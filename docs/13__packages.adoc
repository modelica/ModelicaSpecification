== Packages
:id: packages

Packages in Modelica may contain definitions of constants and classes including all kinds of specialized classes, functions, and subpackages.
By the term _subpackage_ we mean that the package is declared inside another package, no inheritance relationship is implied.
Parameters and variables cannot be declared in a package.
The definitions in a package should typically be related in some way, which is the main reason they are placed in a particular package.
Packages are useful for a number of reasons:

* Definitions that are related to some particular topic are typically grouped into a package. This makes those definitions easier to find and the code more understandable.

* Packages provide encapsulation and coarse-grained structuring that reduces the complexity of large systems. An important example is the use of packages for construction of (hierarchical) class libraries.

* Name conflicts between definitions in different packages are eliminated since the package name is implicitly prefixed to names of definitions declared in a package.

* Information hiding and encapsulation can be supported to some extent by declaring `protected` classes, types, and other definitions that are available only inside the package and therefore inaccessible to outside code.

* Modelica defines a method for locating a package by providing a standard mapping of package names to storage places, typically file or directory locations in the file system.

=== Package as Specialized Class

The package concept is a specialized class (see <<specialized-classes>>), using the keyword `package`.

=== Importing Definitions from a Package

The `import` clause makes public classes and other public definitions declared in some package available for use by shorter names in a class or a package.
It is the only way of referring to definitions declared in some other package for use inside an encapsulated package or class.

[NOTE]
--
The `import` clauses in a package or class fill the following two needs:

* Making definitions from other packages available for use (by shorter names) in a package or class.

* Explicit declaration of usage dependences on other packages.
--

An `import` clause can occur in one of the following syntactic forms:

[source,modelica]
----
import definitionname;                         // qualified import of top-level definition
import packagename.definitionname;             // qualified import
import packagename.{def1, def2, ..., defn};    // multiple definition import
import packagename.*;                          // unqualified import
import shortname = definitionname;             // renaming import of top-level definition
import shortname = packagename.definitionname; // renaming import
----

Here `packagename` is the fully qualified name of the imported package including possible dot notation and `definitionname` is the name of an element in a package.
The multiple definition import is equivalent to multiple single definition imports with corresponding `packagename` and definition names.

==== Lookup of Imported Names

This section only defines how the imported name is looked up in the `import` clause.
For lookup in general -- including how `import` clauses are used -- see <<static-name-lookup>>.

Lookup of the name of an imported package or class deviates from the normal lexical lookup.

For example, consider `A.B.C` in the import clauses `import A.B.C;`, `import D = A.B.C;`, or `import A.B.C.*;`.
Here, lookup starts with the lexical lookup of the first part of the name (`A`) at the top level.

Qualified import clauses may only refer to packages or elements of packages, i.e., in `import A.B.C;` or `import D = A.B.C;`, `A.B` must be a package.
Unqualified import clauses may only import from packages, i.e., in `import A.B.*;`, `A.B` must be a package.

[NOTE]
In `import A;` the class `A` can be any class which is an element of the unnamed top-level package.

[example]
====
For example, if the package `ComplexNumbers` would have been declared as a subpackage inside the package `Modelica.Math`, its fully qualified name would be `Modelica.Math.ComplexNumbers`.
`definitionname` is the simple name without dot notation of a single definition that is imported.
A `shortname` is a simple name without dot notation that can be used to refer to the package after import instead of the presumably much longer `packagename`.

The forms of `import` are exemplified below assuming that we want to access the addition operation of the hypothetical package `Modelica.Math.ComplexNumbers`:

[source,modelica]
----
import Modelica.Math.ComplexNumbers;         // Accessed by ComplexNumbers.Add
import Modelica.Math.ComplexNumbers.Add;     // Accessed by Add
import Modelica.Math.ComplexNumbers.{Add,Sub}; // Accessed by Add and Sub
import Modelica.Math.ComplexNumbers.*;       // Accessed by Add
import Co = Modelica.Math.ComplexNumbers;    // Accessed by Co.Add
----
====

==== Rules for Import Clauses

The following rules apply to `import` clauses:

* The `import` clauses are _not_ inherited.

* The `import` clauses are not named elements of a class or package. This means that `import` clauses cannot be changed by modifiers or redeclarations.

* The _order_ of `import` clauses does not matter.

* One can only import _from_ packages, not from other kinds of classes. Both packages and classes can be imported _into_, i.e., they may contain `import` clauses.

* An imported package or definition should always be referred to by its fully qualified name in the `import` clause.

* Multiple qualified `import` clauses shall not have the same import name (see <<simple-name-lookup>>).

=== The Modelica Library Path - MODELICAPATH

The top-level scope implicitly contains a number of classes stored externally.
If a top-level name is not found at global scope, a Modelica translator shall look up additional classes in an ordered list of library roots, called `MODELICAPATH`.

[NOTE]
The implementation of `MODELICAPATH` is tool dependent.
In order that a user can work in parallel with different Modelica tools, it is advisable to not have this list as environment variable, but as a setting in the respective tool.
Since `MODELICAPATH` is tool dependent, it is not specified in which way the list of library roots is stored.
Typically, on a Windows system `MODELICAPATH` is a string with path names separated by `;` whereas on a Linux system it is a string with path names separated by a `:`.

In addition a tool may define an internal list of libraries, since it is in general not advisable for a program installation to modify global environment variables.
The version information for a library (as defined in <<annotations-for-version-handling>>) may also be used during this search to search for a specific version of the library (e.g., if Modelica library version 2.2 is needed and the first directory in `MODELICAPATH` contain Modelica library version 2.1, whereas the second directory contains Modelica version 2.2, then Modelica library version 2.2 is loaded from the second directory.).

[NOTE]
The first part of the path `A.B.C` (i.e., `A`) is located by searching the ordered list of roots in `MODELICAPATH`.
If no root contains `A` the lookup fails.
If `A` has been found in one of the roots, the rest of the path is located in `A`; if that fails, the entire lookup fails without searching for `A` in any of the remaining roots in `MODELICAPATH`.

If during lookup a top-level name is not found in the unnamed top-level scope, the search continues in the package hierarchies stored in these directories.

[example]
====
Example: Assume `MODELICAPATH = C:\library;C:\lib1;C:\lib2`, with three directories containing the roots of the package hierarchies `Modelica`, `MyLib`, and `ComplexNumbers`.
The first two are represented as the subdirectories `C:\library\Modelica` and `C:\lib1\MyLib`, whereas the third is stored as the file `C:\lib2\ComplexNumbers.mo`.

.Roots of package hierarchies, e.g., `Modelica`, `MyLib`, and `ComplexNumbers` in `MODELICAPATH = C:\library;C:\lib1;C:\lib2`.
image::media/modelicapath.svg[]

Assume that we want to access the package `MyLib.Pack2` in the figure above, e.g., through an import clause `import MyLib.Pack2;`.
During lookup we first try to find a package `MyLib` corresponding to the first part of the name in the import-statement.
It is not found in the top-level scope since it has not previously been loaded into the environment.

Since the name was not found in the top-level scope the search continues in the directories in the `MODELICAPATH` in the specified order.
For the search to succeed, there must be a subdirectory `MyLib` or a file `MyLib.mo` in one of the directories mentioned in the `MODELICAPATH`.
If there is no such subdirectory or file, the lookup fails.
If `MyLib` is found in one of the directories, the rest of the name, in this case `Pack2`, is located in `MyLib`.
If that fails, the entire lookup fails without continuing the search in possibly remaining directories.

In this example the name matches the subdirectory named `MyLib` in the second directory `C:\lib1` mentioned in the `MODELICAPATH`.
This subdirectory must have a file `package.mo` containing a definition of the package `MyLib`, according to the Modelica rules on how to map a package hierarchy to the file system.
The subpackage `Pack2` is stored in its own subdirectory or file in the subdirectory `MyLib`.
In this case the search succeeds and the package `MyLib.Pack2` is loaded into the environment.
====

=== File System Mapping of Package/Class

A package/class hierarchy may be represented in the hierarchical structure of the operating system (the file system).
For classes with version information see also <<versions-in-the-file-system>>.
The nature of such an external entity falls into one of the following two groups:

* Directory in the file system.

* File in the file system.

Each Modelica file in the file system is stored in UTF-8 format (defined by The Unicode Consortium; https://unicode.org).
A deprecated feature is that the file may start with the UTF-8 encoded BOM (byte order mark; `0xef 0xbb 0xbf`); this is treated as white-space in the grammar.
Since the use of BOM is deprecated, tools can ignore any BOM when reading, and it is recommended to never write it.

[NOTE]
Tools may also store classes in data-base systems, but that is not standardized.

==== Directory Hierarchy Mapping

A directory shall contain a node, the file `package.mo`.
The node shall contain a `stored-definition` that defines a class `A` with a name matching the name of the structured entity.

[NOTE]
The node typically contains documentation and graphical information for a package, but may also contain additional elements of the class `A`.

A directory may also contain one or more sub-entities (directories or files).
The sub-entities are mapped as elements of the class defined by their enclosing structured entity.
Two sub-entities shall not define classes with identical names.

[example]
====
Example: If directory `A` contains the three files `package.mo`, `B.mo` and `C.mo`, the classes defined are `A`, `A.B`, and `A.C`.
====

[example]
====
Example: A directory shall not contain both the sub-directory `A` and the file `A.mo`.
====

In order to preserve the order of sub-entities it is advisable to create a file `package.order` where each line contains the name of one class or constant (using its Modelica `IDENT` form).
If a `package.order` is present when reading a structured entity the classes and constants are added in this order; if the contents does not exactly match the classes and constants in the package, the resulting order is tool specific and a warning may be given.
Classes and constants that are stored in `package.mo` are also present in `package.order` but their relative order should be identical to the one in `package.mo` (this ensures that the relative order between classes and constants stored in different ways is preserved).

==== Single File Mapping

When mapping a package or class hierarchy to a file (e.g., the file `A.mo`), the file content shall match `stored-definition` in the grammar.
In this case, the `stored-definition` shall only define a single class whose name (here, `A`) matches the name of the nonstructured entity.
The filename shall have the extension `.mo`.

==== The within Clause

A `within` clause has the following syntax:

[source,grammar]
----
within [ packageprefixname ] ;
----

A non-top-level entity shall begin with a `within` clause which for the class defined in the entity specifies the location in the Modelica class hierarchy.
A top-level class may contain a `within` clause with no name.
For a sub-entity of an enclosing structured entity, the `within` clause shall designate the class of the enclosing entity; and this class must exist and must not have been defined using a short class definition.
See <<stored-definitions-containing-multiple-class-definitions>> regarding the use of `within` clause when a `stored-definition` does not hold exactly one class definition.

[example]
====
Example: The subpackage `Rotational` declared within `Modelica.Mechanics` has the fully qualified name `Modelica.Mechanics.Rotational`, which is formed by concatenating the `packageprefixname` with the short name of the package.
The declaration of `Rotational` could be given as below:

[source,modelica]
----
within Modelica.Mechanics;
package Rotational // Modelica.Mechanics.Rotational
  ...
end Rotational;
----
====

=== Stored Definitions Containing Multiple Class Definitions

The `stored-definition` in the grammar allows for zero or more class definitions, but a `stored-definition` not containing exactly one class definition can only be used to define top-level classes, cannot be used for file system mapping of packages or class-hierarchies (see <<file-system-mapping-of-packageclass>>), and shall be ignored when searching the `MODELICAPATH` (see <<the-modelica-library-path-modelicapath>>).
It follows that any `within` clause (see <<the-within-clause>>) in such a `stored-definition` shall not contain a `packageprefixname`.

=== External Resources

Examples of references to external resources include links and images in HTML documentation, and images in the `Bitmap` annotation (see <<bitmap>>).
Absolute URIs should be used, for example `file:///` and the URI scheme `modelica:/` which can be used to retrieve resources associated with a package.
According to the URI specification scheme names are case-insensitive, but the lower-case form should be used, that is `Modelica:/` is allowed but `modelica:/` is the recommended form.

The Modelica-scheme has the ability to reference a hierarchical structure of resources associated with packages.
The same structure is used for all kind of resource references, independent of use (external file, image in documentation, bitmap in icon layer, and link to external file in the documentation), and regardless of the storage mechanism.

Any Modelica-scheme URI containing a slash after the package-name is interpreted as a reference to a resource.
The first _segment_ of the _path_ of the URI is interpreted as a fully qualified package name and the rest of the _path_ of the URI is interpreted as the path (relative to the package) of the resource.
Each storage scheme can define its own interpretation of the path (but care should be taken when converting from one storage scheme or when restructuring packages that resource references resolve to the same resource).
Any storage scheme should be constrained such that a resource with a given path should be unique for any package name that precedes it.
The second segment of the path shall not be the name of a class in the package given by the first segment.

As a deprecated feature the URI may start with `modelica://` and use the host-part of the authority as the fully qualified package name.
That feature is widely used, but deprecated since host-names are generally case-insensitive.

[NOTE]
Examples of deprecated URIs would be `modelica://Modelica/Resources/C.jpg` (referring to a resource) and `modelica://Modelica.Blocks` (referring to a package).
These should be rewritten as `modelica:/Modelica/Resources/C.jpg` and `modelica:/Modelica.Blocks`.

When Modelica packages are stored hierarchically in a file system (i.e., package `A` in a directory `A` containing `package.mo`) the resource
`modelica:/A/Resources/C.jpg` should be stored in the file `A/Resources/C.jpg`, it is not recommend to use `modelica:/A.B/C.jpg` for referencing resources; it could be stored in the file `A/B/C.jpg` -- which is counter-intuitive if `A.B` is stored together with `A`.
When Modelica packages are stored in other formats a similar mapping should be defined, such that a resource with a given path should be unique for any package name that precedes it.
The second segment of the path shall not be the name of a class in the package given by the first segment.
As above for `Modelica 3.2.1/package.mo`, i.e., resources starting from `Modelica 3.2.1`, and `modelica:/Modelica.Mechanics/C.jpg` is `Modelica 3.2.1/Mechanics/C.jpg` -- regardless of whether `Modelica.Mechanics` is stored in `Modelica 3.2.1/package.mo`, `Modelica 3.2.1/Mechanics.mo`, or `Modelica 3.2.1/Mechanics/package.mo`.

When mapping a Modelica URI to a file system path, the file system path shall end in a directory separator if and only if the URI path ends in the segment separator `/`.
For example, if `modelica:/A/Resources` maps to `A/Resources`, then `modelica:/A/Resources/` maps to `A/Resources/`, and vice versa.

[NOTE]
The use of a trailing segment separator is recommended when the resource is a directory and the file system path will be prepended to relative file paths within the directory.
If possible, use URIs for specific files or specific sub-directories instead of appending relative paths to a generic URI such as `modelica:/A/Resources/` as the latter creates a dependency on the entire directory.

For a Modelica-package stored as a single file, `A.mo`, the resource `modelica:/A/C.jpg` refers to a file `C.jpg` stored in the same directory as `A.mo`, but using resources in this variant is not recommended since multiple packages will share resources.

In case the name of the class contains quoted identifiers, the single-quote `'` and any reserved characters (`:`, `/`, `?`, `#`, `[`, `]`, `@`, `!`, `$`, `&`, `(`, `)`, `*`, `+`, `,`, `;`, `=`) should be percent-encoded as normal in URIs.

[example]
====
Example: Consider a top-level package `Modelica` and a class `Mechanics` inside it, a reference such as `modelica:/Modelica.Mechanics/C.jpg` is legal, while `modelica:/Modelica/Mechanics/C.jpg` is illegal.
The references `modelica:/Modelica.Mechanics/C.jpg` and `modelica:/Modelica/C.jpg` must also refer to two distinct resources.
====

=== Multilingual Descriptions

[NOTE]
Descriptive texts in a model or library are usually formulated in English.
This section describes how a tool can present the library in another language.
Translated Modelica text is provided by external files, so that no modification of the original Modelica text is required.

The texts in following Modelica constructs should be translated:

* description strings of component declarations and classes

* strings in the following annotations:

** `Text.string`, `Text.textString`

** `missingInnerMessage`, `obsolete`, `unassignedMessage`

** `Dialog.group`, `Dialog.tab`

** `Dialog.loadSelector.caption`, `Dialog.loadSelector.filter`, `Dialog.saveSelector.caption`, `Dialog.saveSelector.filter`

** `Documentation.info`, `Documentation.revisions`

** `Figure.title`, `Figure.caption`, `Figure.group`, `Plot.title`, `Axis.label`, `Curve.legend`

** `mustBeConnected`

[NOTE]
None of the translatable constructs can have any impact on simulation results.

Comments (delimited as well as rest-of-line) are not translated.
Only constructs given entirely by one or more concatenated string literals are translated, using nothing but the operator `+` for concatenation.
In order to have parameter values as part of the texts the special substitution syntax is preferable (see <<text>> and <<variable-replacements>>), and translators need to be aware of these substrings in order to make good translations.

[example]
====
Example: Consider:

[source,modelica]
----
annotation(..., Text(string = "1st Frequency: %f1"),
               Text(string = "2nd Frequency: " + String(w2 / (2 * pi))), ...);
----

In this example only `"1st Frequency: %f1"` can be translated; the second `Text.string` doesn't consist entirely of concatenated string literals, and is hence completely excluded from translation.
====

The files to support translation must be provided along with the library.
They must be stored in the resources directory `modelica://LibraryName/Resources/Language/`.

Two kind of files in Gettext format have to be provided:

. Template file `LibraryName.pot` (Portable Object Template), one file per library which is stored as the resource `modelica://LibraryName/Resources/Language/LibraryName.pot`.
It describes all translatable strings in the library, but does not contain any translations.
The pattern `LibraryName` denotes the toplevel class name of the library.

. One file for each supported language with the name `LibraryName.language.po` (Portable Object), as the resource `modelica://LibraryName/Resources/Language/LibraryName.language.po`.
This file is a copy of the associated template file, but extended with the translations in the specified language.
The pattern `language` stands for the ISO 639-1 language code, e.g., `de` or `sv`.

The detailed format of these files is described in the Gettext Manual.
Use of translation files in other formats (including the binary MO file format) is not standardized in Modelica.
For Modelica translations, only the keywords `msgctxt`, `msgid` and `msgstr` are used, meaning that a translation entry looks like this:

[source,text]
----
#: filename:lineNumber
#, no-c-format
msgctxt messageContext
msgid messageIdentifier
msgstr messageTranslation
----

The restriction to a few keywords makes it easier for tools to support the format without relying on the implementation from <<GettextManual>>.

The use of `no-c-format` ensures that translation tools will not parse `"%class"` as the format specifier `%c` followed by _lass_.

[NOTE]
--
In the remainder of this section, several facts about the gettext specification are interleaved non-normatively for easy access to some of the gettext basics.
Always refer to the external gettext specification for full detail or in case of doubt.

All text strings are in double quotes and encoded with UTF-8 characters.
Comments start with a `#` and are continued until the end of line.
Spaces outside strings are ignored and used as separators.

The files consist of a header and a body.
The header is marked with an empty `msgid` and looks like this:

[source,text]
----
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-15 10:52+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
----

All general terms in the header should be replaced by specific information.

Following the header, there is one translation entry for each string to be translated.
It can start with an optional comment describing the location (file name and line number) of the text to translate.
Multiple occurrences of the same string can be listed here, separated by space.
--

The `messageContext` following the keyword `msgctxt` shall be the full name of the Modelica class (e.g., `"Modelica.Blocks.Math.Sin"`) where the text appears.
Short class definitions do not appear here.
Texts in such classes belong to the enclosing full class definition.

The text string which shall be translated is used as `messageIdentifier` (following the `msgid` keyword), and shall contain the original string from the Modelica code.
Note that if a `msgid` string is given more than once in the same context, all occurrences are translated with the same (last) translation!

[NOTE]
The `messageTranslation` (following the keyword `msgstr`) is the translation of `messageIdentifier` and is typically edited using special tools for translators.
In the template file this string is empty by definition.
If this is empty in a language specific file the `messageIdentifier` may be used instead.

[NOTE]
--
Since in Modelica control sequences also start with a backslash and another backslash is used to use sequences literally or to hide double quotes, no change is required here.
But Modelica allows strings to go over more than one line, gettext does not.
Therefore, line breaks in Modelica must be encoded with `"\n"` for gettext.

In order to avoid long lines in the translated strings (following `msgid` or `msgstr`), strings may be split into smaller parts given on consecutive lines.
E.g., the Modelica description

[source,modelica]
----
"A
B\"C" + "D\nE"
----

evaluates to:

[source,text]
----
A  
B"CD  
E
----

which in the translation entry looks like:

[source,text]
----
msgid ""
"A\n"
"B\"CD\n"
"E"
----
--

[example]
====
Example: Consider a simple sine-source:

[source,modelica]
----
within MyPackage.Sources;
model Sine "Sine"
  parameter Frequency f=2 "Frequency";
  RealOutput y=sin(2*pi*f*time); // Relying on imported types
  /* Could add details. Note that this is not translated */
  annotation(Icon(graphics={Text(extent={{0,0},{40,40}},
                        textString="Frequency: %f")}));
end Sine;
----

The entries for translating this model into Swedish could look like this:

[source,text]
----
#: MyPackage/Sources/package.mo:10126
#, no-c-format
msgctxt "MyPackage.Sources.Sine"
msgid "Sine"
msgstr "Sinus"
#: MyPackage/Sources/package.mo:10127
#, no-c-format
msgctxt "MyPackage.Sources.Sine"
msgid "Frequency"
msgstr "Frekvens"
#: MyPackage/Sources/package.mo:10131
#, no-c-format
msgctxt "MyPackage.Sources.Sine"
msgid "Frequency: %f"
msgstr "Frekvens: %f"
----
====

[NOTE]
To support the translation of these strings a number of free and commercial tools exist in context of GNU gettext.