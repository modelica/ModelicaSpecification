\chapter{Inheritance, Modification, and Redeclaration}\doublelabel{inheritance-modification-and-redeclaration}

One of the major benefits of object-orientation is the ability to
\emph{extend} the behavior and properties of an existing class. The
original class, known as the \emph{base class}, is extended to create a
more specialized version of that class, known as the \emph{derived
class} or \emph{subclass}. In this process, the data and behavior of the
original class in the form of variable declarations, equations, and
certain other contents are reused, or \emph{inherited}, by the subclass.
In fact, the inherited contents is copied from the superclass into the
subclass, but before copying certain operations, such as type expansion,
checking, and modification, are performed on the inherited contents when
appropriate. This chapter describes the inheritance concept in Modelica,
together with the related concepts modification and redeclaration.

\section{Inheritance---Extends Clause}\doublelabel{inheritance-extends-clause}

The extends-clause is used to specify inheritance from a base class into
an (enclosing) class containing the extends-clause. The syntax of the
extends-clause is as follows:

\begin{lstlisting}[language=grammar]
extends-clause :
   extends name [ class-modification ] [annotation]
\end{lstlisting}
The name of the base class is looked up in the partially flattened
enclosing class (\autoref{enclosing-classes}) of the extends-clause. The found base
class is flattened with a new environment and the partially flattened
enclosing class of the extends-clause. The new environment is the result
of merging

\begin{itemize}
\item
  arguments of all enclosing class environments that match names in the
  flattened base class
\item
  the optional \lstinline!class-modification! of the extends-clause
\end{itemize}

in that order.

{[}\emph{Example}:
\begin{lstlisting}[language=modelica]
class A
  parameter Real a, b;
end A;

class B
  extends A(b=2);
end B;

class C
  extends B(a=1);
end C;
\end{lstlisting}
{]}

The elements of the flattened base class become elements of the
flattened enclosing class, and are added at the place of the
extends-clause: specifically components and classes, the equation
sections, algorithm sections, optional external clause, and the contents
of the annotation at the end of the class, but excluding import-clauses.

{[}\emph{From the example above we get the following flattened class:}
\begin{lstlisting}[language=modelica]
class Cinstance
  parameter Real a=1;
  parameter Real b=2;
end Cinstance;
\end{lstlisting}

\emph{The ordering of the merging rules ensures that, given classes A
and B defined above, }
\begin{lstlisting}[language=modelica]
class C2
  B bcomp(b=3);
end C2;
\end{lstlisting}

\emph{yields an instance with} \lstinline!bcomp.b=3!\emph{, which overrides} b=2.{]}

The declaration elements of the flattened base class shall either

\begin{itemize}
\item
  Not already exist in the partially flattened enclosing class
  {[}\emph{i.e., have different names}{]} .
\item
  The new element is a long form of redeclare or uses the `\lstinline!class extends A!' syntax, see \autoref{redeclaration}.
\item
  Be exactly identical to any element of the flattened enclosing class
  with the same name and the same level of protection (public or
  protected) and same contents. In this case, the first element in order
  (can be either inherited or local) is kept. It is recommended to give
  a warning for this case; unless it can be guaranteed that the
  identical contents will behave in the same way.
\end{itemize}

Otherwise the model is incorrect.

\emph{{[}Clarifiying order:}
\begin{lstlisting}[language=modelica]
function A
  input Real a;
  input Real b;
end A;

function B
  extends A;
  input Real a;
end B;
// The inputs of B are "a, b" in that order; and the "input Real a;" is ignored.
\end{lstlisting}
\emph{{]}}

Equations of the flattened base class that are syntactically equivalent
to equations in the flattened enclosing class are discarded. This
feature is deprecated, and it is recommend to give a warning when
discarding them and for the future give a warning about all forms of
equivalent equations due to inheritance. {[}\emph{Note: equations that
are mathematically equivalent but not syntactically equivalent are not
discarded, hence yield an overdetermined system of equations.}{]}

\subsection{Multiple Inheritance}\doublelabel{multiple-inheritance}

Multiple inheritance is possible since multiple extends-clauses can be
present in a class.

\subsection{Inheritance of Protected and Public Elements}\doublelabel{inheritance-of-protected-and-public-elements}

If an extends-clause is used under the \lstinline!protected! heading, all elements
of the base class become protected elements of the current class. If an
extends-clause is a public element, all elements of the base class are
inherited with their own protection. The eventual headings \lstinline!protected! and
\lstinline!public! from the base class do not affect the consequent elements of the
current class (i.e., headings \lstinline!protected! and \lstinline!public! are not inherited).

\subsection{Restrictions on the Kind of Base Class}\doublelabel{restrictions-on-the-kind-of-base-class}

Since specialized classes of different kinds have different properties,
see \autoref{specialized-classes}, only specialized classes that are ``in some sense
compatible'' to each other can be derived from each other via
inheritance. The following table shows which kind of specialized class
can be used in an extends clause of another kind of specialized class
(the ``grey'' cells mark the few exceptional cases, where a specialized
class can be derived from a specialized class of another kind):

% LaTeXML does not handle resizebox. So don't use it for HTML

\begin{table}[H]
% latexml does not like resizebox
  \ifpdf\resizebox{\textwidth}{!}{\else\fi%

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
                      & \multicolumn{12}{c|}{\textbf{Base Class}}                                                                                                                                                                                                                                                                                                                          \\
    \hline
     \textbf{Derived} & \multirow{2}{*}{package} & \multirow{2}{*}{operator} & \multirow{2}{*}{function}                  & operator             & \multirow{2}{*}{type}    & \multirow{2}{*}{record}  & operator                 & expandable               & \multirow{2}{*}{connector} & \multirow{2}{*}{block}   & \multirow{2}{*}{model} & \multirow{2}{*}{class}                     \\
     \textbf{Class}   &                          &                           &                                            & function             &                          &                          & record                   & connector                &                            &                          &                        &                                            \\
     \hline
    package           & yes                      &                           &                                            &                      &                          &                          &                          &                          &                            &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    operator          &                          & yes                       &                                            &                      &                          &                          &                          &                          &                            &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    function          &                          &                           & yes                                        &                      &                          &                          &                          &                          &                            &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    operator          &                          &                           & \cellcolor{lightgray}                      & \multirow{2}{*}{yes} &                          &                          &                          &                          &                            &                          &                        & \cellcolor{lightgray}                      \\
    function          &                          &                           & \multirow{-2}{*}{\cellcolor{lightgray}yes} &                      &                          &                          &                          &                          &                            &                          &                        & \multirow{-2}{*}{\cellcolor{lightgray}yes}  \\
    \hline
    type              &                          &                           &                                            &                      & yes                      &                          &                          &                          &                            &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    record            &                          &                           &                                            &                      &                          & yes                      &                          &                          &                            &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    operator          &                          &                           &                                            &                      &                          &                          & \multirow{2}{*}{yes}     &                          &                            &                          &                        & \cellcolor{lightgray}                      \\
    record            &                          &                           &                                            &                      &                          &                          &                          &                          &                            &                          &                        & \multirow{-2}{*}{\cellcolor{lightgray}yes} \\
    \hline
    expandable        &                          &                           &                                            &                      &                          &                          &                          & \multirow{2}{*}{yes}     &                            &                          &                        & \cellcolor{lightgray}                      \\
    connector         &                          &                           &                                            &                      &                          &                          &                          &                          &                            &                          &                        & \multirow{-2}{*}{\cellcolor{lightgray}yes} \\
    \hline
    connector         &                          &                           &                                            &                      & \cellcolor{lightgray}yes & \cellcolor{lightgray}yes & \cellcolor{lightgray}yes & \cellcolor{lightgray}yes & yes                        &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    block             &                          &                           &                                            &                      &                          & \cellcolor{lightgray}yes &                          &                          &                            & yes                      &                        & \cellcolor{lightgray}yes                   \\
    \hline
    model             &                          &                           &                                            &                      &                          & \cellcolor{lightgray}yes &                          &                          &                            & \cellcolor{lightgray}yes & yes                    & \cellcolor{lightgray}yes                   \\
    \hline
    class             &                          &                           &                                            &                      &                          &                          &                          &                          &                            &                          &                        & yes                                        \\
    \hline
  \end{tabular}
% close resizebox
  \ifpdf}\else\fi%
\end{table}

If a derived class is inherited from another type of specialized class,
then the result is a specialized class of the derived class type.
{[}\emph{For example, if a} \lstinline!block! \emph{inherits from a} \lstinline!record! \emph{, then the result
is a} \lstinline!block!\emph{.}{]}

All specialized classes can be derived from \lstinline!class! {[}\emph{provided the
resulting class fulfills the restriction of the specialized class. It is
recommended to use the most specific specialized class.}{]} A \lstinline!class! may
only contain class-definitions, annotations, and extends-clauses (having
any other contents is deprecated).

The specialized classes \lstinline!package!, \lstinline!operator!, \lstinline!function!,
\lstinline!type,! \lstinline!record!,
\lstinline!operator record,! and expandable connector can only be derived from their
own kind {[}\emph{(e.g. a package can only be base class for packages.
All other kinds of classes can use the import statement to use the
contents of a package)}{]} and from \lstinline!class!\emph{.}

{[}\emph{Examples}:
\begin{lstlisting}[language=modelica]
record RecordA
  ...
end RecordA;

package PackageA
  ...
end PackageA;

package PackageB
  extends PackageA; // fine
end PackageB;

model ModelA
  extends RecordA; // fine
end ModelA;

model ModelB
  extends PackageA; // error, inheritance not allowed
end ModelB;
\end{lstlisting}
{]}

\subsection{Restrictions on Base Classes and Constraining Types to be Transitively Non-Replaceable}\doublelabel{restrictions-on-base-classes-and-constraining-types-to-be-transitively-non-replaceable}

The class name used after extends for base-classes and for constraining
classes must use a class reference considered transitively
non-replaceable, see definition in \autoref{transitively-non-replaceable}. {[}\emph{This
formulation excludes the long form of redeclare, i.e. `}\lstinline!redeclare model extends M...!\emph{' where} \lstinline!M! \emph{must be an inherited replaceable
class.}{]} For a replaceable component declaration without constraining
clause the class must use a class reference considered transitively
non-replaceable. {[}\emph{This implies that constraining classes are
always transitively non-replaceable -- both if explicitly given or
implicitly by the declaration.}{]}

\section{Modifications}\doublelabel{modifications}

There are three kinds of constructs in the Modelica language in which
modifications can occur:

\begin{itemize}
\item
  Variable declarations.
\item
  Short class declarations.
\item
  Extends-clauses.
\end{itemize}

A modifier modifies one or more declarations from a class by changing
some aspect(s) of the declarations. The most common kind of modifier
just changes the \emph{default value} or the \emph{start value} in a
binding equation; the value and/or start-value should be compatible with
the variable according to \autoref{type-compatible-expressions}.

{[}\emph{Example: Modifying the default} \lstinline!start! \emph{value of the}
\lstinline!altitude! \emph{variable}:
\begin{lstlisting}[language=modelica]
Real altitude(start= 59404);
\end{lstlisting}
{]}

A modification (i.e. C1 c1(x = 5) is considered a modification equation,
if the modified variable is a non-parameter (here: c1.x) variable.
{[}\emph{This equation is created, if the modified component (here: c1)
is also created (see \autoref{class-declarations}). In most cases a
modification equation for a non-parameter variable requires that the
variable was declared with a declaration equation, see \autoref{balanced-models};
in those cases the declaration equation is replaced by the
modification equation.}{]}

A more dramatic change is to modify the \emph{type} and/or the
\emph{prefixes} and possibly the \emph{dimension sizes} of a declared
element. This kind of modification is called a \emph{redeclaration}
(\autoref{redeclaration}) and requires the special keyword \lstinline!redeclare! to be used in
the modifier in order to reduce the risk for accidental modeling errors.
In most cases a declaration that can be redeclared must include the
prefix \lstinline!replaceable! (\autoref{redeclaration}). The modifier value (and class for
redeclarations) is found in the context in which the modifier occurs,
see also \autoref{simple-name-lookup}.

{[}\emph{Example: Scope for modifiers}
\begin{lstlisting}[language=modelica]
model B
  parameter Real x;
  package Medium=Modelica.Media.PartialMedium;
end B;

model C
  parameter Real x=2;
  package Medium=Modelica.Media.PartialMedium;
  B b(x=x, redeclare package Medium=Medium);
  // The 'x' and 'Medium' being modified are declared in the model B.
  // The modifiers '=x' and '=Medium' are found in the model C.
end C;

model D
  parameter Real x=3;
  package Medium=Modelica.Media.PartialMedium;
  C c(b(x=x, redeclare package Medium=Medium));
  // The 'x' and 'Medium' being modified are declared in the model B.
  // The modifiers '=x' and '=Medium' are found in the model D.
end D;
\end{lstlisting}

{]}
When present, the description string of a modifier overrides the existing description.

\subsection{Syntax of Modifications and Redeclarations}\doublelabel{syntax-of-modifications-and-redeclarations}

The syntax is defined in the grammar, \autoref{modification}.

\subsection{Modification Environment}\doublelabel{modification-environment}

The modification environment contains arguments which modify elements of
the class (e.g., parameter changes). The modification environment is
built by merging class modifications, where outer modifications override
inner modifications. {[}\emph{Note: this should not be confused with}
\lstinline!inner outer! \emph{prefixes described in \autoref{instance-hierarchy-name-lookup-of-inner-declarations}}{]}

\subsection{Merging of Modifications}\doublelabel{merging-of-modifications}

Merging of modifiers means that outer modifiers override inner
modifiers. The merging is hierarchical, and a value for an entire
non-simple component overrides value modifiers for all components, and
it is an error if this overrides a final prefix for a component, or if
value for a simple component would override part of the value of a
non-simple component. When merging modifiers each modification keeps its
own each-prefix.

{[}\emph{The following larger example demonstrates several aspects:}
\begin{lstlisting}[language=modelica]
class C1
  class C11
    parameter Real x;
  end C11;
end C1;

class C2
  class C21
    ...
  end C21;
end C2;

class C3
  extends C1;
  C11 t(x=3);
  // ok, C11 has been inherited from C1
  C21 u;
  // ok, even though C21 is inherited below
  extends C2;
end C3;
\end{lstlisting}
\emph{The following example demonstrates overriding part of non-simple
component: }
\begin{lstlisting}[language=modelica]
record A
  parameter Real x;
  parameter Real y;
end A;

model B
  parameter A a=A(2, 3);
end B;

model C
  B b1(a(x=4));
  // Error since attempting to override value for a.x when a has a value.
end C;
\end{lstlisting}

\emph{The modification environment of the declaration of} \lstinline!t! \emph{is
(}\lstinline!x=3!\emph{). The modification environment is built by merging class
modifications, as shown by: }
\begin{lstlisting}[language=modelica]
class C1
  parameter Real a;
end C1;

class C2
  parameter Real b;
  parameter Real c;
end C2;

class C3
  parameter Real x1;
  // No default value
  parameter Real x2=2;
  // Default value 2
  parameter C1 x3;
  // No default value for x3.a
  parameter C2 x4(b=4);
  // x4.b has default value 4
  parameter C1 x5(a=5);
  // x5.a has default value 5
  extends C1;
  // No default value for inherited element a
  extends C2(b=6, c=77);
  // Inherited b has default value 6
end C3;

class C4
  extends C3(x2=22, x3(a=33), x4(c=44), x5=x3, a=55, b=66);
end C4;
\end{lstlisting}

\emph{Outer modifications override inner modifications, e.g.,} \lstinline!b=66!
\emph{overrides the nested class modification of extends} \lstinline!C2(b=6)!.
\emph{This is known as merging of modifications}: merge\lstinline!((b=66), (b=6))!
\emph{becomes} \lstinline!(b=66)!.

\emph{A flattening of class} \lstinline!C4! \emph{will give an object with the
following variables: }

\begin{longtable}[]{|@{}l|l@{}|}
\hline \endhead
\emph{Variable} & \emph{Default value}\\ \hline
\lstinline!x1! & \lstinline!none!\\ \hline
\lstinline!x2! & \lstinline!22!\\ \hline
\lstinline!x3.a! & \lstinline!33!\\ \hline
\lstinline!x4.b! & \lstinline!4!\\ \hline
\lstinline!x4.c! & \lstinline!44!\\ \hline
\lstinline!x5.a! & \lstinline!x3.a!\\ \hline
\lstinline!a! & \lstinline!55!\\ \hline
\lstinline!b! & \lstinline!66!\\ \hline
\lstinline!c! & \lstinline!77!\\ \hline
\end{longtable}

{]}

\subsection{Single Modification}\doublelabel{single-modification}

Two arguments of a modification shall not modify the same element,
attribute, or string-comment. When using qualified names the different
qualified names starting with the same identifier are merged into one
modifier. If a modifier with a qualified name has the each or
final-prefix that prefix is only seen as applied to the final part of
the name.

{[}\emph{Example}:
\begin{lstlisting}[language=modelica]
class C1
  Real x[3];
end C1;
class C2 = C1(x=ones(3), x=ones(3)); // Error: x designated twice
class C3
  class C4
    Real x;
  end C4;
  C4 a(final x.unit = "V", x.displayUnit="mV", x=5.0);
  // Ok, different attributes designated (unit, displayUnit and value)
  // identical to:
  C4 b(x(final unit = "V", displayUnit="mV") = 5.0));
end C3;
\end{lstlisting}

\emph{The following examples are incorrect:}
\begin{lstlisting}[language=modelica]
m1(r=1.5, r=1.6) // Multiple modifier for r (its value)
m1(r=1.5, r=1.5) // Multiple modifier for r (its value) - even if identical
m1(r.start=2, r(start=3)) // Multiple modifier for r.start
m1(x.r=1.5 "x", x.r(start=2.0) "y")) // Multiple string-comment for x.r
m1(r=R(), r(y=2)) // Multiple modifier for r.y - both direct value and part of record
\end{lstlisting}
\emph{The following examples are correct:}
\begin{lstlisting}[language=modelica]
m1(r=1.5, r(start=2.0))
m1(r=1.6, r "x")
m1(r=R(), r(y(min=2)))
\end{lstlisting}
{]}

\subsection{Modifiers for Array Elements}\doublelabel{modifiers-for-array-elements}

The following rules apply to modifiers:

\begin{itemize}
\item
  The \lstinline!each! keyword on a modifier requires that it is applied in an array
  declaration/modification, and the modifier is applied individually to
  each element of the array (in case of nested modifiers this implies it
  is applied individually to each element of each element of the
  enclosing array; see example). If the modified element is a vector and
  the modifier does not contain the \lstinline!each!-prefix, the modification is
  split such that the first element in the vector is applied to the
  first element of the vector of elements, the second to the second
  element, until the last element of the vector-expression is applied to
  the last element of the array; it is an error if these sizes do not
  match. Matrices and general arrays of elements are treated by viewing
  those as vectors of vectors etc.
\item
  If a nested modifier is split, the split is propagated to all elements
  of the nested modifier, and if they are modified by the \lstinline!each!-keyword
  the split is inhibited for those elements. If the nested modifier that
  is split in this way contains re-declarations that are split it is
  illegal.
\end{itemize}

{[}\emph{Example}:
\begin{lstlisting}[language=modelica]
model C
  parameter Real a [3];
  parameter Real d;
end C;

model B
  C c[5](each a ={1,2,3}, d={1,2,3,4,5});
  parameter Real b=0;
end B;
\end{lstlisting}

\emph{This implies that} \lstinline!c[i].a[j]=j!\emph{, and}
\lstinline!c[i].d=i!\emph{.}
\begin{lstlisting}[language=modelica]
model D
  B b(each c.a={3,4,5}, c.d={2,3,4,5,6});
  // Equivalent to:
  B b2(c(each a={3,4,5}, d={2,3,4,5,6}));
end D;
\end{lstlisting}

\emph{This implies that} \lstinline!b.c[i].a[j]=2+j! \emph{and}
\lstinline!b.c[i].d=1+i!
\begin{lstlisting}[language=modelica]
model E
  B b[2](each c(each a={1,2,3}, d={1,2,3,4,5}), p={1,2});
  // Without the first each one would have to use:
  B b2[2](c(each a={1,2,3}, d=fill({1,2,3,4,5},2)), p={1,2});
end E;
\end{lstlisting}
\emph{This implies that} \lstinline!b[k].c[i].a[j]=j! \emph{and}
\begin{lstlisting}[language=modelica]
  b[k].c[i].d=i and b[k].p=k
\end{lstlisting}
\emph{For 'c.a' the additional (outer) each has no effect, but it is
necessary for 'c.d'.}

{]}

\subsection{Final Element Modification Prevention}\doublelabel{final-element-modification-prevention}

An element defined as final by the \lstinline!final! prefix in an element
modification or declaration cannot be modified by a modification or by a
redeclaration. All elements of a final element are also final.
{[}\emph{Setting the value of a parameter in an experiment environment
is conceptually treated as a modification. This implies that a final
modification equation of a parameter cannot be changed in a simulation
environment}{]}.

{[}\emph{Examples}:
\begin{lstlisting}[language=modelica]
type Angle = Real (final quantity="Angle",final unit="rad",displayUnit="deg");

model TransferFunction
  parameter Real b[:]={1} "numerator coefficient vector";
  parameter Real a[:]={1,1} "denominator coefficient vector";
  ...
end TransferFunction;

model PI "PI controller"
  parameter Real k=1 "gain";
  parameter Real T=1 "time constant";
  TransferFunction tf(final b=k*{T,1}, final a={T,0});
end PI;

model Test
  PI c1(k=2, T=3);
  // fine, will indirectly change tf.b to 2*{3,1}
  PI c2(tf(b={1}));
  // error, b is declared as final
end Test;
\end{lstlisting}
{]}

\section{Redeclaration}\doublelabel{redeclaration}

A redeclare construct in a modifier replaces the declaration of a local
class or component with another declaration. A redeclare construct as an
element replaces the declaration of a local class or component with
another declaration. Both redeclare constructs work in the same way. The
redeclare construct as an element requires that the element is
inherited, and cannot be combined with a modifier of the same element in
the extends-clause. For modifiers the redeclare of classes uses a
special short-class-definition construct; that is a subset of normal
class definitions and semantically behave as the corresponding
class-definition.

A modifier with the keyword \lstinline!replaceable! is automatically seen as being a
redeclare.

In redeclarations some parts of the original declaration is
automatically inherited by the new declaration. This is intended to make
it easier to write declarations by not having to repeat common parts of
the declarations, and does in particular apply to prefixes that must be
identical. The inheritance only applies to the declaration itself and
not to elements of the declaration.

The general rule is that if no prefix within one of the following groups
is present in the new declaration the old prefixes of that kind are
preserved.

The groups that are valid for both classes and components:

\begin{itemize}
\item
  public, protected
\item
  \lstinline!inner!, \lstinline!outer!
\item
  constraining type according to rules in \autoref{constraining-type}.
\end{itemize}

The groups that are only valid for components:

\begin{itemize}
\item
  flow, stream
\item
  discrete, parameter, constant
\item
  input, output
\item
  array dimensions
\end{itemize}

Note that if the old declaration was a short class definition with array
dimensions the array dimensions are not automatically preserved, and
thus have to be repeated in the few cases they are used.

Replaceable component array declarations with array sizes on the left of
the component are seen as syntactic sugar for having all arrays sizes on
the right of the component; and thus can be redeclared in a consistent
way.

{[}\emph{Note: The inheritance is from the original declaration. In most
cases replaced or original does not matter. It does matter if a user
redeclares a variable to be a parameter and then redeclares it without
parameter.}{]}

{[}
\begin{lstlisting}[language=modelica]
model HeatExchanger
  replaceable parameter GeometryRecord geometry;
  replaceable input Real u[2];
end HeatExchanger;

  HeatExchanger(
    /*redeclare*/ replaceable /*parameter */ GeoHorizontal geometry,
    redeclare /* input */ Modelica.SIunits.Angle u /*[2]*/);
  // The semantics ensure that parts in /*.*/ are automatically added
   // from the declarations in HeatExchanger.
\end{lstlisting}

\emph{Example of arrays on the left of the component name:}
\begin{lstlisting}[language=modelica]
model M
  replaceable Real [4] x[2];
  // Seen as syntactic sugar for "replaceable Real x[2,4];"
  // Note the order.
end M;
M m(redeclare Modelica.SIunits.Length x[2,4]); // Valid redeclare of the type
\end{lstlisting}

{]}

\subsection{The class extends Redeclaration Mechanism}\doublelabel{the-class-extends-redeclaration-mechanism}

A class declaration of the type `\lstinline!redeclare class extends B(...)!' ,
where \lstinline!class! as usual can be replaced by any other specialized class,
replaces the inherited class \lstinline!B! with another declaration that extends the
inherited class where the optional class-modification is applied to the
inherited class. {[}\emph{Since this implies that all declarations are
inherited with modifications applied there is no need to apply modifiers
to the new declaration.}{]} Inherited B here means that the class
containing \lstinline!redeclare class extends! B(\ldots{}) should also inherit
another declaration of B from one of its extends-clauses. The new
declaration should explicitly include redeclare.

For `\lstinline!redeclare class extends B(...)!' the inherited class is subject
to the same restrictions as a redeclare of the inherited element, and
the original class B should be replaceable, and the new element is only
replaceable if the new definition is replaceable. In contrast to normal
extends it is not subject to the restriction that B should be
transitively non-replaceable (since B should be replaceable).

The syntax rule for \lstinline!class extends! construct is in the definition of the
\lstinline!class-specifier! nonterminal (see also class declarations in \autoref{class-declarations}):

\begin{lstlisting}[language=grammar]
class-definition :
   [ encapsulated ] class-prefixes
   class-specifier

class-specifier : long-class-specifier | ...

long-class-specifier : ...
    | extends IDENT [ class-modification ]string-comment composition end IDENT
\end{lstlisting}
The nonterminal \lstinline!class-definition! is referenced in several places in the
grammar, including the following case which is used in some examples
below, including \lstinline!package extends! and \lstinline!model extends!:
\begin{lstlisting}[language=grammar]
element :
   import-clause |
   extends-clause |
   [ redeclare ]
   [ final ]
   [ inner ] [ outer ]
   ( ( class-definition | component-clause) |
      replaceable ( class-definition | component-clause)
        [constraining-clause comment])
\end{lstlisting}

{[}\emph{Example to extend from existing packages:}
\begin{lstlisting}[language=modelica]
package PowerTrain // library from someone else
  replaceable package GearBoxes
    ...
  end GearBoxes;
end PowerTrain;

package MyPowerTrain
  extends PowerTrain; // use all classes from PowerTrain
  redeclare package extends GearBoxes // add classes to sublibrary
    ...
  end GearBoxes;
end MyPowerTrain;
\end{lstlisting}

\emph{Example for an advanced type of package structuring with
constraining types:}
\begin{lstlisting}[language=modelica]
partial package PartialMedium "Generic medium interface"
  constant Integer nX "number of substances";
  replaceable partial model BaseProperties
    Real X[nX];
    ...
  end BaseProperties;

  replaceable partial function dynamicViscosity
    input Real p;
    output Real eta;...
  end dynamicViscosity;
end PartialMedium;

package MoistAir "Special type of medium"
  extends PartialMedium(nX=2);

  redeclare model extends BaseProperties(T(stateSelect=StateSelect.prefer))
    // replaces BaseProperties by a new implementation and // extends from Baseproperties with modification
    // note, nX = 2 (!)
  equation
    X = {0,1};
    ...
  end BaseProperties;

  redeclare function extends dynamicViscosity
    // replaces dynamicViscosity by a new implementation and
    // extends from dynamicViscosity
  algorithm
    eta := 2*p;
  end dynamicViscosity;
end MoistAir;
\end{lstlisting}

\emph{Note, since} \lstinline!MostAir! \emph{extends from} \lstinline!PartialMedium!\emph{,
constant} \lstinline!nX!\emph{=2 in package} \lstinline!MoistAir! \emph{and the model}
\lstinline!BaseProperties! \emph{and the function} \lstinline!dynamicViscosity! \emph{is present
in} \lstinline!MoistAir!\emph{. By the following definitions, the available}
\lstinline!BaseProperties! \emph{model is replaced by another implementation which
extends from the} \lstinline!BaseProperties! \emph{model that has been temporarily
constructed during the extends of package} \lstinline!MoistAir! \emph{from}
\lstinline!PartialMedium!\emph{. The redeclared} \lstinline!BaseProperties! \emph{model
references constant} \lstinline!nX! \emph{which is 2, since by construction the
redeclared} \lstinline!BaseProperties! \emph{model is in a package with} \lstinline!nX! \emph{=
2.}

\emph{This definition is compact but is difficult to understand. At a
first glance an alternative exists that is more straightforward and
easier to understand: }
\begin{lstlisting}[language=modelica]
package MoistAir2 "Alternative definition that does not work"
  extends PartialMedium(nX=2,
    redeclare model BaseProperties = MoistAir_BaseProperties,
    redeclare function dynamicViscosity = MoistAir_dynamicViscosity);

  model MoistAir_BaseProperties
    // wrong model since nX has no value
    extends PartialMedium.BaseProperties;
  equation
    X = {1,0};
  end MoistAir_BaseProperties;

  model MoistAir_dynamicViscosity
    extends PartialMedium.dynamicViscosity;
  algorithm
    eta := p;
  end MoistAir_dynamicViscosity;
end MoistAir2;
\end{lstlisting}

\emph{Here, the usual approach is used to extend (here from} \lstinline!PartialMedium!\emph{) and
in the modifier perform all redeclarations. In order to perform these
redeclarations, corresponding implementations of all elements of} \lstinline!PartialMedium!
\emph{have to be given under a different name, such as} \lstinline!MoistAir2.MoistAir_BaseProperties!\emph{, since the name}
\lstinline!BaseProperties!
\emph{already exists due to} \lstinline!extends PartialMedium!. \emph{Then it is possible in
the modifier to redeclare} \lstinline!PartialMedium.BaseProperties! \emph{to}
\lstinline!MoistAir2.MoistAir_BaseProperties!\emph{. Besides the drawback that the
namespace is polluted by elements that have different names but the same
implementation (e.g.} \lstinline!MoistAir2.BaseProperties! \emph{is identical to}
\lstinline!MoistAir2.MoistAir_BaseProperties!\emph{) the whole construction does not work
if arrays are present that depend on constants in} \lstinline!PartialMedium! \emph{, such as}
\lstinline!X[nX]!\emph{: The problem is that} \lstinline!MoistAir_BaseProperties!\emph{ extends from}
\lstinline!PartialMedium.BaseProperties! \emph{where the constant nX does not yet have a value.
This means that the dimension of array X is undefined and model}
\lstinline!MoistAir_BaseProperties!\emph{ is wrong. With this construction, all constant
definitions have to be repeated whenever these constants shall be used,
especially in} \lstinline!MoistAir_BaseProperties! \emph{and} \lstinline!MoistAir_dynamicViscosity!\emph{.
For larger models this is not practical and therefore the only
practically useful definition is the complicated construction in the
previous example with} \lstinline!redeclare model extends BaseProperties!\emph{.}

\emph{To detect this issue the rule on lookup of composite names (\autoref{composite-name-lookup})
ensures that}\\ \lstinline!PartialMedium.dynamicViscosity! \emph{is incorrect in a
simulation model.}
{]}

\subsection{Constraining Type}\doublelabel{constraining-type}

In a replaceable declaration the optional \lstinline!constraining-clause! defines a
constraining type. Any modifications following the constraining type
name are applied both for the purpose of defining the actual
constraining type and they are automatically applied in the declaration
and in any subsequent redeclaration. The precedence order is that
declaration modifiers override constraining type modifiers.

If the \lstinline!constraining-clause! is not present in the original declaration
(i.e., the non-redeclared declaration):

\begin{itemize}
\item
  The type of the declaration is also used as a constraining type.
\item
  The modifiers for subsequent redeclarations and constraining type are
  the modifiers on the component or short-class-definition if that is
  used in the original declaration, otherwise empty.
\end{itemize}

The syntax of a constraining-clause is as follows:
\begin{lstlisting}[language=grammar]
constraining-clause :
   constrainedby name [ class-modification ]
\end{lstlisting}
{[}\emph{Example of merging of modifiers}:
\begin{lstlisting}[language=modelica]
class A
  parameter Real x;
end A;

class B
  parameter Real x=3.14, y; // B is a subtype of A
end B;

class C
  replaceable A a(x=1);
end C;

class D
  extends C(redeclare B a(y=2));
end D;
\end{lstlisting}

\emph{which is equivalent to defining D as }
\begin{lstlisting}[language=modelica]
class D
  B a(x=1, y=2);
end D;
\end{lstlisting}
\emph{Example}:

\emph{A modification of the constraining type is automatically applied
in subsequent redeclarations:}
\begin{lstlisting}[language=modelica]
model ElectricalSource
  replaceable SineSource source constrainedby MO(final n=5);
  ...
end ElectricalSource;

model TrapezoidalSource
  extends ElectricalSource(
  redeclare Trapezoidal source); // source.n=5
end TrapezoidalSource;
\end{lstlisting}

\emph{A modification of the base type without a constraining type is
automatically applied in subsequent redeclarations:}
\begin{lstlisting}[language=modelica]
model Circuit
  replaceable model NonlinearResistor = Resistor(R=100);
  ...
end Circuit;

model Circuit2
  extends Circuit(
    redeclare replaceable model NonlinearResistor
                           = ThermoResistor(T0=300));
      // As a result of the modification on the base type,
      // the default value of R is 100
end Circuit2;

model Circuit3
  extends Circuit2(
   redeclare replaceable model NonlinearResistor
                           = Resistor(R=200));
  // The T0 modification is not applied because it did not
  // appear in the original declaration
end Circuit3;
\end{lstlisting}

\emph{Circuit2 is intended to illustrate that a user can still select
any resistor model, including the original one - as is done in Circuit3,
since the constraining type is kept from the original declaration if not
specified in the redeclare. Thus it is easy to select an advanced
resistor model, without limiting the possible future changes. }

\emph{A redeclaration can redefine the constraining type:}
\begin{lstlisting}[language=modelica]
model Circuit4
  extends Circuit2(
    redeclare replaceable model NonlinearResistor
                 = ThermoResistor constrainedby ThermoResistor);
end Circuit4;

model Circuit5
  extends Circuit4(
    redeclare replaceable model NonlinearResistor = Resistor); // illegal
end Circuit5;
\end{lstlisting}

{]}

The class or type of component shall be a subtype of the constraining
type. In a redeclaration of a replaceable element, the class or type of
a component must be a subtype of the constraining type. The constraining
type of a replaceable redeclaration must be a subtype of the
constraining type of the declaration it redeclares. In an element
modification of a replaceable element, the modifications are applied
both to the actual type and to the constraining type.

In an element-redeclaration of a replaceable element the modifiers of
the replaced constraining type are merged to both the new declaration
and to the new constraining type, using the normal rules where outer
modifiers override inner modifiers.

When a class is flattened as a constraining type, the flattening of its
replaceable elements will use the constraining type and not the actual
default types.

The number of dimension in the constraining type should correspond to
the number of dimensions in the type-part. Similarly the type used in a
redeclaration must have the same number of dimensions as the type of
redeclared element.

{[}\emph{Examples:}
\begin{lstlisting}[language=modelica]
replaceable T1 x[n] constrainedby T2;
replaceable type T=T1[n] constrainedby T2;
replaceable T1[n] x constrainedby T2;
\end{lstlisting}

\emph{In these examples the number of dimensions must be the same in T1
and T2, as well as in a redeclaration. Normally T1 and T2 are scalar
types, but both could also be defined as array types -- with the same
number of dimensions. Thus if T2 is a scalar type (e.g. type T2= Real)
then T1 must also be a scalar type; and if T2 is defined as vector type
  (e.g. type T2=Real[3]) then T1 must also be vector type.}]
\subsubsection{Constraining-clause annotations}\doublelabel{constraining-clause-annotations}

Description and annotations on the constraining-clause are applied to
the entire declaration, and it is an error if they also appear on the
definition. \emph{{[}The intent is that the description and/or
annotation are at the end of the declaration, but it is not
straightforward to specify this in the grammar.{]}}

{[}\emph{Examples:}
\begin{lstlisting}[language=modelica]
replaceable model Load1=Resistor constrainedby TwoPin "The Load"; //Recommended
replaceable model Load2=Resistor "The Load" constrainedby TwoPin; //Identical to Load1
replaceable model Load3=Resistor "The Load" constrainedby TwoPin "The Load"; //Error

replaceable Resistor load1 constrainedby TwoPin "The Load"; //Recommended
replaceable Resistor load2 "The Load" constrainedby TwoPin; //Identical to load1
replaceable Resistor load3 "The Load" constrainedby TwoPin "The Load!"; //Error
\end{lstlisting}

{]}

See also the examples in \autoref{annotation-choices-for-suggested-redeclarations-and-modifications}.

\subsection{Restrictions on Redeclarations}\doublelabel{restrictions-on-redeclarations}

The following additional constraints apply to redeclarations (after
prefixes are inherited, \autoref{redeclaration}):

Only classes and components declared as replaceable can be redeclared
with a new type {[}\emph{redeclaration with the same type can be used to
restrict variability and/or change array dimensions}{]}, which must have
an interface compatible with the constraining interface of the original
declaration, and to allow further redeclarations one must use
``\lstinline!redeclare replaceable!''

\begin{itemize}
\item
  an element declared as constant cannot be redeclared
\item
  an element declared as final may not be modified, and thus not
  redeclared
\item
  Modelica does not allow a protected element to be redeclared as
  public, or a public element to be redeclared as protected.
\item
  Array dimensions may be redeclared; provided the sub-typing rules in
  \autoref{interface-compatibility-or-subtyping} are satisfied. {[}\emph{This is one example of redeclare of
  non-replaceable elements.}{]}
\end{itemize}

\subsection{Annotation Choices for Suggested Redeclarations and Modifications}\doublelabel{annotation-choices-for-suggested-redeclarations-and-modifications}

A declaration can have an annotation ``\lstinline!choices!'' containing modifiers on
\lstinline!choice!, where each of them indicates a suitable redeclaration or
modifications of the element.

This is a hint for users of the model, and can also be used by the user
interface to suggest reasonable redeclaration, where the string comments
on the choice declaration can be used as textual explanations of the
choices. The annotation is not restricted to replaceable elements but
can also be applied to non-replaceable elements, enumeration types, and
simple variables. For a Boolean variable, a choices annotation may
contain the definition \lstinline!checkBox = true!, meaning to display a checkbox to
input the values \lstinline!false! or \lstinline!true! in the graphical user interface.

Choices menus of replaceable elements can be automatically constructed
showing the names of all classes that are either directly or indirectly
derived by inheritance from the constraining class of the declaration.
This can be recommended by having \lstinline!annotation choicesAllMatching = true!; and disabled by having
\lstinline!annotation choicesAllMatching = false!.
\begin{nonnormative}
The behavior when choicesAllMatching is not specified;
ideally it should present (at least) the same choices as for
\lstinline!choicesAllMatching = true;! but if it takes (too long) time to present
the list it is better to have \lstinline!choicesAllMatching = false!.
\end{nonnormative}

\begin{example}
\begin{lstlisting}[language=modelica]
replaceable model MyResistor=Resistor
  annotation(choices(
               choice(redeclare model MyResistor=lib2.Resistor(a={2}) "..."),
               choice(redeclare model MyResistor=lib2.Resistor2 "...")));

replaceable Resistor Load(R=2) constrainedby TwoPin
  annotation(choices(
               choice(redeclare lib2.Resistor Load(a={2}) "..."),
               choice(redeclare Capacitor Load(L=3) "...")));

replaceable FrictionFunction a(func=exp) constrainedby Friction
  annotation(choices(
               choice(redeclare ConstantFriction a(c=1) "..."),
               choice(redeclare TableFriction a(table="...") "..."),
               choice(redeclare FunctionFriction a(func=exp) "...")));

replaceable package Medium = Modelica.Media.Water.ConstantPropertyLiquidWater
          constrainedby Modelica.Media.Interfaces.PartialMedium
	     annotation (choicesAllMatching=true);
\end{lstlisting}

It can also be applied to nonreplaceable declarations, e.g. to
describe enumerations.
\begin{lstlisting}[language=modelica]
type KindOfController=Integer(min=1,max=3)
  annotation(choices(
              choice=1 "P",
              choice=2 "PI",
              choice=3 "PID"));

model A
  parameter KindOfController x;
end A;
A a(x=3 "PID");
\end{lstlisting}

It can also be applied to Boolean variables to define a check
box.
\begin{lstlisting}[language=modelica]
parameter Boolean useHeatPort=false annotation(choices(checkBox=true));
\end{lstlisting}

\end{example}
