\chapter{Inheritance, Modification, and Redeclaration}\label{inheritance-modification-and-redeclaration}

One of the major benefits of object-orientation is the ability to \emph{extend} the behavior and properties of an existing class.
The original class, known as the \willintroduce{base class}, is extended to create a more specialized version of that class, known as the \willintroduce{derived class}.
In this process, the data and behavior of the original class in the form of variable declarations, equations, and certain other contents are reused, or \emph{inherited}, by the derived class.
In fact, the inherited contents is copied from the superclass into the derived class, but before copying certain operations, such as type expansion, checking, and modification, are performed on the inherited contents when appropriate.
This chapter describes the inheritance concept in Modelica, together with the related concepts modification and redeclaration.

\section{Inheritance -- Extends Clause}\label{inheritance-extends-clause}

The class \lstinline!A! is called a \firstuse{base class} of \lstinline!B!, if \lstinline!B! extends \lstinline!A!.
The converse relation is then expressed as \lstinline!B! being a \firstuse{derived class} of \lstinline!A!, or as \lstinline!B! being \firstuse{derived from} \lstinline!A!.
This relation is specified by an \lstinline!extends!-clause in \lstinline!B! or in one of \lstinline!B!'s base classes.
A class inherits all elements from its base classes, and may modify all non-final elements inherited from base classes, as explained below.

The \lstinline!extends!-clause is used to specify inheritance from a base class into an (enclosing) class containing the \lstinline!extends!-clause.
It is an unnamed element of a class definition that uses a name and an optional modification to specify a base class of the class defined using the class definition.
The syntax of the \lstinline!extends!-clause is as follows:
\begin{lstlisting}[language=grammar]
extends-clause :
   extends name [ class-modification ] [annotation]
\end{lstlisting}%
\indexinline{extends}
The name of the base class is looked up in the partially flattened enclosing class (\cref{enclosing-classes}) of the \lstinline!extends!-clause.
The found base class is flattened with a new environment and the partially flattened enclosing class of the \lstinline!extends!-clause.
The new environment is the result of merging
\begin{itemize}
\item
  arguments of all enclosing class environments that match names in the flattened base class
\item
  the optional \lstinline!class-modification! of the \lstinline!extends!-clause
\end{itemize}
in that order.

\begin{example}
\begin{lstlisting}[language=modelica]
class A
  parameter Real a, b;
end A;

class B
  extends A(b = 2);
end B;

class C
  extends B(a = 1);
end C;
\end{lstlisting}
\end{example}

The elements of the flattened base class become elements of the flattened enclosing class, and are added at the place of the \lstinline!extends!-clause: specifically components and classes, the equation sections, algorithm sections, optional \lstinline!external!-clause, and the contents of the annotation at the end of the class, but excluding \lstinline!import!-clauses.

\begin{nonnormative}
From the example above we get the following flattened class:
\begin{lstlisting}[language=modelica]
class Cinstance
  parameter Real a = 1;
  parameter Real b = 2;
end Cinstance;
\end{lstlisting}

The ordering of the merging rules ensures that, given classes \lstinline!A! and \lstinline!B! defined above,
\begin{lstlisting}[language=modelica]
class C2
  B bcomp(b = 3);
end C2;
\end{lstlisting}
yields an instance with \lstinline!bcomp.b = 3!, which overrides \lstinline!b = 2!.
\end{nonnormative}

The declaration elements of the flattened base class shall either:
\begin{itemize}
\item
  Not already exist in the partially flattened enclosing class
  (i.e., have different names).
\item
  The new element is a long form of redeclare or uses the \lstinline!class extends A! syntax, see \cref{redeclaration}.
\item
  Be exactly identical to any element of the flattened enclosing class
  with the same name and the same level of protection (public or
  protected) and same contents. In this case, the first element in order
  (can be either inherited or local) is kept. It is recommended to give
  a warning for this case; unless it can be guaranteed that the
  identical contents will behave in the same way.
\end{itemize}

Otherwise the model is incorrect.

\begin{nonnormative}
Clarifiying order:
\begin{lstlisting}[language=modelica]
function A
  input Real a;
  input Real b;
end A;

function B
  extends A;
  input Real a;
end B;
// The inputs of B are {a, b} in that order; the "input Real a;" is ignored.
\end{lstlisting}
\end{nonnormative}

Equations of the flattened base class that are syntactically equivalent
to equations in the flattened enclosing class are discarded. This
feature is deprecated, and it is recommended to give a warning when
discarding them and for the future give a warning about all forms of
equivalent equations due to inheritance.

\begin{nonnormative}
Equations that are mathematically equivalent but not syntactically equivalent are not discarded, hence yield an overdetermined system of equations.
\end{nonnormative}

\subsection{Multiple Inheritance}\label{multiple-inheritance}

Multiple inheritance is possible since multiple \lstinline!extends!-clauses can be present in a class.

\begin{nonnormative}
As stated in \cref{the-inherited-contents-of-the-element}, it is illegal for an \lstinline!extends!-clause to influence the lookup of the class name of any \lstinline!extends!-clause in the same class definition.
\end{nonnormative}

\subsection{Inheritance of Protected and Public Elements}\label{inheritance-of-protected-and-public-elements}

If an \lstinline!extends!-clause is used under the \lstinline!protected! heading, all elements of the base class become protected elements of the current class.
If an \lstinline!extends!-clause is a public element, all elements of the base class are inherited with their own protection.
The eventual headings \lstinline!protected! and \lstinline!public! from the base class do not affect the consequent elements of the current class (i.e., headings \lstinline!protected! and \lstinline!public! are not inherited).

\subsection{Restrictions on the Kind of Base Class}\label{restrictions-on-the-kind-of-base-class}

Since specialized classes of different kinds have different properties, see \cref{specialized-classes}, only specialized classes that are \emph{in some sense compatible} to each other can be derived from each other via inheritance.
The following table shows which kind of specialized class can be used in an \lstinline!extends!-clause of another kind of specialized class (the grey cells mark the few exceptional cases, where a specialized class can be derived from a specialized class of another kind):
% The PDF contains an excessive amount of vertical space here, but it seems like a bad idea to try to make it go away
% by adding LaTeX spacing commands that will cause problems later when things move around.
\begin{center}
% LaTeXML does not handle resizebox, so don't use it for HTML.
\ifpdf\resizebox{\textwidth}{!}{\else\fi%
\begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
                      & \multicolumn{12}{c|}{\tablehead{Base Class}}                                                                                                                                                                                                                                                                                                                          \\
    \hline
     \tablehead{Derived} & \multirow{2}{*}{\lstinline!package!} & \multirow{2}{*}{\lstinline!operator!} & \multirow{2}{*}{\lstinline!function!}                  & \lstinline!operator!             & \multirow{2}{*}{\lstinline!type!}    & \multirow{2}{*}{\lstinline!record!}  & \lstinline!operator!                 & \lstinline!expandable!               & \multirow{2}{*}{\lstinline!connector!} & \multirow{2}{*}{\lstinline!block!}   & \multirow{2}{*}{\lstinline!model!} & \multirow{2}{*}{\lstinline!class!}                     \\
     \tablehead{Class}   &                          &                           &                                            & \lstinline!function!             &                          &                          & \lstinline!record!                   & \lstinline!connector!                &                            &                          &                        &                                            \\
    \hline
    \hline
    \lstinline!package!           & yes                      &                           &                                            &                      &                          &                          &                          &                          &                            &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    \lstinline!operator!          &                          & yes                       &                                            &                      &                          &                          &                          &                          &                            &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    \lstinline!function!          &                          &                           & yes                                        &                      &                          &                          &                          &                          &                            &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    \lstinline!operator!          &                          &                           & \cellcolor{lightgray}                      & \multirow{2}{*}{yes} &                          &                          &                          &                          &                            &                          &                        & \cellcolor{lightgray}                      \\
    \lstinline!function!          &                          &                           & \multirow{-2}{*}{\cellcolor{lightgray}yes} &                      &                          &                          &                          &                          &                            &                          &                        & \multirow{-2}{*}{\cellcolor{lightgray}yes}  \\
    \hline
    \lstinline!type!              &                          &                           &                                            &                      & yes                      &                          &                          &                          &                            &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    \lstinline!record!            &                          &                           &                                            &                      &                          & yes                      &                          &                          &                            &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    \lstinline!operator!          &                          &                           &                                            &                      &                          &                          & \multirow{2}{*}{yes}     &                          &                            &                          &                        & \cellcolor{lightgray}                      \\
    \lstinline!record!            &                          &                           &                                            &                      &                          &                          &                          &                          &                            &                          &                        & \multirow{-2}{*}{\cellcolor{lightgray}yes} \\
    \hline
    \lstinline!expandable!        &                          &                           &                                            &                      &                          &                          &                          & \multirow{2}{*}{yes}     &                            &                          &                        & \cellcolor{lightgray}                      \\
    \lstinline!connector!         &                          &                           &                                            &                      &                          &                          &                          &                          &                            &                          &                        & \multirow{-2}{*}{\cellcolor{lightgray}yes} \\
    \hline
    \lstinline!connector!         &                          &                           &                                            &                      & \cellcolor{lightgray}yes & \cellcolor{lightgray}yes & \cellcolor{lightgray}yes &                          & yes                        &                          &                        & \cellcolor{lightgray}yes                   \\
    \hline
    \lstinline!block!             &                          &                           &                                            &                      &                          & \cellcolor{lightgray}yes &                          &                          &                            & yes                      &                        & \cellcolor{lightgray}yes                   \\
    \hline
    \lstinline!model!             &                          &                           &                                            &                      &                          & \cellcolor{lightgray}yes &                          &                          &                            & \cellcolor{lightgray}yes & yes                    & \cellcolor{lightgray}yes                   \\
    \hline
    \lstinline!class!             &                          &                           &                                            &                      &                          &                          &                          &                          &                            &                          &                        & yes                                        \\
    \hline
\end{tabular}
% Close resizebox.
\ifpdf}\else\fi%
\end{center}

If a derived class is inherited from another type of specialized class,
then the result is a specialized class of the derived class type.

\begin{nonnormative}
For example, if a \lstinline!block! inherits from a \lstinline!record!, then the result is a \lstinline!block!.
\end{nonnormative}

All specialized classes can be derived from \lstinline!class!\indexinline{class}, provided that the resulting class fulfills the restriction of the specialized class.
A \lstinline!class! may only contain class definitions, annotations, and \lstinline!extends!-clauses (having any other contents is deprecated).

\begin{nonnormative}
It is recommended to use the most specific specialized class.
\end{nonnormative}

The specialized classes \lstinline!package!, \lstinline!operator!, \lstinline!function!,
\lstinline!type,! \lstinline!record!,
\lstinline!operator record!, and \lstinline!expandable connector! can only be derived from their
own kind and from \lstinline!class!.

\begin{nonnormative}
E.g.\ a package can only be base class for packages.
All other kinds of classes can use the \lstinline!import!-clause to use the contents of a package.
\end{nonnormative}

\begin{example}
\begin{lstlisting}[language=modelica]
record RecordA
  $\ldots$
end RecordA;

package PackageA
  $\ldots$
end PackageA;

package PackageB
  extends PackageA; // fine
end PackageB;

model ModelA
  extends RecordA; // fine
end ModelA;

model ModelB
  extends PackageA; // error, inheritance not allowed
end ModelB;
\end{lstlisting}
\end{example}

\subsection{Require Transitively Non-Replaceable}\label{restrictions-on-base-classes-and-constraining-types-to-be-transitively-non-replaceable}\label{require-transitively-non-replaceable}

The class name used after \lstinline!extends! for base classes and for constraining classes must use a class reference considered transitively non-replaceable, see definition in \cref{transitively-non-replaceable}.
For a replaceable component declaration without \lstinline[language=grammar]!constraining-clause! the class must use a class reference considered transitively non-replaceable.

\begin{nonnormative}
The requirement to use a transitively non-replaceable name excludes the long form of redeclare, i.e.\ \lstinline!redeclare model extends M $\ldots$! where \lstinline!M! must be an inherited replaceable class.
\end{nonnormative}

\begin{nonnormative}
The rule for a replaceable component declaration without \lstinline[language=grammar]!constraining-clause! implies that constraining classes are always transitively non-replaceable -- both
if explicitly given or implicitly by the declaration.
\end{nonnormative}

\section{Modifications}\label{modifications}

A \firstuse{modification} is part of an element.
It modifies the instance generated by that element.
A modification contains \willintroduce{element modifications} (e.g., \lstinline!vcc(unit = "V") = 1000!) and \willintroduce{element-redeclarations} (e.g., \lstinline!redeclare type Voltage = Real(unit="V")!).

There are three kinds of constructs in the Modelica language in which modifications can occur:
\begin{itemize}
\item
  variable declarations
\item
  short class declarations
\item
  \lstinline!extends!-clauses
\end{itemize}

A modifier modifies one or more declarations from a class by changing some aspect(s) of the declarations.
The most common kind of modifier just changes the \emph{default value} or the \lstinline!start!-attribute in a binding equation; the value and/or \lstinline!start!-attribute should be compatible with the variable according to \cref{type-compatible-expressions}.

An \firstuse{element modification} overrides the declaration equation in the class used by the instance generated by the modified element.

\begin{example}
Modifying the default \lstinline!start! value of the \lstinline!altitude! variable:
\begin{lstlisting}[language=modelica]
Real altitude(start = 59404);
\end{lstlisting}
\end{example}

A modification (e.g., \lstinline!C1 c1(x = 5)!) is called a \firstuse{modification equation}, if the modified variable (here: \lstinline!c1.x!) is a non-parameter variable.

\begin{nonnormative}
The modification equation is created, if the modified component (here: \lstinline!c1!) is also created (see \cref{class-declarations}). In most cases
a modification equation for a non-parameter variable requires that the variable was declared with a declaration equation, see \cref{balanced-models};
in those cases the declaration equation is replaced by the modification equation.
\end{nonnormative}

A more dramatic change is to modify the \emph{type} and/or the \emph{prefixes} and possibly the \emph{dimension sizes} of a declared element.
This kind of modification is called an \firstuse{element-redeclaration}\index{redeclaration!element} (\cref{redeclaration}) and requires the special keyword \lstinline!redeclare! to be used in the modifier in order to reduce the risk for accidental modeling errors.
In most cases a declaration that can be redeclared must include the prefix \lstinline!replaceable!\indexinline{replaceable} (\cref{redeclaration}).
The modifier value (and class for redeclarations) is found in the context in which the modifier occurs, see also \cref{simple-name-lookup}.

\begin{example}
Scope for modifiers:
\begin{lstlisting}[language=modelica]
model B
  parameter Real x;
  package Medium = Modelica.Media.PartialMedium;
end B;

model C
  parameter Real x = 2;
  package Medium = Modelica.Media.PartialMedium;
  B b(x = x, redeclare package Medium = Medium);
  // The 'x' and 'Medium' being modified are declared in the model B.
  // The modifiers '= x' and '= Medium' are found in the model C.
end C;

model D
  parameter Real x = 3;
  package Medium = Modelica.Media.PartialMedium;
  C c(b(x = x, redeclare package Medium = Medium));
  // The 'x' and 'Medium' being modified are declared in the model B.
  // The modifiers '= x' and '= Medium' are found in the model D.
end D;
\end{lstlisting}
\end{example}

When present, the description-string of a modifier overrides the existing description.

\subsection{Syntax of Modifications and Redeclarations}\label{syntax-of-modifications-and-redeclarations}

The syntax is defined in the grammar, \cref{modification}.

\subsection{Modification Environment}\label{modification-environment}

The \firstuse{modification environment} of a class contains arguments which modify elements of the class (e.g., parameter changes) when the class is flattened.
The modification environment is built by merging class modifications, where outer modifications override inner modifications.

\begin{nonnormative}
This should not be confused with \lstinline!inner outer! prefixes described in \cref{instance-hierarchy-name-lookup-of-inner-declarations}.
\end{nonnormative}

\subsection{Merging of Modifications}\label{merging-of-modifications}

Merging of modifiers means that outer modifiers override inner modifiers.  The merging is hierarchical, and a value for an entire non-simple component overrides value modifiers for all components, and it is an error if this overrides a \lstinline!final! prefix for a component, or if value for a simple component would override part of the value of a non-simple component. When merging modifiers each modification keeps its own \lstinline!each! prefix.

\begin{example}
The following larger example demonstrates several aspects:
\begin{lstlisting}[language=modelica]
class C1
  class C11
    parameter Real x;
  end C11;
end C1;

class C2
  class C21
    $\ldots$
  end C21;
end C2;

class C3
  extends C1;
  C11 t(x = 3); // ok, C11 has been inherited from C1
  C21 u; // ok, even though C21 is inherited below
  extends C2;
end C3;
\end{lstlisting}
The following example demonstrates overriding part of non-simple component:
\begin{lstlisting}[language=modelica]
record A
  parameter Real x;
  parameter Real y;
end A;

model B
  parameter A a = A(2, 3);
end B;

model C
  B b1(a(x = 4)); // Error since attempting to override value for a.x when a has a value.
end C;
\end{lstlisting}

The modification environment of the declaration of \lstinline!t! is
(\lstinline!x = 3!). The modification environment is built by merging class modifications, as shown by:
\begin{lstlisting}[language=modelica]
class C1
  parameter Real a;
end C1;

class C2
  parameter Real b;
  parameter Real c;
end C2;

class C3
  parameter Real x1; // No default value
  parameter Real x2 = 2; // Default value 2
  parameter C1 x3; // No default value for x3.a
  parameter C2 x4(b = 4); // x4.b has default value 4
  parameter C1 x5(a = 5); // x5.a has default value 5
  extends C1; // No default value for inherited element a
  extends C2(b = 6, c = 77); // Inherited b has default value 6
end C3;

class C4
  extends C3(x2 = 22, x3(a = 33), x4(c = 44), x5 = x3, a = 55, b = 66);
end C4;
\end{lstlisting}

Outer modifications override inner modifications, e.g., \lstinline!b = 66!
overrides the nested class modification of extends \lstinline!C2(b = 6)!.
This is known as merging of modifications: merge\lstinline!((b = 66), (b = 6))!
becomes \lstinline!(b = 66)!.

A flattening of class \lstinline!C4! will give an object with the following variables:
\begin{center}
\begin{tabular}{l|l}
\hline
\tablehead{Variable} & \tablehead{Default value}\\
\hline
\hline
\lstinline!x1! & \textit{none}\\ % Look of \emph won't be as expected inside example.
\lstinline!x2! & 22\\
\lstinline!x3.a! & 33\\
\lstinline!x4.b! & 4\\
\lstinline!x4.c! & 44\\
\lstinline!x5.a! & \lstinline!x3.a!\\
\lstinline!a! & 55\\
\lstinline!b! & 66\\
\lstinline!c! & 77\\
\hline
\end{tabular}
\end{center}
\end{example}

\subsection{Single Modification}\label{single-modification}

Two arguments of a modification shall not modify the same element, attribute, or description-string.  When using qualified names the different qualified names starting with the same identifier are merged into one modifier.  If a modifier with a qualified name has the \lstinline!each! or \lstinline!final! prefix, that prefix is only seen as applied to the final part of the name.

\begin{example}
\begin{lstlisting}[language=modelica]
class C1
  Real x[3];
end C1;
class C2 = C1(x = ones(3), x = ones(3)); // Error: x designated twice
class C3
  class C4
    Real x;
  end C4;
  C4 a(final x.unit = "V", x.displayUnit = "mV", x = 5.0);
  // Ok, different attributes designated (unit, displayUnit and value)
  // identical to:
  C4 b(x(final unit = "V", displayUnit = "mV") = 5.0));
end C3;
\end{lstlisting}

The following examples are incorrect:
\begin{lstlisting}[language=modelica]
m1(r = 1.5, r = 1.6) // Multiple modifier for r (its value)
m1(r = 1.5, r = 1.5) // Multiple modifier for r (its value) - even if identical
m1(r.start = 2, r(start = 3)) // Multiple modifier for r.start
m1(x.r = 1.5 "x", x.r(start = 2.0) "y")) // Multiple description-string for x.r
m1(r = R(), r(y = 2)) // Multiple modifier for r.y - both direct value and
                      // part of record
\end{lstlisting}
The following examples are correct:
\begin{lstlisting}[language=modelica]
m1(r = 1.5, r(start = 2.0))
m1(r = 1.6, r "x")
m1(r = R(), r(y(min = 2)))
\end{lstlisting}
\end{example}

\subsection{Modifiers for Array Elements}\label{modifiers-for-array-elements}

The following rules apply to modifiers:
\begin{itemize}
\item
  The \lstinline!each!\indexinline{each} keyword on a modifier requires that it is applied in an array declaration/modification, and the modifier is applied individually to each element of the enclosing array (with regard to the position of \lstinline!each!).
  In case of nested modifiers this implies it is applied individually to each element of each element of the enclosing array; see example.
  If the modified element is a vector and the modifier does not contain the \lstinline!each! prefix, the modification is split such that the first element in the vector is applied to the first element of the vector of elements, the second to the second element, until the last element of the vector is applied to the last element of the array; it is an error if these sizes do not match.
  Matrices and general arrays of elements are treated by viewing those as vectors of vectors etc.
\item
  If a nested modifier is split, the split is propagated to all elements of the nested modifier, and if they are modified by the \lstinline!each! keyword the split is inhibited for those elements.
  If the nested modifier that is split in this way contains re-declarations that are split, it is illegal.
\end{itemize}

\begin{example}
\begin{lstlisting}[language=modelica]
model C
  parameter Real a[3];
  parameter Real d;
end C;

model B
  C c[5](each a = {1, 2, 3}, d = {1, 2, 3, 4, 5});
  parameter Real b = 0;
end B;
\end{lstlisting}
This implies \lstinline!c[i].a[j] = j! and \lstinline!c[i].d = i!.

\begin{lstlisting}[language=modelica]
model D
  B b(each c.a = {3, 4, 5}, c.d = {2, 3, 4, 5, 6});
  // Equivalent to:
  B b2(c(each a = {3, 4, 5}, d = {2, 3, 4, 5, 6}));
end D;
\end{lstlisting}
This implies \lstinline!b.c[i].a[j] = 2+j! and \lstinline!b.c[i].d = 1+i!.
\begin{lstlisting}[language=modelica]
model E
  B b[2](each c(each a = {1, 2, 3}, d = {1, 2, 3, 4, 5}), p = {1, 2});
  // Without the first each one would have to use:
  B b2[2](c(each a = {1, 2, 3}, d = fill({1, 2, 3, 4, 5}, 2)), p = {1, 2});
end E;
\end{lstlisting}
This implies \lstinline!b[k].c[i].a[j] = j!, \lstinline!b[k].c[i].d = i!, and \lstinline!b[k].p = k!.  For \lstinline!c.a! the additional (outer) \lstinline!each! has no effect, but it is necessary for \lstinline!c.d!.

Specifying array dimensions after the type works the same as specifying them after the variable name.
\begin{lstlisting}[language=modelica]
model F
  Real fail1[2](each start = {1, 2}); // Illegal
  Real work1[2](each start = 1);      // Legal
  Real[2] fail2(each start = {1, 2}); // Illegal
  Real[2] work2(each start = 2);      // Legal
end F;
\end{lstlisting}
\end{example}

\subsection{Final Element Modification Prevention}\label{final-element-modification-prevention}

An element defined as final by the \lstinline!final!\indexinline{final} prefix in an element modification or declaration cannot be modified by a modification or by a redeclaration.  All elements of a final element are also final.

\begin{nonnormative}
Setting the value of a parameter in an experiment environment is conceptually treated as a modification.  This implies that a final modification equation
of a parameter cannot be changed in a simulation environment.
\end{nonnormative}

\begin{example}
Final component modification.
\begin{lstlisting}[language=modelica]
type Angle =
  Real(final quantity = "Angle", final unit = "rad", displayUnit = "deg");

model TransferFunction
  parameter Real b[:] = {1} "numerator coefficient vector";
  parameter Real a[:] = {1, 1} "denominator coefficient vector";
  $\ldots$
end TransferFunction;

model PI "PI controller"
  parameter Real k = 1 "gain";
  parameter Real T = 1 "time constant";
  TransferFunction tf(final b = k * {T, 1}, final a = {T, 0});
end PI;

model Test
  PI c1(k = 2, T = 3); // fine, will indirectly change tf.b to 2 * {3, 1}
  PI c2(tf(b = {1}));  // error, b is declared as final
end Test;
\end{lstlisting}
\end{example}

\begin{example}
Final class declaration.
\begin{lstlisting}[language=modelica]
model Test2
  final model MyTF = TransferFunction(b = {1, 2});
  /* Equivalently:
  final model MyTF = TransferFunction(final a, final b = {1, 2});
  */
  MyTF tf1;                        // fine
  MyTF tf2(a = {1, 2});            // error, all elements in MyTF are final
  model M = MyTF(a = {4});         // error, all elements in MyTF are final
  model TFX
    extends MyTF;                  // fine
    Real foo = 1.0;
  end TFX;
  TFX tfx(foo = 2.0);              // fine, foo is not from MyRF
  TFX tfx2(a = {1, 3});            // error, all elements from MyTF are final
  model TFX3 = TFX(a = {1, 4});    // error, all elements from MyTF are final
end Test2;
\end{lstlisting}
\end{example}

\section{Redeclaration}\label{redeclaration}

A \lstinline!redeclare!\indexinline{redeclare} construct in a modifier replaces the declaration of a local class or component with another declaration.
A \lstinline!redeclare! construct as an element replaces the declaration of a local class or component with another declaration.
Both \lstinline!redeclare! constructs work in the same way.
The \lstinline!redeclare! construct as an element requires that the element is inherited, and cannot be combined with a modifier of the same element in the \lstinline!extends!-clause.
For modifiers, the redeclare of classes uses the \lstinline[language=grammar]!short-class-definition! construct, which is a special case of normal class definitions and semantically behaves as the corresponding \lstinline[language=grammar]!class-definition!.

A modifier with the keyword \lstinline!replaceable!\indexinline{replaceable} is automatically seen as being a \lstinline!redeclare!.

In redeclarations some parts of the original declaration is
automatically inherited by the new declaration. This is intended to make
it easier to write declarations by not having to repeat common parts of
the declarations, and does in particular apply to prefixes that must be
identical. The inheritance only applies to the declaration itself and
not to elements of the declaration.

The general rule is that if no prefix within one of the following groups
is present in the new declaration the old prefixes of that kind are
preserved.

The groups that are valid for both classes and components:
\begin{itemize}
\item
  \lstinline!public!, \lstinline!protected!
\item
  \lstinline!inner!, \lstinline!outer!
\item
  constraining type according to rules in \cref{constraining-type}.
\end{itemize}

The groups that are only valid for components:
\begin{itemize}
\item
  \lstinline!flow!, \lstinline!stream!
\item
  \lstinline!discrete!, \lstinline!parameter!, \lstinline!constant!
\item
  \lstinline!input!, \lstinline!output!
\item
  array dimensions
\end{itemize}

Note that if the old declaration was a short class definition with array
dimensions the array dimensions are not automatically preserved, and
thus have to be repeated in the few cases they are used.

Replaceable component array declarations with array sizes on the left of
the component are seen as syntactic sugar for having all arrays sizes on
the right of the component; and thus can be redeclared in a consistent
way.

\begin{nonnormative}
Note: The inheritance is from the original declaration. In most
cases replaced or original does not matter. It does matter if a user
redeclares a variable to be a parameter and then redeclares it without
parameter.
\end{nonnormative}

\begin{nonnormative}
\begin{lstlisting}[language=modelica]
model HeatExchanger
  replaceable parameter GeometryRecord geometry;
  replaceable input Real u[2];
end HeatExchanger;

  HeatExchanger(
    /*redeclare*/ replaceable /*parameter*/ GeoHorizontal geometry,
    redeclare /*input*/ Modelica.Units.SI.Angle u /*[2]*/);
   // The semantics ensure that parts in /*.*/ are automatically added
   // from the declarations in HeatExchanger.
\end{lstlisting}

Example of arrays on the left of the component name:
\begin{lstlisting}[language=modelica]
model M
  replaceable Real [4] x[2];
  // Seen as syntactic sugar for "replaceable Real x[2, 4];"
  // Note the order.
end M;
M m(redeclare Modelica.Units.SI.Length x[2, 4]); // Valid redeclare of the type
\end{lstlisting}
\end{nonnormative}

\subsection{The ``class extends'' Redeclaration Mechanism}\label{the-class-extends-redeclaration-mechanism}

A class declaration of the type \lstinline!redeclare class extends B($\ldots$)!, where \lstinline!class! as usual can be replaced by any other specialized class, replaces the inherited class \lstinline!B! with another declaration that extends the inherited class where the optional class-modification is applied to the inherited class.
Inherited \lstinline!B! here means that the class containing \lstinline!redeclare class extends B($\ldots$)! should also inherit another declaration of \lstinline!B! from one of its \lstinline!extends!-clauses.
The new declaration should explicitly include \lstinline!redeclare!.

\begin{nonnormative}
Since the rule about applying the optional class-modification implies that all declarations are inherited with modifications applied, there is no need
to apply modifiers to the new declaration.
\end{nonnormative}

% henrikt-ma: Adding index entry for 'replaceable' here, since I can't find a place where the term is really explained in terms of using the corresponding keyword.
For \lstinline!redeclare class extends B($\ldots$)! the inherited class is subject to the same restrictions as a redeclare of the inherited element, and the original class \lstinline!B! should be \firstuse{replaceable}, and the new element is only replaceable if the new definition is replaceable.
In contrast to normal extends it is not subject to the restriction that \lstinline!B! should be transitively non-replaceable (since \lstinline!B! should be replaceable).

The syntax rule for \lstinline!class extends! construct is in the definition of the
\lstinline!class-specifier! nonterminal (see also class declarations in \cref{class-declarations}):
\begin{lstlisting}[language=grammar]
class-definition :
   [ encapsulated ] class-prefixes
   class-specifier

class-specifier : long-class-specifier | $\ldots$

long-class-specifier : $\ldots$
    | extends IDENT [ class-modification ] description-string
      composition end IDENT
\end{lstlisting}
The nonterminal \lstinline!class-definition! is referenced in several places in the
grammar, including the following case which is used in some examples
below, including \lstinline!package extends! and \lstinline!model extends!:
\begin{lstlisting}[language=grammar]
element :
   import-clause |
   extends-clause |
   [ redeclare ]
   [ final ]
   [ inner ] [ outer ]
   ( ( class-definition | component-clause) |
      replaceable ( class-definition | component-clause)
        [constraining-clause comment])
\end{lstlisting}

\begin{nonnormative}
Example to extend from existing packages:
\begin{lstlisting}[language=modelica]
package PowerTrain // library from someone else
  replaceable package GearBoxes
    $\ldots$
  end GearBoxes;
end PowerTrain;

package MyPowerTrain
  extends PowerTrain; // use all classes from PowerTrain
  redeclare package extends GearBoxes // add classes to sublibrary
    $\ldots$
  end GearBoxes;
end MyPowerTrain;
\end{lstlisting}

Example for an advanced type of package structuring with constraining types:
\begin{lstlisting}[language=modelica]
partial package PartialMedium "Generic medium interface"
  constant Integer nX "number of substances";
  replaceable partial model BaseProperties
    Real X[nX];
    $\ldots$
  end BaseProperties;

  replaceable partial function dynamicViscosity
    input Real p;
    output Real eta;
    $\ldots$
  end dynamicViscosity;
end PartialMedium;

package MoistAir "Special type of medium"
  extends PartialMedium(nX=2);

  redeclare model extends BaseProperties(T(stateSelect = StateSelect.prefer))
    // replaces BaseProperties by a new implementation and
    // extends from Baseproperties with modification
    // note, nX = 2 (!)
  equation
    X = {0, 1};
    $\ldots$
  end BaseProperties;

  redeclare function extends dynamicViscosity
    // replaces dynamicViscosity by a new implementation and
    // extends from dynamicViscosity
  algorithm
    eta := 2 * p;
  end dynamicViscosity;
end MoistAir;
\end{lstlisting}

Note, since \lstinline!MostAir! extends from \lstinline!PartialMedium!,
constant \lstinline!nX! = 2 in package \lstinline!MoistAir! and the model
\lstinline!BaseProperties! and the function \lstinline!dynamicViscosity! is present
in \lstinline!MoistAir!. By the following definitions, the available
\lstinline!BaseProperties! model is replaced by another implementation which
extends from the \lstinline!BaseProperties! model that has been temporarily
constructed during the extends of package \lstinline!MoistAir! from
\lstinline!PartialMedium!. The redeclared \lstinline!BaseProperties! model
references constant \lstinline!nX! which is 2, since by construction the
redeclared \lstinline!BaseProperties! model is in a package with \lstinline!nX! = 2.

This definition is compact but is difficult to understand. At a
first glance an alternative exists that is more straightforward and
easier to understand:
\begin{lstlisting}[language=modelica]
package MoistAir2 "Alternative definition that does not work"
  extends PartialMedium(nX=2,
    redeclare model BaseProperties = MoistAir_BaseProperties,
    redeclare function dynamicViscosity = MoistAir_dynamicViscosity);

  model MoistAir_BaseProperties
    // wrong model since nX has no value
    extends PartialMedium.BaseProperties;
  equation
    X = {1, 0};
  end MoistAir_BaseProperties;

  function MoistAir_dynamicViscosity
    extends PartialMedium.dynamicViscosity;
  algorithm
    eta := p;
  end MoistAir_dynamicViscosity;
end MoistAir2;
\end{lstlisting}

Here, the usual approach is used to extend (here from \lstinline!PartialMedium!) and in the modifier perform all redeclarations.
In order to perform these redeclarations, corresponding implementations of all elements of \lstinline!PartialMedium! have to be given under a different name, such as \lstinline!MoistAir2.MoistAir_BaseProperties!, since the name \lstinline!BaseProperties! already exists due to \lstinline!extends PartialMedium!.
Then it is possible in the modifier to redeclare \lstinline!PartialMedium.BaseProperties! to \lstinline!MoistAir2.MoistAir_BaseProperties!.
Besides the drawback that the namespace is polluted by elements that have different names but the same implementation (e.g.\ \lstinline!MoistAir2.BaseProperties! is identical to \lstinline!MoistAir2.MoistAir_BaseProperties!) the whole construction does not work if arrays are present that depend on constants in \lstinline!PartialMedium!, such as \lstinline!X[nX]!:
The problem is that \lstinline!MoistAir_BaseProperties! extends from \lstinline!PartialMedium.BaseProperties! where the constant \lstinline!nX! does not yet have a value.
This means that the dimension of array \lstinline!X! is undefined and model \lstinline!MoistAir_BaseProperties! is wrong.
With this construction, all constant definitions have to be repeated whenever these constants shall be used, especially in \lstinline!MoistAir_BaseProperties! and \lstinline!MoistAir_dynamicViscosity!.
For larger models this is not practical and therefore the only practically useful definition is the complicated construction in the previous example with \lstinline!redeclare model extends BaseProperties!.

To detect this issue the rule on lookup of composite names (\cref{composite-name-lookup}) ensures that \lstinline!PartialMedium.dynamicViscosity! is incorrect in a simulation model.
\end{nonnormative}

\subsection{Constraining Type}\label{constraining-type}

In a replaceable declaration the optional \lstinline[language=grammar]!constraining-clause! defines a constraining type.
Any modifications following the constraining type name are applied both for the purpose of defining the actual constraining type and they are automatically applied in the declaration and in any subsequent redeclaration.
The precedence order is that declaration modifiers override constraining type modifiers.

If the \lstinline[language=grammar]!constraining-clause! is not present in the original declaration (i.e., the non-redeclared declaration):
\begin{itemize}
\item
  The type of the declaration is also used as a constraining type.
\item
  The modifiers for subsequent redeclarations and constraining type are the modifiers on the component or \lstinline[language=grammar]!short-class-definition! if that is used in the original declaration, otherwise empty.
\end{itemize}

The syntax of a \lstinline[language=grammar]!constraining-clause!\indexinline{constrainedby} is as follows:
\begin{lstlisting}[language=grammar]
constraining-clause :
   constrainedby name [ class-modification ]
\end{lstlisting}

\begin{example}
Merging of modifiers:
\begin{lstlisting}[language=modelica]
class A
  parameter Real x;
end A;

class B
  parameter Real x = 3.14, y; // B is a subtype of A
end B;

class C
  replaceable A a(x = 1);
end C;

class D
  extends C(redeclare B a(y = 2));
end D;
\end{lstlisting}
which is equivalent to defining \lstinline!D! as
\begin{lstlisting}[language=modelica]
class D
  B a(x = 1, y = 2);
end D;
\end{lstlisting}

A modification of the constraining type is automatically applied
in subsequent redeclarations:
\begin{lstlisting}[language=modelica]
model ElectricalSource
  replaceable SineSource source constrainedby MO(final n=5);
  $\ldots$
end ElectricalSource;

model TrapezoidalSource
  extends ElectricalSource(
  redeclare Trapezoidal source); // source.n=5
end TrapezoidalSource;
\end{lstlisting}

A modification of the base type without a constraining type is
automatically applied in subsequent redeclarations:
\begin{lstlisting}[language=modelica]
model Circuit
  replaceable model NonlinearResistor = Resistor(R=100);
  $\ldots$
end Circuit;

model Circuit2
  extends Circuit(
    redeclare replaceable model NonlinearResistor
                           = ThermoResistor(T0 = 300));
      // As a result of the modification on the base type,
      // the default value of R is 100
end Circuit2;

model Circuit3
  extends Circuit2(
   redeclare replaceable model NonlinearResistor
                           = Resistor(R = 200));
  // The T0 modification is not applied because it did not
  // appear in the original declaration
end Circuit3;
\end{lstlisting}

\lstinline!Circuit2! is intended to illustrate that a user can still select
any resistor model (including the original one, as is done in \lstinline!Circuit3!),
since the constraining type is kept from the original declaration if not
specified in the redeclare. Thus it is easy to select an advanced
resistor model, without limiting the possible future changes.

A redeclaration can redefine the constraining type:
\begin{lstlisting}[language=modelica]
model Circuit4
  extends Circuit2(
    redeclare replaceable model NonlinearResistor
                 = ThermoResistor constrainedby ThermoResistor);
end Circuit4;

model Circuit5
  extends Circuit4(
    redeclare replaceable model NonlinearResistor = Resistor); // illegal
end Circuit5;
\end{lstlisting}
\end{example}

The class or type of component shall be a subtype of the constraining
type. In a redeclaration of a replaceable element, the class or type of
a component must be a subtype of the constraining type. The constraining
type of a replaceable redeclaration must be a subtype of the
constraining type of the declaration it redeclares. In an element
modification of a replaceable element, the modifications are applied
both to the actual type and to the constraining type.

In an element-redeclaration of a replaceable element the modifiers of
the replaced constraining type are merged to both the new declaration
and to the new constraining type, using the normal rules where outer
modifiers override inner modifiers.

When a class is flattened as a constraining type, the flattening of its
replaceable elements will use the constraining type and not the actual
default types.

The number of dimension in the constraining type should correspond to
the number of dimensions in the type-part. Similarly the type used in a
redeclaration must have the same number of dimensions as the type of
redeclared element.

\begin{example}
\begin{lstlisting}[language=modelica]
replaceable T1 x[n] constrainedby T2;
replaceable type T=T1[n] constrainedby T2;
replaceable T1[n] x constrainedby T2;
\end{lstlisting}
In these examples the number of dimensions must be the same in \lstinline!T1! and \lstinline!T2!, as well as in a redeclaration.  Normally \lstinline!T1! and \lstinline!T2! are scalar types, but both
could also be defined as array types (with the same number of dimensions).  Thus if \lstinline!T2! is a scalar type (e.g.\ \lstinline!type T2 = Real!) then \lstinline!T1! must also be a scalar type,
and if \lstinline!T2! is defined as vector type (e.g.\ \lstinline!type T2 = Real[3]!) then \lstinline!T1! must also be vector type.
\end{example}

\subsubsection{Constraining-Clause Annotations}\label{constraining-clause-annotations}

Description and annotations on the \lstinline[language=grammar]!constraining-clause! are applied to the entire declaration, and it is an error if they also appear on the definition.

\begin{nonnormative}
The intent is that the description and/or annotation are at the end of the declaration, but it is not straightforward to specify this in the grammar.
\end{nonnormative}

\begin{example}
\begin{lstlisting}[language=modelica]
replaceable model Load1 =
  Resistor constrainedby TwoPin "The Load"; // Recommended
replaceable model Load2 =
  Resistor "The Load" constrainedby TwoPin; // Identical to Load1
replaceable model Load3 =
  Resistor "The Load" constrainedby TwoPin "The Load"; // Error

replaceable Resistor load1
  constrainedby TwoPin "The Load"; // Recommended
replaceable Resistor load2
  "The Load" constrainedby TwoPin; // Identical to load1
replaceable Resistor load3
  "The Load" constrainedby TwoPin "The Load!"; // Error
\end{lstlisting}
\end{example}

See also the examples in \cref{annotation-choices-for-suggested-redeclarations-and-modifications}.

\subsection{Restrictions on Redeclarations}\label{restrictions-on-redeclarations}

The following additional constraints apply to redeclarations (after
prefixes are inherited, \cref{redeclaration}):
\begin{itemize}
\item
  Only classes and components declared as replaceable can be redeclared with a new type, which must have an interface compatible with the constraining
  interface of the original declaration, and to allow further redeclarations one must use \lstinline!redeclare replaceable!.
  \begin{nonnormative}
  Redeclaration with the same type can be used to restrict variability and/or change array dimensions.
  \end{nonnormative}
\item
  An element declared as \lstinline!constant! cannot be redeclared.
\item
  An element declared as \lstinline!final! shall not be modified, and thus not redeclared.
\item
  Modelica does not allow a protected element to be redeclared as public, or a public element to be redeclared as protected.
\item
  Array dimensions may be redeclared; provided the sub-typing rules in \cref{interface-compatibility-or-subtyping} are satisfied.
  \begin{nonnormative}
  This is one example of redeclaration of non-replaceable elements.
  \end{nonnormative}
\end{itemize}

\subsection{Annotations for Redeclaration and Modification}\label{annotation-choices-for-suggested-redeclarations-and-modifications}

A declaration can have an annotation \fmtannotationindex{choices} containing modifiers on \lstinline!choice!, where each of them indicates a suitable redeclaration or modifications of the element.

This is a hint for users of the model, and can also be used by the user interface to suggest reasonable redeclaration, where the string comments on the choice declaration can be used as textual explanations of the choices.
The annotation is not restricted to replaceable elements but can also be applied to non-replaceable elements, enumeration types, and simple variables.
For a \lstinline!Boolean! variable, a \lstinline!choices! annotation may contain the definition \lstinline!checkBox = true!, meaning to display a checkbox to input the values \lstinline!false! or \lstinline!true! in the graphical user interface.

The annotation \lstinline!choicesAllMatching = true!\annotationindex{choicesAllMatching} on a replaceable element indicates that tools should automatically construct a menu with choices of elements usable for replacing it.
Exact criteria for inclusion in such a menu are not defined, but there shall be a a way to at least get a selection of classes, \lstinline!A.B.$\ldots$.X.Z!, that are either directly or indirectly derived by inheritance from the constraining class of the declaration, where \lstinline!A! to \lstinline!X! are non-partial packages, and \lstinline!Z! is non-partial.
This menu can be disabled using annotation \lstinline!choicesAllMatching = false!.
It is possible to combine the two annotations for one declaration, and tools may avoid generating duplicate menu entries in that case.
\begin{nonnormative}
The behavior when \lstinline!choicesAllMatching! is not specified; ideally it should present (at least) the same choices as for \lstinline!choicesAllMatching = true;! but if it takes (too long) time to present the list it is better to have \lstinline!choicesAllMatching = false!.
\end{nonnormative}

\begin{example}
\begin{lstlisting}[language=modelica]
replaceable model MyResistor = Resistor
  annotation(choices(
               choice(redeclare model MyResistor=lib2.Resistor(a={2}) "$\ldots$"),
               choice(redeclare model MyResistor=lib2.Resistor2 "$\ldots$")));

replaceable Resistor Load(R = 2) constrainedby TwoPin
  annotation(choices(
               choice(redeclare lib2.Resistor Load(a={2}) "$\ldots$"),
               choice(redeclare Capacitor Load(L=3) "$\ldots$")));

replaceable FrictionFunction a(func = exp) constrainedby Friction
  annotation(choices(
               choice(redeclare ConstantFriction a(c=1) "$\ldots$"),
               choice(redeclare TableFriction a(table="$\ldots$") "$\ldots$"),
               choice(redeclare FunctionFriction a(func=exp) "$\ldots$")));

replaceable package Medium = Modelica.Media.Water.ConstantPropertyLiquidWater
  constrainedby Modelica.Media.Interfaces.PartialMedium
  annotation(choicesAllMatching = true);
\end{lstlisting}

It can also be applied to nonreplaceable declarations, e.g.\ to describe enumerations.
\begin{lstlisting}[language=modelica]
type KindOfController = Integer(min = 1, max = 3)
  annotation(choices(
              choice = 1 "P",
              choice = 2 "PI",
              choice = 3 "PID"));

model A
  parameter KindOfController x;
end A;
A a(x = 3 "PID");
\end{lstlisting}

It can also be applied to \lstinline!Boolean! variables to define a check box.
\begin{lstlisting}[language=modelica]
parameter Boolean useHeatPort = false annotation(choices(checkBox = true));
\end{lstlisting}
\end{example}
