\chapter{Arrays}\doublelabel{arrays}

An array can be regarded as a collection of values, all of the same
type. Modelica arrays can be multidimensional and are ``rectangular'',
which in the case of matrices has the consequence that all rows in a
matrix have equal length, and all columns have equal length.

Each array has a certain dimensionality, i.e., number of dimensions. The
degenerate case of a scalar variable is not really an array, but can be
regarded as an array with zero dimensions. Vectors have one dimension,
matrices have two dimensions, etc.

\begin{nonnormative}
So-called row vectors and column vectors do not exist in Modelica and cannot be distinguished since vectors have only one
dimension.  If distinguishing these is desired, row matrices and column matrices are available, being the corresponding
two-dimensional entities.  However, in practice this is seldom needed since the usual matrix arithmetic and linear algebra
operations have been defined to give the expected behavior when operating on Modelica vectors and matrices.
\end{nonnormative}

Modelica is a strongly typed language, which also applies to array
types. The number of dimensions of an array is fixed and cannot be
changed at run-time. However, the sizes of array dimensions can
be computed at run-time.

\begin{nonnormative}
The fixed number of array dimensions permits strong type checking and efficient implementation.  The non-fixed sizes of array
dimensions on the other hand, allow fairly generic array manipulation code to be written as well as interfacing to standard
numeric libraries implemented in other programming languages.
\end{nonnormative}

An array is allocated by declaring an array variable or calling an array
constructor. Elements of an array can be indexed by \lstinline!Integer!, \lstinline!Boolean!, or
\lstinline!enumeration! values.

\section{Array Declarations}\doublelabel{array-declarations}

The Modelica type system includes scalar number, vector, matrix (number
of dimensions, ndim=2), and arrays of more than two dimensions.

\begin{nonnormative}
There is no distinction between a row and column vector.
\end{nonnormative}

The following table shows the two possible forms of declarations and
defines the terminology. \lstinline!C! is a placeholder for any class, including the
built-in type classes \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, \lstinline!String!, and enumeration
types. The type of a dimension upper bound expression, e.g.\ $n$, $m$, $p$, \ldots
in the table below, need to be a subtype of \lstinline!Integer! or \lstinline!EB! for a class \lstinline!EB!
that is an enumeration type or subtype of the \lstinline!Boolean! type.

Colon (\lstinline!:!) indicates that the dimension upper bound is unknown and is a subtype of \lstinline!Integer!.  The size of such a variable can be determined from its binding equation, or the
size of any of its array attributes, see also \autoref{flexible-array-sizes-and-resizing-of-arrays-in-functions}.  The size cannot be determined from other equations or algorithm.

Upper and lower array dimension index bounds are described in \autoref{array-dimension-lower-and-upper-index-bounds}.

An array indexed by \lstinline!Boolean! or enumeration type can only be used in the following ways:
\begin{itemize}
\item
  Subscripted using expressions of the appropriate type (i.e.\ \lstinline!Boolean! or the enumerated type).
\item
  Binding equations of the form \lstinline!x1 = x2! as well as declaration assignments of the form \lstinline!x1 := x2! are allowed for arrays independent of
  whether the index types of dimensions are subtypes of \lstinline!Integer!, \lstinline!Boolean!, or enumeration types.
\end{itemize}

% IMPROVETOP
\begin{longtable}{|l|l|l|l|p{4cm}|}
\caption{General forms of declaration of arrays.}\\
\hline
\tablehead{Modelica form 1} & \tablehead{Modelica form 2} & \tablehead{\# dims} & \tablehead{Designation} & \tablehead{Explanation}\\ \hline
\endhead
\lstinline!C x!;            & \lstinline!C x!; & $0$ & Scalar & Scalar\\ \hline
\lstinline!C[$n$] x;!       & \lstinline!C x[$n$];! & $1$ & Vector & $n$-Vector\\ \hline
\lstinline!C[EB] x;!        & \lstinline!C x[EB]! & $1$ & Vector & Vector index by enumeration or \lstinline!Boolean! type \lstinline!EB!\\ \hline
\lstinline!C[$n$, $m$] x;!  & \lstinline!C x[$n$, $m$];! & $2$ & Matrix & $n \times m$ Matrix\\ \hline
\lstinline!C[$n_1$, $n_{2}$, $\ldots$, $n_k$] x;! &
\lstinline!C x[$n_{1}$, $n_{2}$, $\ldots$, $n_{k}$];! & $k$ & Array & Array with $k$ dimensions ($k \geq 0$).\\ \hline
\end{longtable}

\begin{example}
The number of dimensions and the dimensions sizes are part of
the type, and shall be checked for example at redeclarations.
Declaration form 1 displays clearly the type of an array, whereas
declaration form 2 is the traditional way of array declarations in
languages such as Fortran, C, C++.

\begin{lstlisting}[language=modelica]
Real[:] v1, v2 // vectors v1 and v2 have unknown sizes. The actual sizes may be different.
\end{lstlisting}
It is possible to mix the two declaration forms although it might be confusing.
\begin{lstlisting}[language=modelica]
Real[3, 2] x[4, 5]; // x has type Real[4, 5, 3, 2];
\end{lstlisting}
The reason for this order is given by examples such as:
\begin{lstlisting}[language=modelica]
type R3 = Real[3];
R3 a;
R3 b[1] = {a};
Real[3] c[1] = b;
\end{lstlisting}
Using a type for \lstinline!a! and \lstinline!b! in this way is normal, and substituting a type by its definition allows \lstinline!c!.

A vector \lstinline!y! indexed by enumeration values
\begin{lstlisting}[language=modelica]
type TwoEnums = enumeration(one,two);
Real[TwoEnums] y;
\end{lstlisting}
\end{example}

Zero-valued dimensions are allowed, so: \lstinline!C x[0];! declares an empty vector and: \lstinline!C x[0,3]!; an empty matrix.

\begin{nonnormative}
Special cases:
\begin{longtable}{|l|l|l|l|p{3cm}|}
\caption{Declaration of arrays as 1-vectors, row-vectors, or column-vectors of arrays.}\\
\hline
\tablehead{Modelica form 1} & \tablehead{Modelica form 2} & \tablehead{\# dims} & \tablehead{Designation} & \tablehead{Explanation}\\ \hline
\endhead
\lstinline!C[1] x;!      & \lstinline!C x[1];!      & $1$ & Vector & 1-Vector, representing a scalar\\ \hline
\lstinline!C[1, 1] x;!   & \lstinline!C x[1, 1];!   & $2$ & Matrix & $(1 \times 1)$-Matrix, representing a scalar\\ \hline
\lstinline!C[$n$, 1] x;! & \lstinline!C x[$n$, 1];! & $2$ & Matrix & $(n \times 1)$-Matrix, representing a column\\ \hline
\lstinline!C[1, $n$] x;! & \lstinline!C x[1, $n$];! & $2$ & Matrix & $(1 \times n)$-Matrix, representing a row\\ \hline
\end{longtable}
\end{nonnormative}

The type of an array of array is the multidimensional array which is constructed by taking the first dimensions from the component declaration and subsequent dimensions
from the maximally expanded component type.  A type is maximally expanded, if it is either one of the built-in types (\lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!,
\lstinline!String!, enumeration type) or it is not a type class.  Before operator overloading is applied, a type class of a variable is maximally expanded.

\begin{example}
\begin{lstlisting}[language=modelica]
type Voltage = Real(unit = "V");
type Current = Real(unit = "A");
connector Pin
  Voltage v; // type class of v = Voltage, type of v = Real
  flow Current i; // type class of i = Current, type of i = Real
end Pin;
type MultiPin = Pin[5];
MultiPin[4] p; // type class of p is MultiPin, type of p is Pin[4, 5];
type Point = Real[3];
Point p1[10];
Real p2[10, 3];
\end{lstlisting}
The components \lstinline!p1! and \lstinline!p2! have identical types.
\begin{lstlisting}[language=modelica]
p2[5] = p1[2] + p2[4]; // equivalent to p2[5, :] = p1[2, :] + p2[4, :]
Real r[3] = p1[2]; // equivalent to r[3] = p1[2, :]
\end{lstlisting}
\end{example}

\begin{nonnormative}
Automatic assertions at simulation time:

Let \lstinline!A! be a declared array and \lstinline!i! be the declared maximum dimension size of the \lstinline!di!-dimension, then an assert statement
\lstinline!assert(i >= 0, $\ldots$)! is generated provided this assertion cannot be checked at compile time.  It is a quality of implementation
issue to generate a good error message if the assertion fails.

Let \lstinline!A! be a declared array and \lstinline!i! be an index accessing an index of the \lstinline!di!-dimension.  Then for every such index-access an assert
statement \lstinline!assert(1 <= i and i <= size(A, di), $\ldots$)! is generated, provided this assertion cannot be checked at compile time.

For efficiency reasons, these implicit assert statements may be optionally suppressed.
\end{nonnormative}

\subsection{Array Dimension Lower and Upper Index Bounds}\doublelabel{array-dimension-lower-and-upper-index-bounds}

The lower and upper index bounds for a dimension of an array indexed by \lstinline!Integer!, \lstinline!Boolean!, or \lstinline!enumeration! values are as follows:
\begin{itemize}
\item
  An array dimension indexed by \lstinline!Integer! values has a lower bound of 1 and an upper bound being the size of the dimension.
\item
  An array dimension indexed by \lstinline!Boolean! values has the lower bound \lstinline!false! and the upper bound \lstinline!true!.
\item
  An array dimension indexed by \lstinline!enumeration! values of the type \lstinline!E = enumeration(e1, e2, $\ldots$, en)!
  has the lower bound \lstinline!E.e1! and the upper bound \lstinline!E.en!.
\end{itemize}

\section{Flexible Array Sizes}\doublelabel{flexible-array-sizes}

Regarding flexible array sizes and resizing of arrays in functions, see
\autoref{flexible-array-sizes-and-resizing-of-arrays-in-functions}.

\section{Built-in Array Functions}\doublelabel{built-in-array-functions}

Modelica provides a number of built-in functions that are applicable to arrays.

The following \lstinline!promote! function is
utilized below to define other array operators and functions:
\begin{longtable}[]{|l|p{9cm}|}
\caption{Promote function (cannot be used in Modelica).}\\
\hline \endhead
\lstinline!promote(A, $n$)! & Fills dimensions of size 1 from the right to array \lstinline!A! upto
dimension $n$, where $n \geq$ \lstinline!ndims(A)! is required. Let \lstinline!C = promote(A, $n$)!, with $n_{\mathrm{A}}$ = \lstinline!ndims(A)!,
then \lstinline!ndims(C) = $n$!, \lstinline!size(C, $j$) = size(A, $j$)! for $1 \leq j \leq n_{\mathrm{A}}$,
\lstinline!size(C, $j$)! = $1$ for $n_{\mathrm{A}} + 1 \leq j \leq n$, \lstinline!C[$i_{1}$, $\ldots$, $i_{n_{\mathrm{A}}}$, 1, $\ldots$, 1]! =
\lstinline!A[$i_{1}$, $\ldots$, $i_{n_{\mathrm{A}}}$]!\\ \hline
\end{longtable}
The argument $n$ must be a constant that can be evaluated during translation, as it determines
the number of dimensions of the returned array.
\begin{nonnormative}
An $n$ that is not a constant that can be evaluated during translation for \lstinline!promote!
complicates matrix handling as it
can change matrix-equations in subtle ways (e.g.\ changing inner products to matrix multiplication).
\end{nonnormative}

\begin{nonnormative}
Some examples of using the functions defined in the following
\autoref{array-dimension-and-size-functions} to \autoref{matrix-and-vector-algebra-functions}:
\begin{lstlisting}[language=modelica]
Real x[4,1,6];
size(x,1) = 4;
size(x); // vector with elements 4, 1, 6
size(2*x+x ) = size(x);
Real[3] v1 = fill(1.0, 3);
Real[3,1] m = matrix(v1);
Real[3] v2 = vector(m);
Boolean check[3,4] = fill(true, 3, 4);
\end{lstlisting}
\end{nonnormative}

\subsection{Array Dimension and Size Functions}\doublelabel{array-dimension-and-size-functions}

The following built-in functions for array dimensions and dimension
sizes are provided:
\begin{longtable}[]{|l|p{9cm}|}
\caption{Built-in array dimension and size functions.}\\
\hline
\tablehead{Modelica} & \tablehead{Explanation}\\ \hline
\endhead
\lstinline!ndims(A)! &
Returns the number of dimensions $k$ of expression \lstinline!A!, with $k \geq 0$.
\\ \hline
\lstinline!size(A, $i$)! &
Returns the size of dimension $i$ of array expression \lstinline!A! where $0 \leq i \leq \text{\lstinline!ndims(A)!}$.\\ \hline
\lstinline!size(A)! &
Returns a vector of length \lstinline!ndims(A)! containing the dimension sizes of \lstinline!A!.\\ \hline
\end{longtable}

\subsection{Dimensionality Conversion Functions}\doublelabel{dimensionality-conversion-functions}

The following built-in conversion functions convert scalars, vectors,
and arrays to scalars, vectors, or matrices by adding or removing
1-sized dimensions.

\begin{longtable}[]{|l|p{9cm}|}
\caption{Built-in dimensionality conversion functions.}\\
\hline
\tablehead{Modelica} & \tablehead{Explanation}\\ \hline
\endhead
\lstinline!scalar(A)! & Returns the single element of array \lstinline!A!. $\text{\lstinline!size(A, i)!} = 1$ is required for $1
\leq \text{\lstinline!i!} \leq \text{\lstinline!ndims(A)!}$.\\ \hline
\lstinline!vector(A)!
&
Returns a 1-vector, if A is a scalar and otherwise returns a vector
containing all the elements of the array, provided there is at most one
dimension size $> 1$.\\ \hline
\lstinline!matrix(A)!
&
Returns \lstinline!promote(A, 2)!, if \lstinline!A! is a scalar or vector and otherwise returns
the elements of the first two dimensions as a matrix. $\text{\lstinline!size(A, i)!} = 1$ is
required for $2 < \text{\lstinline!i!} \leq \text{\lstinline!ndims(A)!}$.\\ \hline
\end{longtable}

\subsection{Specialized Array Constructor Functions}\doublelabel{specialized-array-constructor-functions}

An array constructor function constructs and returns an array computed
from its arguments. Most of the constructor functions in the table below
construct an array by filling in values according to a certain pattern,
in several cases just giving all array elements the same value. The
general array constructor with syntax \lstinline!array! (\ldots{}) or \{\ldots{}\}
is described in \autoref{vector-matrix-and-array-constructors}.

\begin{longtable}[]{|l|p{11cm}|}
\caption{Specialized array constructor functions.}\\
\hline
\tablehead{Modelica} & \tablehead{Explanation}\\ \hline
\endhead
\lstinline!identity($n$)!
&
Returns the $n \times n$ \lstinline!Integer! identity matrix, with ones on the diagonal and
zeros at the other places.\\ \hline
\lstinline!diagonal(v)!
&
Returns a square matrix with the elements of vector v on the diagonal
and all other elements zero.\\ \hline
\lstinline!zeros($n_{1}$, $n_{2}$, $n_{3}$, $\ldots$)! &
Returns the $n_{1} \times n_{2} \times n_{3} \times \ldots$ \lstinline!Integer! array with all elements equal to zero ($n_{i} \geq 0$).
The function needs one or more arguments, that is, \lstinline!zeros()! is not legal.\\ \hline
\lstinline!ones($n_{1}$, $n_{2}$, $n_{3}$, $\ldots$)! &
Return the $n_{1} \times n_{2} \times n_{3} \times \ldots$ \lstinline!Integer! array with all elements equal to one ($n_{i} \geq 0$).
The function needs one or more arguments, that is, \lstinline!ones()! is not legal.\\ \hline
\lstinline!fill(s, $n_{1}$, $n_{2}$, $n_{3}$, $\ldots$)! &
Returns the $n_{1} \times n_{2} \times n_{3} \times \ldots$ array with all elements equal to scalar or array expression \lstinline!s!
($n_{i} \geq 0$). The returned array has the same type as \lstinline!s!.
Recursive definition:
\lstinline!fill(s, $n_{1}$, $n_{2}$, $n_{3}$, $\ldots$)! =
\lstinline!fill(fill(s, $n_{2}$, $n_{3}$, $\ldots$), $n_{1}$)!;
\lstinline!fill(s, $n$)! = \lstinline!{s, s, $\ldots$, s}!.
The function needs two or more arguments; that is \lstinline!fill(s)! is not legal.\\ \hline
\lstinline!linspace($x_{1}$, $x_{2}$, $n$)!
&
Returns a \lstinline!Real! vector with $n$ equally spaced elements, such that \lstinline!v = linspace($x_{1}$, $x_{2}$, $n$)! results in
\begin{equation*}
\text{\lstinline!v[$i$]!} = x_{1} + (x_{2} - x_{1}) \frac{i - 1}{n - 1} \quad \text{for $1 \leq i \leq n$}
\end{equation*}
It is required that $n \geq 2$.  The arguments $x_{1}$ and $x_{2}$ shall be numeric scalar expressions.\\ \hline
\end{longtable}

\subsection{Reduction Functions and Operators}\doublelabel{reduction-functions-and-operators}

A reduction function ``reduces'' an array (or several scalars) to one value (normally a scalar, but the \lstinline!sum! reduction function may give an array as result
and also be applied to an operator record).  Note that none of these operators (particularly \lstinline!min! and \lstinline!max!) generate events themselves (but arguments
could generate events).  The restriction on the type of the input in \autoref{reduction-expressions} for reduction expressions also applies to the array elements/scalar
inputs for the reduction operator with the same name.

The \lstinline!sum! reduction function (both variants) may be applied to an operator record, provided that the operator record defines \lstinline!'0'! and \lstinline!'+'!.
It is then assumed to form an additive group.

The following reduction functions are available:
\begin{longtable}{|p{4.1cm}|p{10.1cm}|}
\caption{Array reduction functions and operators.}\\
\hline
\tablehead{Modelica} & \tablehead{Explanation}\\ \hline
\endhead
\lstinline!min(A)!
&
Returns the least element of array expression \lstinline!A!; as defined by \lstinline!<!.\\ \hline
\lstinline!min(x, y)!
&
Returns the least element of the scalars \lstinline!x! and \lstinline!y!; as defined by \lstinline!<!.\\ \hline
\begin{tabular}{@{}p{4cm}@{}}
\lstinline!min(e(i, $\ldots$, j)!\\
\lstinline! for i in u, $\ldots$,!\\
\lstinline!     j in v)!
\end{tabular}
&
\begin{tabular}{@{}p{10cm}@{}}
Also described in \autoref{reduction-expressions}.  Returns the least value (as defined by \lstinline!<!) of the scalar expression
\lstinline!e(i, $\ldots$, j)! evaluated for all combinations of \lstinline!i! in \lstinline!u!, \ldots, \lstinline!j! in \lstinline!v!.
\end{tabular}\\ \hline
\lstinline!max(A)!
&
Returns the greatest element of array expression \lstinline!A!; as defined by
\lstinline!>!.\\ \hline
\lstinline!max(x, y)!
&
Returns the greatest element of the scalars \lstinline!x! and \lstinline!y!; as defined by
\lstinline!>!.\\ \hline
\begin{tabular}{@{}p{4cm}@{}}
\lstinline!max(e(i, $\ldots$, j)!\\
\lstinline! for i in u, $\ldots$,!\\
\lstinline!     j in v)!
\end{tabular}
&
\begin{tabular}{@{}p{10cm}@{}}
Also described in \autoref{reduction-expressions}.  Returns the greatest value (as defined by \lstinline!>!) of the scalar expression
\lstinline!e(i, $\ldots$, j)! evaluated for all combinations of \lstinline!i! in \lstinline!u!, \ldots, \lstinline!j! in \lstinline!v!.
\end{tabular}\\ \hline
\lstinline!sum(A)!
&
\begin{tabular}{@{}p{10cm}@{}}
Returns the scalar sum of all the elements of array expression \lstinline!A!:\\
\lstinline!= sum(A[j, k, $\ldots$] for j, k, $\ldots$)!
\end{tabular}\\ \hline
\begin{tabular}{@{}p{5cm}@{}}
\lstinline!sum(e(i, $\ldots$, j)!\\
\lstinline! for i in u, $\ldots$,!\\
\lstinline!     j in v)!
\end{tabular}
&
\begin{tabular}{@{}p{10cm}@{}}
Also described in \autoref{reduction-expressions}.  Returns the sum of the expression \lstinline!e(i, $\ldots$, j)! evaluated for all
combinations of \lstinline!i in u!, $\ldots$, \lstinline!j in v!: For \lstinline!Integer! indexing this is
\begin{lstlisting}[language=modelica]
e(u[1], $\ldots$, v[1]) + e(u[2], $\ldots$, v[1]) + $\ldots$
 + e(u[end], $\ldots$, v[1]) + $\ldots$
 + e(u[end], $\ldots$, v[end])
\end{lstlisting}
For non-\lstinline!Integer! indexing this uses all valid indices instead of 1..\lstinline!end!.
The type of \lstinline!sum(e(i, $\ldots$, j) for i in u, $\ldots$, j in v)! is the same as the type of \lstinline!e(i, $\ldots$, j)!.
\end{tabular}\\ \hline
\lstinline!product(A)!
&
\begin{tabular}{@{}p{10cm}@{}}
Returns the scalar product of all the elements of array expression \lstinline!A!:\\
\lstinline!= product(A[j, k, $\ldots$] for j, k, $\ldots$)!
\end{tabular}\\ \hline
\begin{tabular}{@{}p{4cm}@{}}
\lstinline!product(e(i, $\ldots$, j)!\\
\lstinline! for i in u, $\ldots$,!\\
\lstinline!     j in v)!
\end{tabular}
&
\begin{tabular}{@{}p{10cm}@{}}
Also described in \autoref{reduction-expressions}.  Returns the product of the scalar expression \lstinline!e(i, $\ldots$, j)! evaluated for
all combinations of \lstinline!i in u!, \ldots, \lstinline!j in v!: For \lstinline!Integer! indexing this is
\begin{lstlisting}[language=modelica]
e(u[1], $\ldots$, v[1]) * e(u[2], $\ldots$, v[1]) * $\ldots$
 * e(u[end], $\ldots$, v[1]) * $\ldots$
 * e(u[end], $\ldots$, v[end])
\end{lstlisting}
For non-\lstinline!Integer! indexing this uses all valid indices instead of 1..\lstinline!end!.
The type of \lstinline!product(e(i, $\ldots$, j) for i in u, $\ldots$, j in v)! is the same as the type of \lstinline!e(i, $\ldots$, j)!.
\end{tabular}
\\ \hline
\end{longtable}

\subsubsection{Reduction Expressions}\doublelabel{reduction-expressions}

An expression:
\begin{lstlisting}[language=grammar]
function-name "(" expression1 for iterators ")"
\end{lstlisting}

is a reduction-expression. The expressions in the iterators of a
reduction-expression shall be vector expressions. They are evaluated
once for each reduction-expression, and are evaluated in the scope
immediately enclosing the reduction-expression.

For an iterator:
\begin{lstlisting}[language=grammar]
IDENT in expression2
\end{lstlisting}

the loop-variable, \lstinline!IDENT!, is in scope inside \lstinline!expression1!. The
loop-variable may hide other variables, as in for-clauses. The result
depends on the \lstinline!function-name!, and currently the only legal
function-names are the built-in operators \lstinline!array!, \lstinline!sum!,
\lstinline!product!, \lstinline!min!, and
\lstinline!max!. For array, see \autoref{vector-matrix-and-array-constructors}. If \lstinline!function-name! is
\lstinline!sum!, \lstinline!product!, \lstinline!min!,
or \lstinline!max! the result is of the same type as \lstinline!expression1! and is constructed
by evaluating \lstinline!expression1! for each value of the loop-variable and
computing the \lstinline!sum!, \lstinline!product!, \lstinline!min!, or
\lstinline!max! of the computed elements. For
deduction of ranges, see \autoref{implicit-iteration-ranges}; and for using types as ranges
see \autoref{types-as-iteration-ranges}.

\begin{longtable}{|p{3cm}|p{5cm}|p{6cm}|}
\caption{Reduction expressions with iterators.}\\
\hline
\tablehead{Function-name} & \tablehead{Restriction on expression1} & \tablehead{Result if expression2 is empty}\\ \hline
\endhead
\lstinline!sum! & \lstinline!Integer! or \lstinline!Real! & \lstinline!zeros($\ldots$)!\\ \hline
\lstinline!product! & Scalar \lstinline!Integer! or \lstinline!Real! & \lstinline!1!\\ \hline
\lstinline!min! & Scalar enumeration, \lstinline!Boolean!, \lstinline!Integer! or \lstinline!Real! &
\begin{tabular}{@{}p{6cm}@{}}
Greatest value of type\\
(\lstinline!Modelica.Constants.inf! for \lstinline!Real!)
\end{tabular}\\ \hline
\lstinline!max! & Scalar enumeration, \lstinline!Boolean!, \lstinline!Integer! or \lstinline!Real! &
\begin{tabular}{@{}p{6cm}@{}}
Least value of type\\
(\lstinline!-Modelica.Constants.inf! for \lstinline!Real!)
\end{tabular}\\ \hline
\end{longtable}

\begin{example}
% No frame since the math would break it.
\begin{lstlisting}[language=modelica, frame=none]
sum(i for  i in 1:10) // Gives $\sum_{i=1}^{10}i=$1+2+...+10=55
// Read it as: compute the sum of i for i in the range 1 to 10.
sum(i^2 for  i in {1,3,7,6}) // Gives $\sum_{i\in \begin{Bmatrix}1&3&7&6\end{Bmatrix}}i^2=$1+9+49+36=95
{product(j for j in 1:i) for i in 0:4} // Gives {1,1,2,6,24}
max(i^2 for  i in {3,7,6}) // Gives 49
\end{lstlisting}
\end{example}

\subsection{Matrix and Vector Algebra Functions}\doublelabel{matrix-and-vector-algebra-functions}

The following set of built-in matrix and vector algebra functions are available.  The function transpose and symmetric can be applied to any matrix.
The functions \lstinline!outerProduct!, \lstinline!cross! and \lstinline!skew! require \lstinline!Real!/\lstinline!Integer! vector(s) or matrix as input(s)
and returns a \lstinline!Real!/\lstinline!Integer! vector or matrix (the result is only \lstinline!Integer! if the input/all inputs are \lstinline!Integer!):
\begin{longtable}[]{|p{3.5cm}|p{11.5cm}|}
\caption{Matrix and vector algebra functions.}\\
\hline
\tablehead{Modelica} & \tablehead{Explanation}\\ \hline
\endhead
\lstinline!transpose(A)!
& Permutes the first two dimensions of array \lstinline!A!. It is an error, if array \lstinline!A!
does not have at least 2 dimensions.\\ \hline
\lstinline!outerProduct(x, y)!
&
\begin{tabular}{@{}p{10cm}@{}}
Returns the outer product of vectors \lstinline!x! and \lstinline!y!:\\
\lstinline!= matrix(x) * transpose(matrix(y))!
\end{tabular}\\ \hline
\lstinline!symmetric(A)!
& Returns a symmetric matrix which is identical to the square matrix \lstinline!A!
on and above the diagonal.  I.e., \lstinline!B := symmetric(A)! implies
\begin{equation*}
\text{\lstinline!B[$i$, $j$]!} =
\begin{cases}
\text{\lstinline!A[$i$, $j$]!} & \text{if $i \leq j$}\\
\text{\lstinline!A[$j$, $i$]!} & \text{if $i > j$}
\end{cases}
\end{equation*}\\ \hline
\lstinline!cross(x, y)!
&
\begin{tabular}{@{}p{10cm}@{}}
Returns the cross product of the 3-vectors \lstinline!x! and \lstinline!y!:
\begin{lstlisting}[frame=none,aboveskip=-\parskip,belowskip=-\medskipamount]
= vector([ x[2] * y[3] - x[3] * y[2];
           x[3] * y[1] - x[1] * y[3];
           x[1] * y[2] - x[2] * y[1] ])
\end{lstlisting}
\end{tabular}\\ \hline
\lstinline!skew(x)!
&
\begin{tabular}{@{}p{10cm}@{}}
Returns the $3 \times 3$ skew symmetric matrix associated with a 3-vector, i.e., \lstinline!cross(x, y) = skew(x) * y!, or --- equivalently --- \lstinline!skew(x)!
\begin{lstlisting}[frame=none,aboveskip=-\parskip,belowskip=-\medskipamount]
= [ 0,   -x[3], x[2] ;
    x[3], 0,   -x[1] ;
   -x[2], x[1], 0    ]
\end{lstlisting}
\end{tabular}\\ \hline
\end{longtable}

\section{Vector, Matrix and Array Constructors}\doublelabel{vector-matrix-and-array-constructors}

The constructor function \lstinline!array(A, B, C, $\ldots$)! constructs an array from its arguments according to the following rules:
\begin{itemize}
\item
  Size matching: All arguments must have the same sizes, i.e.,
  \lstinline!size(A)! = \lstinline!size(B)! = \lstinline!size(C)! = \ldots
\item
  All arguments must be type compatible expressions (\autoref{type-compatible-expressions}) giving the type of the elements.  The data type of the result array is the
  maximally expanded type of the arguments. \lstinline!Real! and \lstinline!Integer! subtypes can be mixed resulting in a \lstinline!Real! result array where the
  \lstinline!Integer! numbers have been transformed to \lstinline!Real! numbers.
\item
  Each application of this constructor function adds a one-sized dimension to the left in the result compared to the dimensions of the argument arrays, i.e.,
  \lstinline!ndims(array(A, B, C)) = ndims(A) + 1 = ndims(B) + 1, $\ldots$!
\item
  \lstinline!{A, B, C, $\ldots$}! is a shorthand notation for \lstinline!array(A, B, C, $\ldots$)!.
\item
  There must be at least one argument.
  \begin{nonnormative}
  The reason \lstinline!array()! or \lstinline!{}! is not defined is that at least one argument is needed to determine the type of the resulting array.
  \end{nonnormative}
\end{itemize}

\begin{example}
\begin{lstlisting}[language=modelica, escapechar=!]
{1, 2, 3} !\emph{is a 3-vector of type Integer}.!
{{11, 12, 13}, {21, 22, 23}} !\emph{is a 2 x 3 matrix of type Integer}!
{{{1.0, 2.0, 3.0}}} !\emph{is a 1 x 1 x 3 array of type Real}.!

Real[3] v = array(1, 2, 3.0);
type Angle = Real(unit="rad");
parameter Angle alpha = 2.0; // type of alpha is Real.
// array(alpha, 2, 3.0) or {alpha, 2, 3.0} is a 3-vector of type Real.
Angle[3] a = {1.0, alpha, 4}; // type of a is Real[3].
\end{lstlisting}
\end{example}

\subsection{Array Constructor with Iterators}\doublelabel{array-constructor-with-iterators}

An expression:
\begin{lstlisting}[language=grammar]
"{" expression for iterators "}"
\end{lstlisting}
or
\begin{lstlisting}[language=grammar]
array "(" expression for iterators ")"
\end{lstlisting}

is an array constructor with iterators. The expressions inside the
iterators of an array constructor shall be vector expressions. They are
evaluated once for each array constructor, and are evaluated in the
scope immediately enclosing the array constructor.

For an iterator:
\begin{lstlisting}[language=modelica]
IDENT in array_expression
\end{lstlisting}

the loop-variable, \lstinline!IDENT!, is in scope inside expression in the array construction.  The loop-variable may hide other variables, as in for-clauses.  The loop-variable has the same type as
the type of the elements of \lstinline!array_expression!; and can be simple type as well as a record type.  The loop-variable will have the same type for the entire loop --- i.e., for an
\lstinline!array_expression! \lstinline!{1, 3.2}! the iterator will have the type of the type-compatible expression (\lstinline!Real!) for all iterations.  For deduction of ranges, see
\autoref{implicit-iteration-ranges}; and for using types as range see \autoref{types-as-iteration-ranges}.

\subsubsection{Array Constructor with One Iterator}\doublelabel{array-constructor-with-one-iterator}

If only one iterator is used, the result is a vector constructed by
evaluating expression for each value of the loop-variable and forming an
array of the result.

\begin{example}
\begin{lstlisting}[language=modelica]
array(i for i in 1:10)
// Gives the vector 1:10={1,2,3,...,10}

{r for r in 1.0 : 1.5 : 5.5}
// Gives the vector 1.0:1.5:5.5={1.0, 2.5, 4.0, 5.5}

{i^2 for i in {1,3,7,6}}
// Gives the vector {1, 9, 49, 36}
\end{lstlisting}
\end{example}

\subsubsection{Array Constructor with Several Iterators}\doublelabel{array-constructor-with-several-iterators}

The notation with several iterators is a shorthand notation for nested
array constructors. The notation can be expanded into the usual form by
replacing each '\lstinline!,!' by '\lstinline!} for!' and prepending the array constructor with
a '\lstinline!{!'.

\begin{example}
\begin{lstlisting}[language=modelica]
Real hilb[:,:]= { 1/(i+j-1) for  i in 1:n, j in 1:n};
Real hilb2[:,:]={{ 1/(i+j-1) for  j in 1:n} for i in 1:n};
\end{lstlisting}
\end{example}

\subsection{Array Concatenation}\doublelabel{array-concatenation}

The function \lstinline!cat($k$, A, B, C, $\ldots$)! concatenates arrays
\lstinline!A!, \lstinline!B!, \lstinline!C!, \ldots along
dimension $k$ according to the following rules:
\begin{itemize}
\item
  Arrays \lstinline!A!, \lstinline!B!, \lstinline!C!, \ldots must have the same number of dimensions, i.e.,
  \lstinline!ndims(A)! = \lstinline!ndims(B)! = \ldots
\item
  Arrays \lstinline!A!, \lstinline!B!, \lstinline!C!, \ldots must be type compatible expressions (\autoref{type-compatible-expressions})
  giving the type of the elements of the result. The maximally expanded
  types should be equivalent. \lstinline!Real! and \lstinline!Integer! subtypes can be mixed
  resulting in a \lstinline!Real! result array where the \lstinline!Integer! numbers have been
  transformed to \lstinline!Real! numbers.
\item
  $k$ has to characterize an existing dimension, i.e., $1 \leq k \leq \text{\lstinline!ndims(A)!} = \text{\lstinline!ndims(B)!} = \text{\lstinline!ndims(C)!}$; $k$ shall be a parameter expression of \lstinline!Integer! type.
\item
  Size matching: Arrays \lstinline!A!, \lstinline!B!, \lstinline!C!, \ldots must have identical array sizes
  with the exception of the size of dimension $k$, i.e., \lstinline!size(A, $j$)! =
  \lstinline!size(B, $j$)!, for $1 \leq j \leq \text{\lstinline!ndims(A)!}$ and $j \neq k$.
\end{itemize}

\begin{example}
\begin{lstlisting}[language=modelica]
Real[2,3] r1 = cat(1, {{1.0, 2.0, 3}}, {{4, 5, 6}});
Real[2,6] r2 = cat(2, r1, 2*r1);
\end{lstlisting}
\end{example}

Formally, the concatenation \lstinline!R = cat($k$, A, B, C, $\ldots$)! is defined as follows.  Let $n$ = \lstinline!ndims(A)! = \lstinline!ndims(B)! = \lstinline!ndims(C)! = \ldots  Then the size of \lstinline!R! is given by
\begin{lstlisting}[language=modelica,escapechar=!,frame=none,xleftmargin=1em]
size(R,$k$) = size(A,$k$) + size(B,$k$) + size(C,$k$) + $\ldots$
size(R,$j$) = size(A,$j$) = size(B,$j$) = size(C,$j$) = $\ldots$ !for! $1 \leq j \leq n$ !and! $j \neq k$
\end{lstlisting}
and the array elements of \lstinline!R! are given by
\begin{lstlisting}[language=modelica,escapechar=!,frame=none,xleftmargin=1em]
R[$i_{1}$, $\ldots$, $i_{k}$, $\ldots$, $i_{n}$] = A[$i_{1}$, $\ldots$, $i_{k}$, $\ldots$, $i_{n}$]
  !for! $0 < i_{k} \leq$ size(A,$k$)
R[$i_{1}$, $\ldots$, $i_{k}$, $\ldots$, $i_{n}$] = B[$i_{1}$, $\ldots$, $i_{k}$ - size(A,$k$), $\ldots$, $i_{n}$]
  !for! size(A,$k$) $< i_{k} \leq$ size(A,$k$) + size(B,$k$)
R[$i_{1}$, $\ldots$, $i_{k}$, $\ldots$, $i_{n}$] = C[$i_{1}$, $\ldots$, $i_{k}$ - size(A,$k$) - size(B,$k$), $\ldots$, $i_{n}$]
  !for! size(A,$k$) + size(B,$k$) $< i_{k} \leq$ size(A,$k$) + size(B,$k$) + size(C,$k$)
$\ldots$
\end{lstlisting}
where $1 \leq i_{j} \leq$ \lstinline!size(R,$j$)! for $1 \leq j \leq n$.


\subsubsection{Array Concatenation along First and Second Dimensions}\doublelabel{array-concatenation-along-first-and-second-dimensions}

For convenience, a special syntax is supported for the concatenation along the first and second dimensions:
\begin{itemize}
\item
  \emph{Concatenation along first dimension}:\\
  \lstinline![A; B; C; $\ldots$] = cat(1, promote(A, n), promote(B, n), promote(C, n), $\ldots$)!
  where \lstinline!n = max(2, ndims(A), ndims(B), ndims(C), $\ldots$)!.  If necessary, 1-sized
  dimensions are added to the right of \lstinline!A!, \lstinline!B!, \lstinline!C! before the operation is
  carried out, in order that the operands have the same number of dimensions which will be at least two.
\item
  \emph{Concatenation along second dimension}:\\
  \lstinline![A, B, C, $\ldots$] = cat(2, promote(A, n), promote(B, n), promote(C, n), $\ldots$)!
  where \lstinline!n = max(2, ndims(A), ndims(B), ndims(C), $\ldots$)!.  If necessary, 1-sized
  dimensions are added to the right of \lstinline!A!, \lstinline!B!, \lstinline!C! before the operation is
  carried out, especially that each operand has at least two dimensions.
\item
  The two forms can be mixed.  \lstinline![$\ldots$, $\ldots$]! has higher precedence than
  \lstinline![$\ldots$; $\ldots$]!, e.g., \lstinline![a, b; c, d]! is parsed as \lstinline![[a, b]; [c, d]]!.
\item
  \lstinline![A] = promote(A, max(2, ndims(A)))!, i.e., \lstinline![A] = A!, if \lstinline!A! has 2 or more dimensions, and it is a matrix
  with the elements of \lstinline!A!, if \lstinline!A! is a scalar or a vector.
\item
  There must be at least one argument (i.e.\ \lstinline![]! is not defined).
\end{itemize}

\begin{example}
\begin{lstlisting}[language=modelica]
Real s1, s2, v1[n1], v2[n2], M1[m1,n],
M2[m2,n], M3[n,m1], M4[n,m2], K1[m1,n,k],
K2[m2,n,k];
[v1;v2] is a (n1+n2) x 1 matrix
[M1;M2] is a (m1+m2) x n matrix
[M3,M4] is a n x (m1+m2) matrix
[K1;K2] is a (m1+m2) x n x k array
[s1;s2] is a 2 x 1 matrix
[s1,s1] is a 1 x 2 matrix
[s1] is a 1 x 1 matrix
[v1] is a n1 x 1 matrix
Real[3] v1 = array(1, 2, 3);
Real[3] v2 = {4, 5, 6};
Real[3,2] m1 = [v1, v2];
Real[3,2] m2 = [v1, [4;5;6]]; // m1 = m2
Real[2,3] m3 = [1, 2, 3; 4, 5, 6];
Real[1,3] m4 = [1, 2, 3];
Real[3,1] m5 = [1; 2; 3];
\end{lstlisting}
\end{example}

\subsection{Vector Construction}\doublelabel{vector-construction}

Vectors can be constructed with the general array constructor, e.g.,
\begin{lstlisting}[language=modelica]
Real[3] v = {1, 2, 3};
\end{lstlisting}
The range vector operator or colon operator of simple-expression can be used instead of or in combination with this general constructor to construct \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean! or enumeration type vectors.  Semantics of the colon operator:
\begin{itemize}
\item
  \lstinline!$j$ : $k$! is the \lstinline!Integer! vector \lstinline!{$j$, $j+1$, $\ldots$, $k$}!, if $j$ and $k$ are of type
  \lstinline!Integer!.
\item
  \lstinline!$j$ : $k$! is the \lstinline!Real! vector \lstinline!{$j$, $j+1.0$, $\ldots$, $j+n$}!, with $n = \text{\lstinline!floor!}(k - j)$, if
  $j$ and/or $k$ are of type \lstinline!Real!.
\item
  \lstinline!$j$ : $k$! is a \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, or \lstinline!enumeration! type vector with zero elements, if $j > k$.
\item
  \lstinline!$j$ : $d$ : $k$! is the \lstinline!Integer! vector \lstinline!{$j$, $j+d$, $\ldots$, $j + n d$}!, with $n = \text{\lstinline!div!}(k - j, d)$, if $j$, $d$, and $k$ are of type \lstinline!Integer!.
\item
  \lstinline!$j$ : $d$ : $k$! is the \lstinline!Real! vector \lstinline!{$j$, $j+d$, $\ldots$, $j + n d$}!, with $n = \text{\lstinline!floor!}((k-j)/d)$,
  if $j$, $d$, or $k$ are of type \lstinline!Real!.  In order to avoid rounding issues for the length it is recommended to use \lstinline!{j + d * i for i in 0 : n}! or
  \lstinline!linspace(j, k, n + 1)! --- if the number of elements are known.
\item
  \lstinline!$j$ : $d$ : $k$! is a \lstinline!Real! or \lstinline!Integer! vector with zero elements, if $d > 0$ and $j > k$ or if $d < 0$ and $j < k$.
\item
  \lstinline!false : true! is the \lstinline!Boolean! vector \lstinline!{false, true}!.
\item
  \lstinline!$j$ : $j$! is \lstinline!{$j$}! if $j$ is \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, or \lstinline!enumeration! type.
\item
  \lstinline!E.ei : E.ej! is the enumeration type vector \lstinline!{E.ei, $\ldots$, E.ej}! where
  $\text{\lstinline!E.ej!} > \text{\lstinline!E.ei!}$, and \lstinline!ei! and \lstinline!ej! belong to some enumeration type
  \lstinline!E = enumeration($\ldots$, ei, $\ldots$, ej, $\ldots$)!.
\end{itemize}

\begin{example}
\begin{lstlisting}[language=modelica]
Real v1[5] = 2.7 : 6.8;
Real v2[5] = {2.7, 3.7, 4.7, 5.7, 6.7}; // = same as v1
Boolean b1[2] = false:true;
Colors = enumeration (red,blue,green);
Colors ec[3] = Colors.red : Colors.green;
\end{lstlisting}
\end{example}

\section{Array Indexing}\doublelabel{array-indexing}

The array indexing operator \emph{name}\lstinline![!\emph{...}\lstinline!]! is used to
access array elements for retrieval of their values or for updating
these values. An indexing operation is subject to upper and lower array
dimension index bounds (\autoref{array-dimension-lower-and-upper-index-bounds}).  The indexing operator takes two or more
operands, where the first operand is the array to be indexed and the rest of the operands are index expressions:

\lstinline!$\mathit{arrayname}$[$\mathit{indexexpr}_{1}$, $\mathit{indexexpr}_{2}$, $\ldots$]!

A colon is used to denote all indices of one dimension. A vector
expression can be used to pick out selected rows, columns and elements
of vectors, matrices, and arrays. The number of dimensions of the
expression is reduced by the number of scalar index arguments. If the
number of index arguments is smaller than the number of dimensions of
the array, the trailing indices will use `\lstinline!:!'.

It is also possible to use the array access operator to assign to
element/elements of an array in algorithm sections. If the index is an
array the assignments take place in the order given by the index array.
For assignments to arrays and elements of arrays, the entire right-hand
side and the index on the left-hand side are evaluated before any
element is assigned a new value.

\begin{nonnormative}
An indexing operation is assumed to take constant time, i.e., largely independent of the size of the array.
\end{nonnormative}

\begin{example}
% henrikt-ma: This listing needs to be cleaned up from confusing punctuation.
\begin{lstlisting}[language=modelica, escapechar=!]
a[:, j] !\emph{is a vector of the j-th column of a,}!
a[j] !\emph{is a vector of the j-th row of a:}! a[j, :]
a[j : k] is {[a[j], a[j+1], ... , a[k]}
a[:,j : k] is [a[:,j], a[:,j+1], ... , a[:,k]],
v[2:2:8] = v[ {2,4,6,8} ] .
v[{j,k}] := {2,3}; // Same as v[j] := 2; v[k] := 3;
v[{1,1}] := {2,3}; // Same as v[1] := 3;
\end{lstlisting}
If \lstinline!x! is a vector, \lstinline!x[1]! is a scalar, but the slice \lstinline!x[1:5]! is a vector
(a vector-valued or colon index expression causes a vector to be returned).
\end{example}

\begin{example}
Array slicing given the declarations \lstinline!x[$n$, $m$]!, \lstinline!v[$k$]!, \lstinline!z[$i$, $j$, $p$]!.
\begin{longtable}[]{|l|l|l|}
\caption{Examples of scalars vs.\ array slices created with the colon index.}\\
\hline
\tablehead{Expression} & \tablehead{\# dims} & \tablehead{Type of value}\\ \hline
\endhead
\lstinline!x[1, 1]!                     & $0$ & Scalar\\ \hline
\lstinline!x[:, 1]!                     & $1$ & $n$-Vector\\ \hline
\lstinline!x[1, :]! or \lstinline!x[1]! & $1$ & $m$-Vector\\ \hline
\lstinline!v[1:$p$]!                    & $1$ & $p$-Vector\\ \hline
\lstinline!x[1:$p$, :]!                 & $2$ & $(p \times m)$-Matrix\\ \hline
\lstinline!x[1:1, :]!                   & $2$ & $1 \times m$ ``row'' matrix\\ \hline
\lstinline!x[{1, 3, 5}, :]!             & $2$ & $(3 \times m)$-Matrix\\ \hline
\lstinline!x[:, v]!                     & $2$ & $(n \times k)$-Matrix\\ \hline
\lstinline!z[:, 3, :]!                  & $2$ & $(i \times p)$-Matrix\\ \hline
\lstinline!x[scalar([1]), :]!           & $1$ & $m$-Vector\\ \hline
\lstinline!x[vector([1]), :]!           & $2$ & $1 \times m$ ``row'' matrix\\ \hline
\end{longtable}
\end{example}

\subsection{Indexing with Boolean or Enumeration Values}\doublelabel{indexing-with-boolean-or-enumeration-values}

Arrays can be indexed using values of enumeration types or the \lstinline!Boolean! type, not only by \lstinline!Integer!.  The type of the index should correspond to
the type used for declaring the dimension of the array.

\begin{example}
\begin{lstlisting}[language=modelica]
  type ShirtSizes = enumeration(small, medium, large, xlarge);
  Real[ShirtSizes] w;
  Real[Boolean] b2;
algorithm
  w[ShirtSizes.large] := 2.28; // Assign a value to an element of w
  b2[true] := 10.0;
  b2[ShirtSizes.medium] := 4; // Error, b2 was declared with Boolean dimension
  w[1] := 3; // Error, w was declared with ShirtSizes dimension
\end{lstlisting}
\end{example}

\subsection{Indexing with end}\doublelabel{indexing-with-end}

The expression \lstinline!end! may only appear inside array subscripts, and if used in the $i$:th subscript of an array expression \lstinline!A! it is equivalent
to \lstinline!size(A, $i$)! provided indices to \lstinline!A! are a subtype of \lstinline!Integer!.  If used inside nested array subscripts it refers
to the most closely nested array.

\begin{example}
\begin{lstlisting}[language=modelica, escapechar=!]
A[end - 1, end] !is! A[size(A,1) - 1, size(A,2)]
A[v[end], end] !is! A[v[size(v,1)], size(A,2)] // !\emph{First}! end !\emph{is referring to end of v.}!
\end{lstlisting}
\end{example}

\section{Scalar, Vector, Matrix, and Array Operator Functions}\doublelabel{scalar-vector-matrix-and-array-operator-functions}

The mathematical operations defined on scalars, vectors, and matrices are the subject of linear algebra.

The term numeric or numeric class is used below for a subtype of the \lstinline!Real! or \lstinline!Integer! type classes.  The standard type coercion defined
in \autoref{standard-type-coercion} applies.

\subsection{Equality and Assignment}\doublelabel{equality-and-assignment}

Equality \lstinline!a = b! and assignment \lstinline!a := b! of scalars, vectors, matrices, and
arrays is defined element-wise and require both objects to have the same
number of dimensions and corresponding dimension sizes. The operands
need to be type equivalent. This is legal for the simple types and all
types satisfying the requirements for a record, and is in the latter
case applied to each component-element of the records.

\begin{longtable}[]{|l|l|l|l|}
\caption{Equality and assignment of arrays and scalars.}\\
\hline
\tablehead{Type of \lstinline!a!} & \tablehead{Type of \lstinline!b!} & \tablehead{Result of} \lstinline!a = b! & \tablehead{Operation} (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & Scalar & a = b\\ \hline
Vector{[}n{]} & Vector{[}n{]} & Vector{[}n{]} & a{[}j{]} = b{[}j{]}\\ \hline
Matrix{[}n, m{]} & Matrix{[}n, m{]} & Matrix{[}n, m{]} & a{[}j, k{]} = b{[}j, k{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & a{[}j, k, \ldots{}{]} = b{[}j, k, \ldots{}{]}\\ \hline
\end{longtable}

\subsection{Array Element-wise Addition, Subtraction, and String Concatenation}\doublelabel{array-element-wise-addition-subtraction-and-string-concatenation}

Addition \lstinline!a+b! and subtraction \lstinline!a-b! of numeric scalars, vectors, matrices,
and arrays is defined element-wise and require \lstinline!size(a)=size(b)! and a
numeric type for \lstinline!a! and \lstinline!b!. Unary plus and minus are defined element-wise.
Addition a+b of string scalars, vectors, matrices, and arrays is defined
as element-wise string concatenation of corresponding elements from \lstinline!a!
and \lstinline!b!, and require \lstinline!size(a)=size(b)!.

\begin{longtable}[]{|l|l|l|l|}
\caption{Array addition, subtraction, and string concatenation.}\\
\hline
\tablehead{Type of \lstinline!a!} & \tablehead{Type of \lstinline!b!} & \tablehead{Result of \lstinline!a! +/- \lstinline!b!} &
\tablehead{Operation \lstinline!c := a +/- b!} (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & Scalar & \lstinline!c := a +/- b!\\ \hline
Vector{[}n{]} & Vector{[}n{]} & Vector{[}n{]} & c{[}j{]} := a{[}j{]} +/- b{[}j{]}\\ \hline
Matrix{[}n, m{]} & Matrix{[}n, m{]} & Matrix{[}n, m{]} & c{[}j, k{]} := a{[}j, k{]} +/- b{[}j, k{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c {[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]} +/- b{[}j, k, \ldots{}{]}\\ \hline
\end{longtable}

Element-wise addition \lstinline!a .+ b! and subtraction \lstinline!a .- b! of numeric scalars, vectors, matrices or arrays \lstinline!a! and \lstinline!b! requires a
numeric type class for \lstinline!a! and \lstinline!b! and either \lstinline!size(a) = size(b)! or scalar \lstinline!a! or scalar \lstinline!b!.  Element-wise addition
\lstinline!a .+ b! of string scalars, vectors, matrices, and arrays is defined as element-wise string concatenation of corresponding elements from \lstinline!a! and
\lstinline!b!, and require either \lstinline!size(a) = size(b)! or scalar \lstinline!a! or scalar \lstinline!b!.

\begin{longtable}[]{|l|l|l|l|}
\caption{Array element-wise addition, subtraction, and string concatenation.}\\
\hline
\tablehead{Type of \lstinline!a!} & \tablehead{Type of \lstinline!b!} & \tablehead{Result of a} \lstinline!.+/.-! \tablehead{b}
& \tablehead{Operation \lstinline!c := a .+/.- b!} (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & Scalar & \lstinline!c := a +/- b!\\ \hline
Scalar & Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a +/- b{[}j, k, \ldots{}{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Scalar & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a{[}j, k, \ldots{}{]} +/- b\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & Array{[}n, m,
\ldots{}{]} & c {[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]} +/- b{[}j,
k, \ldots{}{]}\\ \hline
\end{longtable}

\begin{longtable}[]{|l|l|l|}
\caption{Unary operators.  The element-wise (\lstinline!.+!, \lstinline!.-!) and normal (\lstinline!+!, \lstinline!-!) operators give the same results.}\\
\hline
\tablehead{Type of \lstinline!a!} & \tablehead{Result of} \lstinline!+/-! \tablehead{a} & \tablehead{Operation \lstinline!c := +/- a!} (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & \lstinline!c := +/- a!\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c{[}j, k, \ldots{}{]} := +/-a{[}j, k, \ldots{}{]}\\ \hline
\end{longtable}

\subsection{Array Element-wise Multiplication}\doublelabel{array-element-wise-multiplication}

Scalar multiplication \lstinline!s*a! or \lstinline!a*s! with numeric scalar s and numeric
scalar, vector, matrix or array \lstinline!a! is defined element-wise:
\begin{longtable}[]{|l|l|l|l|}
\caption{Scalar and scalar to array multiplication of numeric elements.}\\
\hline
\tablehead{Type of \lstinline!s!} & \tablehead{Type of \lstinline!a!} & \tablehead{Type of \lstinline!s * a! and \lstinline!a * s!} &
\tablehead{Operation \lstinline!c := s * a! or \lstinline!c := a * s!} (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & Scalar & \lstinline!c := s * a!\\ \hline
Scalar & Vector {[}n{]} & Vector {[}n{]} & c{[}j{]} := s * a{[}j{]}\\ \hline
Scalar & Matrix {[}n, m{]} & Matrix {[}n, m{]} & c{[}j, k{]} := s * a{[}j, k{]}\\ \hline
Scalar & Array{[}n, m, ...{]} & Array {[}n, m, ...{]} & c{[}j, k, ...{]} := s * a{[}j, k, ...{]}\\ \hline
\label{tab:product}
\end{longtable}

Element-wise multiplication \lstinline!a .* b! of numeric scalars, vectors, matrices or arrays \lstinline!a! and \lstinline!b! requires a numeric type class
for \lstinline!a! and \lstinline!b! and either \lstinline!size(a) = size(b)! or scalar \lstinline!a! or scalar \lstinline!b!.

\begin{longtable}[]{|l|l|l|l|}
\caption{Array element-wise multiplication.}\\
\hline
\tablehead{Type of \lstinline!a!} & \tablehead{Type of \lstinline!b!} & \tablehead{Type of \lstinline!a .* b!} &
\tablehead{Operation} \lstinline!c := a .* b! (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & Scalar & \lstinline!c := a * b!\\ \hline
Scalar & Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a* b{[}j, k, \ldots{}{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Scalar & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a{[}j, k, \ldots{}{]}* b\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, ...{]} & Array {[}n, m, ...{]}
& c{[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]}* b{[}j, k,
\ldots{}{]}\\ \hline
\end{longtable}

\subsection{Matrix and Vector Multiplication of Numeric Arrays}\doublelabel{matrix-and-vector-multiplication-of-numeric-arrays}

Multiplication \lstinline!a * b! of numeric vectors and matrices is defined only for the following combinations:
\begin{longtable}[]{|l|l|l|l|}
\caption{Matrix and vector multiplication of arrays with numeric elements.}\\
\hline
\tablehead{Type of \lstinline!a!} & \tablehead{Type of \lstinline!b!} & \tablehead{Type of \lstinline!a * b!} &
\tablehead{Operation \lstinline!c := a * b!}\\ \hline
\endhead
Vector {[}n{]} & Vector {[}n{]} & Scalar & c := $\textrm{sum}_k$(a{[}k{]}*b{[}k{]}), k=1:n\\ \hline
Vector {[}n{]} & Matrix {[}n, m{]} & Vector {[}m{]} & c{[}j{]} := $\textrm{sum}_k$(a{[}k{]}*b{[}k, j{]}), j=1:m, k=1:n\\ \hline
Matrix {[}n, m{]} & Vector {[}m{]} & Vector {[}n{]} & c{[}j{]} := $\textrm{sum}_k$(a{[}j, k{]}*b{[}k{]})\\ \hline
Matrix {[}n, m{]} & Matrix {[}m, p{]} & Matrix {[}n, p{]} & c{[}i, j{]} = $\textrm{sum}_k$(a{[}i, k{]}*b{[}k, j{]}), i=1:n, k=1:m, j=1:p\\ \hline
\end{longtable}

\begin{example}
\begin{lstlisting}[language=modelica]
Real A[3, 3], x[3], b[3], v[3];
A * x = b;
x * A = b; // same as transpose([x])*A*b
[v] * transpose([v]) // outer product
v * A * v // scalar
tranpose([v]) * A * v // vector with one element
\end{lstlisting}
\end{example}

\subsection{Division of Scalars or Numeric Arrays by Numeric Scalars}\doublelabel{division-of-scalars-or-numeric-arrays-by-numeric-scalars}

Division \lstinline!a / s! of numeric scalars, vectors, matrices, or arrays \lstinline!a! and numeric scalars \lstinline!s! is defined element-wise.
The result is always of \lstinline!Real! type.  In order to get integer division with truncation, use the function \lstinline!div!.

\begin{longtable}[]{|l|l|l|l|}
\caption{Division of scalars and arrays by numeric elements.}\\
\hline \endhead
\tablehead{Type of \lstinline!a!} & \tablehead{Type of \lstinline!s!} & \tablehead{Result of \lstinline!a / s!} &
\tablehead{Operation \lstinline!c := a / s!} (j=1:n, k=1:m)\\ \hline
Scalar & Scalar & Scalar & \lstinline!c := a / s!\\ \hline
Vector{[}n{]} & Scalar & Vector{[}n{]} & c{[}k{]} := a{[}k{]} /
s\\ \hline
Matrix{[}n, m{]} & Scalar & Matrix{[}n, m{]} & c{[}j, k{]} := a{[}j,
k{]} / s\\ \hline
Array{[}n, m, \ldots{}{]} & Scalar & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a{[}j, k, \ldots{}{]} / s\\ \hline
\end{longtable}

\subsection{Array Element-wise Division}\doublelabel{array-element-wise-division}

Element-wise division \lstinline!a ./ b! of numeric scalars, vectors, matrices or arrays \lstinline!a! and \lstinline!b! requires a numeric type class for \lstinline!a! and \lstinline!b!
and either \lstinline!size(a) = size(b)! or scalar \lstinline!a! or scalar \lstinline!b!.  The result is always of \lstinline!Real! type.  In order to get integer division with truncation,
use the function \lstinline!div!.

\begin{longtable}[]{|l|l|l|l|}
\caption{Element-wise division of arrays.}\\
\hline \endhead
\tablehead{Type of \lstinline!a!} & \tablehead{Type of \lstinline!b!} & \tablehead{Type of \lstinline!a ./ b!} &
\tablehead{Operation} \lstinline!c := a ./ b! (j=1:n, k=1:m)\\ \hline
Scalar & Scalar & Scalar & \lstinline!c := a / b!\\ \hline
Scalar & Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a / b{[}j, k, \ldots{}{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Scalar & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a{[}j, k, \ldots{}{]} / b\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, ...{]} & Array {[}n, m, ...{]}
& c{[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]} / b{[}j, k,
\ldots{}{]}\\ \hline
\end{longtable}

\begin{example}
Element-wise division by scalar (\lstinline!./!) and division by scalar (\lstinline!/!) are identical: \lstinline!a ./ s = a / s!:
\begin{lstlisting}[language=modelica]
2./[1, 2; 3, 4]  // error; same as  2.0 / [1, 2; 3, 4]
2 ./[1, 2; 3, 4] // fine; element-wise division
\end{lstlisting}
This is a consequence of the parsing rules, since `\lstinline!2.!' is a lexical unit.  Using a space after the literal solves the problem.
\end{example}

\subsection{Exponentiation of Scalars of Numeric Elements}\doublelabel{exponentiation-of-scalars-of-numeric-elements}

Exponentiation \lstinline!a ^ b! is defined as \lstinline[language=C]!pow(double a, double b)! in the ANSI~C library if both \lstinline!a! and \lstinline!b! are
\lstinline!Real! scalars. A \lstinline!Real! scalar value is returned.  If \lstinline!a! or \lstinline!b! are \lstinline!Integer! scalars, they are
automatically promoted to \lstinline!Real!.  Consequences of exceptional situations, such as ($\text{\lstinline!a!} = 0.0$ and $\text{\lstinline!b!} \leq 0.0$,
$\text{\lstinline!a!} < 0$ and \lstinline!b! is not an integer) or overflow are undefined.

Element-wise exponentiation \lstinline!a .^ b! of numeric scalars, vectors, matrices, or arrays \lstinline!a! and \lstinline!b! requires a numeric type class for
\lstinline!a! and \lstinline!b! and either \lstinline!size(a) = size(b)! or scalar \lstinline!a! or scalar \lstinline!b!.

\begin{longtable}[]{|l|l|l|l|}
\caption{Element-wise exponentiation of arrays.}\\
\hline
\tablehead{Type of \lstinline!a!} & \tablehead{Type of \lstinline!b!} & \tablehead{Type of \lstinline!a .^ b!} &
\tablehead{Operation} \lstinline!c := a .^ b! (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & Scalar & \lstinline!c := a ^ b!\\ \hline
Scalar & Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c{[}j, k, \ldots{}{]} := a \^{} b{[}j, k, \ldots{}{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Scalar & Array{[}n, m, \ldots{}{]} & c{[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]} \^{} b\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, ...{]} & Array {[}n, m, ...{]} & c{[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]} \^{} b{[}j, k, \ldots{}{]}\\ \hline
\end{longtable}

\begin{example}
\begin{lstlisting}[language=modelica]
2.^[1, 2; 3, 4]  // error; same as 2.0 ^ [1, 2; 3, 4]
2 .^[1, 2; 3, 4] // fine; element-wise exponentiation
\end{lstlisting}
This is a consequence of the parsing rules, i.e.\ since \lstinline!2.! could be a lexical unit it seen as a lexical unit; using a space after
literals solves the problem.
\end{example}

\subsection{Scalar Exponentiation of Square Matrices of Numeric Elements}\doublelabel{scalar-exponentiation-of-square-matrices-of-numeric-elements}

Exponentiation \lstinline!a ^ s! is defined if \lstinline!a! is a square numeric matrix and \lstinline!s! is a scalar as a subtype of \lstinline!Integer!
with $\text{\lstinline!s!} \geq 0$.  The exponentiation is done by repeated multiplication, e.g.:
\begin{lstlisting}[language=modelica]
a^3 = a * a * a;
a^0 = identity(size(a, 1));
assert(size(a, 1) == size(a, 2), "Matrix must be square");
a^1 = a;
\end{lstlisting}

\begin{nonnormative}
Non-\lstinline!Integer! exponents are forbidden, because this would require
computing the eigenvalues and eigenvectors of \lstinline!a! and this is no
longer an elementary operation.
\end{nonnormative}

\subsection{Slice Operation}\doublelabel{slice-operation}

The following holds for slice operations:
\begin{itemize}
\item
  If \lstinline!a! is an array containing scalar components and \lstinline!m! is a component of those components, the expression \lstinline!a.m! is interpreted as a
  slice operation.  It returns the array of components \lstinline!{a[1].m, $\ldots$}!.
\item
  If \lstinline!m! is also an array component, the slice operation is valid only if \lstinline!size(a[1].m)! = \lstinline!size(a[2].m)! = \ldots
\item
  The slicing operation can be combined with indexing, e.g.\ \lstinline!a.m[1]!.  It returns the array of components \lstinline!{a[1].m[1], a[2].m[1], $\ldots$}!,
  and does not require that \lstinline!size(a[1].m) = size(a[2].m)!.  The number of subscripts on \lstinline!m! must not be greater than the number of array dimension
  for \lstinline!m! (the number can be smaller, in which case the missing trailing indices are assumed to be `\lstinline!:!'), and is only valid if
  \lstinline!size(a[1].m[$\ldots$]) = size(a[2].m[$\ldots$])!.
\end{itemize}

\begin{example}
The size-restriction on the operand is only applicable if the indexing on the second operand uses vectors or colon as in the example:
\begin{lstlisting}[language=modelica]
  constant Integer m=3;
  Modelica.Blocks.Continuous.LowpassButterworth tf[m](n=2:(m+1));
  Real y[m];
  Real y2,y3;
equation
  // Extract the x1 slice even though different x1's have different lengths
  y = tf.x1[1] ; // Legal, = {tf[1].x1[1], tf[2].x1[1], $\ldots$ tf[m].x1[1]};
  y2 = sum(tf.x1[:]); // Illegal to extract all elements since they have
    // different lengths. Does not satisfy:
    // size(tf[1].x1[:]) = size(tf[2].x1[:]) = $\ldots$ = size(tf[m].x1[:])
  y3 = sum(tf.x1[1:2]); // Legal.
    // Since x1 has at least 2 elements in all tf, and
    // size(tf[1].x1[1:2]) = size(tf[2].x1[1:2]) = $\ldots$ = size(tf[m].x1[1:2]) = {2}
\end{lstlisting}
In this example the different \lstinline!x1! vectors have different lengths,
but it is still possible to perform some operations on them.
\end{example}

\subsection{Relational Operators}\doublelabel{relational-operators}

Relational operators \lstinline!<!, \lstinline!<=!, \lstinline!>!,
\lstinline!>=!, \lstinline!==!, \lstinline!<>!, are only defined for
scalar operands of simple types, not for arrays, see \autoref{equality-relational-and-logical-operators}

\subsection{Boolean Operators}\doublelabel{boolean-operators}

The operators \lstinline!and! and \lstinline!or! take expressions of \lstinline!Boolean! type, which are either scalars or arrays of matching dimensions.  The operator \lstinline!not!
takes an expression of \lstinline!Boolean! type, which is either scalar or an array.  The result is the element-wise logical operation.  For short-circuit evaluation of \lstinline!and!
and \lstinline!or!, see \autoref{evaluation-order}.

\subsection{Vectorized Calls of Functions}\doublelabel{vectorized-calls-of-functions}

See \autoref{scalar-functions-applied-to-array-arguments}.

\subsection{Standard Type Coercion}\doublelabel{standard-type-coercion}
In all contexts that require an expression which is a subtype of \lstinline!Real!, an expression which is a subtype of \lstinline!Integer! can also be used;
the \lstinline!Integer! expression is automatically converted to \lstinline!Real!.

This also applies to arrays of \lstinline!Real!, and for fields of record expressions.  There is no similar rule for sub-typing.

\begin{example}
\begin{lstlisting}[language=modelica]
record RealR
  Real x,y;
end RealR;
record IntegerR
  Integer x,y;
end IntegerR;
parameter Integer a = 1;
Real y(start=a);           // Ok, a is automatically coerced to Real
RealR r1 = IntegerR(a, a); // Ok, record is automatically coerced
RealR r2 = RealR(a, a);    // Ok, a is automatically coerced to Real
\end{lstlisting}
\end{example}

\section{Empty Arrays}\doublelabel{empty-arrays}

Arrays may have dimension sizes of 0.  For example:
\begin{lstlisting}[language=modelica]
Real x[0]; // an empty vector
Real A[0, 3], B[5, 0], C[0, 0]; // empty matrices
\end{lstlisting}

Empty matrices can be constructed with the fill function.  For example:
\begin{lstlisting}[language=modelica]
Real A[:,:] = fill(0.0, 0, 1); // a Real 0 x 1 matrix
Boolean B[:, :, :] = fill(false, 0, 1, 0); // a Boolean 0 x 1 x 0 matrix
\end{lstlisting}

It is not possible to access an element of an empty matrix, e.g.\ \lstinline!v[j, k]! cannot be evaluated if \lstinline!v = []! because the assertion fails
that the index must be bigger than one.

Size-requirements of operations, such as \lstinline!+!, \lstinline!-!, must also be fulfilled if a dimension is zero.  For example:
\begin{lstlisting}[language=modelica]
Real[3, 0] A, B;
Real[0, 0] C;
A + B // fine, result is an empty matrix
A + C // error, sizes do not agree
\end{lstlisting}

Multiplication of two empty matrices results in a zero matrix of corresponding numeric type if the result matrix has no zero dimension sizes, i.e.,
\begin{lstlisting}[language=modelica]
Real[0, m] * Real[m, n] = Real[0, n] (empty matrix)
Real[m, n] * Real[n, 0] = Real[m, 0] (empty matrix)
Real[m, 0] * Real[0, n] = fill(0.0, m, n) (non-empty matrix, with zero elements).
\end{lstlisting}

\begin{example}
\begin{lstlisting}[language=modelica]
Real u[p], x[n], y[q], A[n, n], B[n, p], C[q, n], D[q, p];
der(x) = A * x + B * u
y = C * x + D * u
\end{lstlisting}
Assume $\text{\lstinline!n!} = 0$, $\text{\lstinline!p!} > 0$, $\text{\lstinline!q!} > 0$: Results in \lstinline!y = D * u!.
\end{example}
