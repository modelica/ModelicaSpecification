\chapter{Arrays}\doublelabel{arrays}

An array can be regarded as a collection of values, all of the same
type. Modelica arrays can be multidimensional and are ``rectangular,''
which in the case of matrices has the consequence that all rows in a
matrix have equal length, and all columns have equal length.

Each array has a certain dimensionality, i.e., number of dimensions. The
degenerate case of a scalar variable is not really an array, but can be
regarded as an array with zero dimensions. Vectors have one dimension,
matrices have two dimensions, etc. {[}\emph{So-called row vectors and
column vectors do not exist in Modelica and cannot be distinguished
since vectors have only one dimension. If distinguishing these is
desired, row matrices and column matrices are available, being the
corresponding two-dimensional entities. However, in practice this is
seldom needed since the usual matrix arithmetic and linear algebra
operations have been defined to give the expected behavior when
operating on Modelica vectors and matrices.}{]}

Modelica is a strongly typed language, which also applies to array
types. The number of dimensions of an array is fixed and cannot be
changed at run-time {[}\emph{in order to permit strong type checking and
efficient implementation.}{]} However, the sizes of array dimensions can
be computed at run-time, {[}\emph{allowing fairly generic array
manipulation code to be written as well as interfacing to standard
numeric libraries implemented in other programming languages}.{]}

An array is allocated by declaring an array variable or calling an array
constructor. Elements of an array can be indexed by \lstinline!Integer!, \lstinline!Boolean!, or
\lstinline!enumeration! values.

\section{Array Declarations}\doublelabel{array-declarations}

The Modelica type system includes scalar number, vector, matrix (number
of dimensions, ndim=2), and arrays of more than two dimensions.
{[}\emph{There is no distinguishing between a row and column vector}.{]}

The following table shows the two possible forms of declarations and
defines the terminology. C is a placeholder for any class, including the
built-in type classes Real, Integer, Boolean, String, and enumeration
types. The type of a dimension upper bound expression, e.g. n, m, p,...
in the table below, need to be a subtype of Integer or EB for a class EB
that is an enumeration type or subtype of the Boolean type. Colon (:)
indicates that the dimension upper bound is unknown and is a subtype of
Integer.

Upper and lower array dimension index bounds are described in \autoref{array-dimension-lower-and-upper-index-bounds}.

An array indexed by Boolean or enumeration type can only be used in the
following ways:

\begin{itemize}
\item
  Subscripted using expressions of the appropriate type (i.e. Boolean or
  the enumerated type)
\item
  Binding equations of the form \lstinline!x1 = x2! as well as declaration
  assignments of the form \lstinline!x1 := x2! are allowed for arrays independent of
  whether the index types of dimensions are subtypes of Integer,
  Boolean, or enumeration types.
\end{itemize}

% IMPROVETOP
\begin{longtable}{|l|l|l|l|p{4cm}|}
\caption{General forms of declaration of arrays.}\\
\hline
\emph{Modelica form 1} & \emph{Modelica form 2} & \emph{\# dimensions} & \emph{Designation} & \emph{Explanation}\\ \hline
\endhead
C x; & C x; & 0 & Scalar & Scalar\\ \hline
C{[}n{]} x; & C x{[}n{]}; & 1 & Vector & n -- Vector\\ \hline
C{[}EB{]} x; & C x{[}EB{]} & 1 & Vector & Vector index by enumeration or
Boolean type EB\\ \hline
C{[}n, m{]} x; & C x{[}n, m{]}; & 2 & Matrix & n x m
Matrix\\ \hline
C{[}$n_1$, $n_{2}$,\ldots{},$n_k${]} x; & C x{[}$n_1$, $n_2$,\ldots{},$n_k${]}; & k & Array & Array with k dimensions
(k\textgreater{}=0).\\ \hline
\end{longtable}

{[}\emph{The number of dimensions and the dimensions sizes are part of
the type, and shall be checked for example at redeclarations.
Declaration form 1 displays clearly the type of an array, whereas
declaration form 2 is the traditional way of array declarations in
languages such as Fortran, C, C++.}

\begin{lstlisting}[language=modelica]
  Real[:] v1, v2 // vectors v1 and v2 have unknown sizes. The actual sizes may be different.
\end{lstlisting}

\emph{It is possible to mix the two declaration forms although it might
be confusing.}

\begin{lstlisting}[language=modelica]
  Real[3,2] x[4,5]; // x has type Real[4,5,3,2];
\end{lstlisting}
\emph{The reason for this order is given by examples such as:}

\begin{lstlisting}[language=modelica]
  type R3=Real[3];
  R3 a;
  R3 b[1]={a};
  Real[3] c[1]=b;
\end{lstlisting}
\emph{Using a type for ``a'' and ``b'' in this way is normal, and
substituting a type by its definition allow ``c''.}

\emph{A vector y indexed by enumeration values}

\begin{lstlisting}[language=modelica]
  type TwoEnums = enumeration(one,two);
  Real[TwoEnums] y;
\end{lstlisting}
{]}

Zero-valued dimensions are allowed, so: \lstinline!C x[0];! declares an empty
  vector and: \lstinline!C x[0,3]!; an empty matrix.
{[}\emph{Special cases}:

\begin{longtable}{|l|l|l|l|p{3cm}|}
\caption{Declaration of arrays as 1-vectors, row-vectors, or
column-vectors of arrays.}\\
\hline
\emph{Modelica form 1} & \emph{Modelica form 2} & \emph{\# dimensions} &
\emph{Designation} & \emph{Explanation}\\ \hline
\endhead
C{[}1{]} x; & C x{[}1{]};  & 1 & Vector & 1 -- Vector, representing a scalar\\ \hline
C{[}1,1{]} x; & C x{[}1, 1{]}; & 2 & Matrix & 1 x 1 -- Matrix, representing a scalar\\ \hline
C{[}n,1{]} x; & C x{[}n, 1{]}; & 2 & Matrix & n x 1 -- Matrix, representing a column\\ \hline
C{[}1,n{]} x; & C x{[}1, n{]}; & 2 & Matrix & 1 x n -- Matrix, representing a row\\ \hline
\end{longtable}

{]}

The type of an array of array is the multidimensional array which is
constructed by taking the first dimensions from the component
declaration and subsequent dimensions from the maximally expanded
component type. A type is maximally expanded, if it is either one of the
built-in types (Real, Integer, Boolean, String, enumeration type) or it
is not a type class. Before operator overloading is applied, a type
class of a variable is maximally expanded.

{[}\emph{Example}:

\begin{lstlisting}[language=modelica]
  type Voltage = Real(unit = "V");
  type Current = Real(unit = "A");
  connector Pin
    Voltage v; // type class of v = Voltage, type of v = Real
    flow Current i; // type class of i = Current, type of i = Real
  end Pin;
  type MultiPin = Pin[5];
  MultiPin[4] p; // type class of p is MultiPin, type of p is Pin[4,5];
  type Point = Real[3];
  Point p1[10];
  Real p2[10,3];
\end{lstlisting}
  The components p1 and p2 have identical types.
\begin{lstlisting}[language=modelica]
  p2[5] = p1[2]+ p2[4]; // equivalent to p2[5,:] = p1[2,:] + p2[4,:]
  Real r[3] = p1[2]; // equivalent to r[3] = p1[2,:]
\end{lstlisting}
{]}

{[}\emph{Automatic assertions at simulation time}:

\emph{Let A be a declared array and i be the declared maximum dimension
size of the} \lstinline!di!\emph{-dimension, then an assert statement}
\lstinline!assert(i>=0, ...)! \emph{is generated provided this
assertion cannot be checked at compile time. It is a quality of
implementation issue to generate a good error message if the assertion
fails.}

\emph{Let A be a declared array and i be an index accessing an index of
the} \lstinline!di!\emph{-dimension. Then for every such index-access an assert
statement} \lstinline!assert(i>=1 and i<=size(A,di), ...!
\emph{) is generated, provided this assertion cannot be checked at
compile time.}

\emph{For efficiency reasons, these implicit assert statement may be
optionally suppressed.}{]}

\subsection{Array Dimension Lower and Upper Index Bounds}\doublelabel{array-dimension-lower-and-upper-index-bounds}

The lower and upper index bounds for a dimension of an array indexed by
\lstinline!Integer!, \lstinline!Boolean!, or \lstinline!enumeration! values are as follows:

\begin{itemize}
\item
  An array dimension indexed by integers has a lower bound of 1 and an
  upper bound being the size of the dimension.
\item
  An array dimension indexed by \lstinline!Boolean! values has the lower bound \lstinline!false!
  and the upper bound \lstinline!true!.
\item
  An array dimension indexed by \lstinline!enumeration! values of the type
  \lstinline!E=enumeration!(\lstinline!e1!, \lstinline!e2!, ..., \lstinline!en!) has the lower bound \lstinline!E.e1! and the upper
  bound \lstinline!E.en!.
\end{itemize}

\section{Flexible Array Sizes}\doublelabel{flexible-array-sizes}

Regarding flexible array sizes and resizing of arrays in functions, see
\autoref{flexible-array-sizes-and-resizing-of-arrays-in-functions}.

\section{Built-in Array Functions}\doublelabel{built-in-array-functions}

Modelica provides a number of built-in functions that are applicable to
arrays.

The following \lstinline!promote! function cannot be used in Modelica, but is
utilized below to define other array operators and functions:

\begin{longtable}[]{|l|p{9cm}|}
\caption{Promote function (cannot be used in Modelica).}\\
\hline \endhead
promote(A,n) & Fills dimensions of size 1 from the right to array A upto
dimension n, where "n \textgreater{}= ndims(A)" is required. Let C =
promote(A,n), with nA=ndims(A), then ndims(C) = n, size(C,j) = size(A,j)
for 1 \textless{}= j \textless{}= nA, size(C,j) = 1 for nA+1 <= j <= n, C{[}i\_1, ..., i\_nA, 1, ..., 1{]} =A{[}i\_1, ..., i\_nA{]}\\ \hline
\end{longtable}

{[}\emph{The function} \lstinline!promote! \emph{cannot be used in Modelica, because
the number of dimensions of the returned array cannot be determined at
compile time if n is a variable. Below,} \lstinline!promote! \emph{is only used for
constant n}.

\emph{Some examples of using the functions defined in the following
\autoref{array-dimension-and-size-functions} to \autoref{matrix-and-vector-algebra-functions}}:

\begin{lstlisting}[language=modelica]
  Real x[4,1,6];
  size(x,1) = 4;
  size(x); // vector with elements 4, 1, 6
  size(2*x+x ) = size(x);
  Real[3] v1 = fill(1.0, 3);
  Real[3,1] m = matrix(v1);
  Real[3] v2 = vector(m);
  Boolean check[3,4] = fill(true, 3, 4);
\end{lstlisting}
{]}

\subsection{Array Dimension and Size Functions}\doublelabel{array-dimension-and-size-functions}

The following built-in functions for array dimensions and dimension
sizes are provided:

\begin{longtable}[]{|l|p{9cm}|}
\caption{Built-in array dimension and size functions.}\\
\hline
\emph{Modelica} & \emph{Explanation}\\ \hline
\endhead
\lstinline!ndims(A)! &
Returns the number of dimensions k of expression A, with k
\textgreater{}= 0.
\\ \hline
\lstinline!size(A,i)! &
Returns the size of dimension i of array expression A where i shall be
\textgreater{} 0 and \textless{}= ndims(A).\\ \hline
\lstinline!size(A)! &
Returns a vector of length ndims(A) containing the dimension sizes of
A.\\ \hline
\end{longtable}

\subsection{Dimensionality Conversion Functions}\doublelabel{dimensionality-conversion-functions}

The following built-in conversion functions convert scalars, vectors,
and arrays to scalars, vectors, or matrices by adding or removing
1-sized dimensions.

\begin{longtable}[]{|l|p{9cm}|}
\caption{Built-in dimensionality conversion functions.}\\
\hline
\emph{Modelica} & \emph{Explanation}\\ \hline
\endhead
\lstinline!scalar(A)! & Returns the single element of array A. size(A,i) = 1 is required for 1
\textless{}= i \textless{}= ndims(A).\\ \hline
\lstinline!vector(A)!
&
Returns a 1-vector, if A is a scalar and otherwise returns a vector
containing all the elements of the array, provided there is at most one
dimension size \textgreater{} 1.\\ \hline
\lstinline!matrix(A)!
&
Returns promote(A,2), if A is a scalar or vector and otherwise returns
the elements of the first two dimensions as a matrix. size(A,i) = 1 is
required for 2 \textless{} i \textless{}= ndims(A).\\ \hline
\end{longtable}

\subsection{Specialized Array Constructor Functions}\doublelabel{specialized-array-constructor-functions}

An array constructor function constructs and returns an array computed
from its arguments. Most of the constructor functions in the table below
construct an array by filling in values according to a certain pattern,
in several cases just giving all array elements the same value. The
general array constructor with syntax \lstinline!array! (\ldots{}) or \{\ldots{}\}
is described in \autoref{vector-matrix-and-array-constructors}.

\begin{longtable}[]{|l|p{11cm}|}
\caption{Specialized array constructor functions.}\\
\hline
\emph{Modelica} & \emph{Explanation}\\ \hline
\endhead
\lstinline!identity(n)!
&
Returns the n x n Integer identity matrix, with ones on the diagonal and
zeros at the other places.\\ \hline
\lstinline!diagonal(v)!
&
Returns a square matrix with the elements of vector v on the diagonal
and all other elements zero.\\ \hline
\texttt{zeros(n\textsubscript 1,n\textsubscript 2,n\textsubscript 3,...)} &
Returns the $n_1$ x $n_2$ x $n_3$ x ... Integer array with all elements equal to zero ($n_i$
\textgreater{}= 0). The function need one or more arguments, that is
zeros() is not legal.\\ \hline
\texttt{ones(n\textsubscript 1,n\textsubscript 2,n\textsubscript 3,...)} &
Return the $n_1$ x $n_2$ x $n_3$ x ... Integer array with all elements equal to one ($n_i$
\textgreater{}=0 ). The function need one or more arguments, that is
ones() is not legal.\\ \hline
\texttt{fill(s,n\textsubscript 1,n\textsubscript 2,n\textsubscript 3,...)} &
Returns the $n_1$ x $n_2$ x $n_3$ x ... array with all elements equal to scalar or array expression s
($n_i$ \textgreater{}= 0). The returned array has the same
type as s.
Recursive definition:
\lstinline!fill!(s,$n_1$,$n_2$,$n_3$,...) =
\lstinline!fill!(\lstinline!fill!(s,$n_2$,$n_3$, ...),
$n_1$,); \lstinline!fill!(s,n)=\{s,s,\ldots{}, s\}

The function needs two or more arguments; that is fill(s) is not
legal.\\ \hline
\lstinline!linspace(x1,x2,n)!
&
Returns a Real vector with n equally spaced elements, such that
v=\lstinline!linspace!(x1,x2,n),

\lstinline!v[i] = x1 + (x2-x1)*(i-1)/(n-1) for 1 <= i <= n!.
It is required that n \textgreater{}= 2. The arguments x1 and x2 shall
be numeric scalar expressions.\\ \hline
\end{longtable}

\subsection{Reduction Functions and Operators}\doublelabel{reduction-functions-and-operators}

A reduction function ``reduces'' an array (or several scalars) to one
value (normally a scalar - but the sum reduction function may give an
array as result and also be applied to an operator record). Note that
none of these operators (particularly min and max) generate events
themselves (but arguments could generate events). The restriction on the
type of the input in \autoref{reduction-expressions} for reduction expressions also
apply to the array elements/scalar inputs for the reduction operator
with the same name.

The sum reduction function (both variants) may be applied to an operator
record, provided that the operator record defines '0' and '+'. It is
then assumed to form an additive group.

The following reduction functions are available:

\begin{longtable}{|p{4.1cm}|p{10.1cm}|}
\caption{Array reduction functions and operators.}\\
\hline
\emph{Modelica} & \emph{Explanation}\\ \hline
\endhead
\lstinline!min(A)!
&
Returns the least element of array expression A; as defined by
\textless{}.\\ \hline
\lstinline!min(x,y)!
&
Returns the least element of the scalars x and y; as defined by
\textless{}.\\ \hline
\begin{tabular}{@{}p{4cm}@{}}
\lstinline!min(e(i, ..., j)!\\
\lstinline! for i in  u,!\\
\lstinline!   ...,  j in  v)!
\end{tabular}
&
\begin{tabular}{@{}p{10cm}@{}}
Also described in \autoref{reduction-expressions}\\
Returns the least value (as defined by \textless{}) of the scalar
expression e(i, ..., j) evaluated for all combinations of i in u, ..., j
in v:
\end{tabular}\\ \hline
\lstinline!max(A)!
&
Returns the greatest element of array expression A; as defined by
\textgreater{}.\\ \hline
\lstinline!max(x,y)!
&
Returns the greatest element of the scalars x and y; as defined by
\textgreater{}.\\ \hline
\begin{tabular}{@{}p{4cm}@{}}
\lstinline!max(e(i, ..., j)!\\
\lstinline! for i in  u,!\\
\lstinline!   ...,  j in  v)!
\end{tabular}
&
\begin{tabular}{@{}p{10cm}@{}}
Also described in \autoref{reduction-expressions}
Returns the greatest value (as defined by \textgreater{}) of the scalar
expression e(i, ..., j) evaluated for all combinations of i in u, ..., j
in v:
\end{tabular}\\ \hline
\lstinline!sum(A)!
&
\begin{tabular}{@{}p{10cm}@{}}
Returns the scalar sum of all the elements of array expression:\\
\lstinline!=sum(A[j,k,...]) for j,k,...!
\end{tabular}\\ \hline
\begin{tabular}{@{}p{5cm}@{}}
\lstinline!sum(e(i, ..., j)!\\
\lstinline! for i in  u,!\\
\lstinline!   ...,  j in  v)!
\end{tabular}
&
\begin{tabular}{@{}p{10cm}@{}}
Also described in \autoref{reduction-expressions}\\
Returns the sum of the expression e(i, ..., j) evaluated for all
combinations of i in u, ..., j in v: For \lstinline!Integer! indexing this is
  e(u{[}1{]},...
  ,v{[}1{]})+e(u{[}2{]},... ,v{[}1{]})+... +e(u{[}end{]},...
  ,v{[}1{]})+...+e(u{[}end{]},... ,v{[}end{]})
  For non-\lstinline!Integer! indexing this uses all valid indices instead of 1..\lstinline!end!.
  The type of sum(e(i, ..., j) for  i in u, ..., j
    in v) is the same as the type of e(i,...j).
\end{tabular}\\ \hline
\lstinline!product(A)!
&
\begin{tabular}{@{}p{10cm}@{}}
Returns the scalar product of all the elements of array expression A.\\
  \lstinline!=product(A[j,k,...] for j,k,...!
\end{tabular}\\ \hline
\begin{tabular}{@{}p{4cm}@{}}
\lstinline!product(e(i, ..., j)!\\
\lstinline! for i in  u,!\\
\lstinline!   ...,  j in  v)!
\end{tabular}
&
\begin{tabular}{@{}p{10cm}@{}}
Also described in \autoref{reduction-expressions}.\\
Returns the product of the scalar expression e(i, ..., j) evaluated for
all combinations of i in u, ..., j in v: For \lstinline!Integer! indexing this is
\begin{lstlisting}[language=modelica]
  e(u[1],...,v[1])*e(u[2],...,v[1])*...
  *(u[end],...,v[1])*...*e(u[end],...,v[end])
\end{lstlisting}
  For non-\lstinline!Integer! indexing this uses all valid indices instead of 1..\lstinline!end!.
  The type of product(e(i, ..., j) for  i in u, ..., j
    in v) is the same as the type of e(i,...j).
\end{tabular}
\\ \hline
\end{longtable}

\subsubsection{Reduction Expressions}\doublelabel{reduction-expressions}

An expression:
\begin{lstlisting}[language=grammar]
function-name "(" expression1 for iterators ")"
\end{lstlisting}

is a reduction-expression. The expressions in the iterators of a
reduction-expression shall be vector expressions. They are evaluated
once for each reduction-expression, and are evaluated in the scope
immediately enclosing the reduction-expression.

For an iterator:
\begin{lstlisting}[language=grammar]
IDENT in expression2
\end{lstlisting}

the loop-variable, \lstinline!IDENT!, is in scope inside \lstinline!expression1!. The
loop-variable may hide other variables, as in for-clauses. The result
depends on the \lstinline!function-name!, and currently the only legal
function-names are the built-in operators \lstinline!array!, \lstinline!sum!,
\lstinline!product!, \lstinline!min!, and
\lstinline!max!. For array, see \autoref{vector-matrix-and-array-constructors}. If \lstinline!function-name! is
\lstinline!sum!, \lstinline!product!, \lstinline!min!,
or \lstinline!max! the result is of the same type as \lstinline!expression1! and is constructed
by evaluating \lstinline!expression1! for each value of the loop-variable and
computing the \lstinline!sum!, \lstinline!product!, \lstinline!min!, or
\lstinline!max! of the computed elements. For
deduction of ranges, see \autoref{implicit-iteration-ranges}; and for using types as ranges
see \autoref{types-as-iteration-ranges}.

\begin{longtable}{|p{3cm}|p{5cm}|p{6cm}|}
\caption{Reduction expressions with iterators.}\\
\hline
\emph{Function-name} & \emph{Restriction on expression1} & \emph{Result if expression2 is empty}\\ \hline
\endhead
\lstinline!sum! & Integer or Real & \lstinline!zeros(...)!\\ \hline
\lstinline!product! & Scalar Integer or Real & \lstinline!1!\\ \hline
\lstinline!min! & Scalar enumeration, Boolean, Integer or Real &
\begin{tabular}{@{}p{6cm}@{}}
Greatest value of type\\( \lstinline!Modelica.Constants.inf! for Real)
\end{tabular}\\ \hline
\lstinline!max! & Scalar enumeration, Boolean, Integer or Real &
\begin{tabular}{@{}p{6cm}@{}}
Least value of type\\ ( \lstinline!-Modelica.Constants.inf! for Real)
\end{tabular}\\ \hline

\end{longtable}

{[}\emph{Example}:

% No frame since the math would break it.
\begin{lstlisting}[language=modelica, mathescape=true, frame=none]
  sum(i for  i in 1:10) // Gives $\sum_{i=1}^{10}i=$1+2+...+10=55
  // Read it as: compute the sum of i for i in the range 1 to 10.
  sum(i^2 for  i in {1,3,7,6}) // Gives $\sum_{i\in \begin{Bmatrix}1&3&7&6\end{Bmatrix}}i^2=$1+9+49+36=95
  {product(j for j in 1:i) for i in 0:4} // Gives {1,1,2,6,24}
  max(i^2 for  i in {3,7,6}) // Gives 49
\end{lstlisting}
{]}

\subsection{Matrix and Vector Algebra Functions}\doublelabel{matrix-and-vector-algebra-functions}

The following set of built-in matrix and vector algebra functions are
available. The function transpose can be applied to any matrix. The
functions outerProduct, symmetric, cross and skew require Real/Integer
vector(s) or matrix as input(s) and returns a Real vector or matrix:

\begin{longtable}[]{|p{3.5cm}|p{11.5cm}|}
\caption{Matrix and vector algebra functions.}\\
\hline
\emph{Modelica} & \emph{Explanation}\\ \hline
\endhead
\lstinline!transpose(A)!
& Permutes the first two dimensions of array A. It is an error, if array A
does not have at least 2 dimensions.\\ \hline
\lstinline!outerProduct(v1,v2)!
& Returns the outer product of vectors v1 and v2 ( = matrix(v1)*transpose(
matrix(v2) ) ).\\ \hline
\lstinline!symmetric(A)!
& Returns a matrix where the diagonal elements and the elements above the
diagonal are identical to the corresponding elements of matrix A and
where the elements below the diagonal are set equal to the elements
above the diagonal of A, i.e., \lstinline!B := symmetric(A) ->!
  \lstinline!B[i,j] := A[i,j], if i <= j, ! \lstinline! B[i,j] := A[j,i], if i > j!.\\ \hline
\lstinline!cross(x,y)!
& Returns the cross product of the 3-vectors x and y, i.e.
\lstinline!cross(x,y) = vector( [ x[2]*y[3]-x[3]*y[2];  x[3]*y[1]-x[1]*y[3]; x[1]*y[2]-x[2]*y[1]  ] );!\\ \hline
\lstinline!skew(x)!
& Returns the 3 x 3 skew symmetric matrix associated with a 3-vector,
  i.e., \lstinline!cross(x,y) = skew(x)*y; skew(x) = [0, -x[3], x[2]; x[3], 0, -x[1]; -x[2], x[1], 0];!\\ \hline
\end{longtable}

\section{Vector, Matrix and Array Constructors}\doublelabel{vector-matrix-and-array-constructors}

The constructor function \lstinline!array(A,B,C,...)! constructs an array from its
arguments according to the following rules:

\begin{itemize}
\item
  Size matching: All arguments must have the same sizes, i.e.,
  \lstinline!size(A)=size(B)=size(C)=!...
\item
  All arguments must be type compatible expressions (\autoref{type-compatible-expressions}) giving
  the type of the elements. The data type of the result array is the
  maximally expanded type of the arguments. Real and Integer subtypes
  can be mixed resulting in a Real result array where the Integer
  numbers have been transformed to Real numbers.
\item
  Each application of this constructor function adds a one-sized
  dimension to the left in the result compared to the dimensions of the
  argument arrays, i.e., \lstinline!ndims(array(A,B,C)) = ndims(A) + 1 = ndims(B) + 1, ...!
\item
  \lstinline!{A, B, C, ...}! is a shorthand notation for \lstinline!array(A, B, C, ...)!.
\item
  There must be at least one argument {[}\emph{i.e.,} \lstinline!array()! \emph{or}
  \lstinline!{}! \emph{is not defined}{]}.
\end{itemize}

{[}\emph{Examples}:
\begin{lstlisting}[language=modelica, escapechar=!]
  {1,2,3} !\emph{is a 3-vector of type Integer}.!
  {{11,12,13}, {21,22,23}} !\emph{is a 2x3 matrix of type Integer}!
  {{{1.0, 2.0, 3.0}}} !\emph{is a 1x1x3 array of type Real}.!

  Real[3] v = array(1, 2, 3.0);
  type Angle = Real(unit="rad");
  parameter Angle alpha = 2.0; // type of alpha is Real.
  // array(alpha, 2, 3.0) or {alpha, 2, 3.0} is a 3-vector of type Real.
  Angle[3] a = {1.0, alpha, 4}; // type of a is Real[3].
\end{lstlisting}
{]}

\subsection{Array Constructor with Iterators}\doublelabel{array-constructor-with-iterators}

An expression:
\begin{lstlisting}[language=grammar]
"{" expression for iterators "}"
\end{lstlisting}
or
\begin{lstlisting}[language=grammar]
array "(" expression for iterators ")"
\end{lstlisting}

is an array constructor with iterators. The expressions inside the
iterators of an array constructor shall be vector expressions. They are
evaluated once for each array constructor, and are evaluated in the
scope immediately enclosing the array constructor.

For an iterator:
\begin{lstlisting}[language=modelica]
IDENT in array_expression
\end{lstlisting}

the loop-variable, \lstinline!IDENT!, is in scope inside expression in the array
construction. The loop-variable may hide other variables, as in
for-clauses. The loop-variable has the same type as the type of the
elements of array\_expression; and can be simple type as well as a
record type. The loop-variable will have the same type for the entire
loop - i.e. for an array\_expression \{1,3.2\} the iterator will have
the type of the type-compatible expression (Real) for all iterations.
For deduction of ranges, see \autoref{implicit-iteration-ranges}; and for using types as
range see \autoref{types-as-iteration-ranges}.

\subsubsection{Array Constructor with One Iterator}\doublelabel{array-constructor-with-one-iterator}

If only one iterator is used, the result is a vector constructed by
evaluating expression for each value of the loop-variable and forming an
array of the result.

{[}\emph{Example}:
\begin{lstlisting}[language=modelica]
array(i for i in 1:10)
// Gives the vector 1:10={1,2,3,...,10}

{r for r in 1.0 : 1.5 : 5.5}
// Gives the vector 1.0:1.5:5.5={1.0, 2.5, 4.0, 5.5}

{i^2 for i in {1,3,7,6}}
// Gives the vector {1, 9, 49, 36}
\end{lstlisting}
\subsubsection{Array Constructor with Several Iterators}\doublelabel{array-constructor-with-several-iterators}

The notation with several iterators is a shorthand notation for nested
array constructors. The notation can be expanded into the usual form by
replacing each '\lstinline!,!' by '\lstinline!} for!' and prepending the array constructor with
a '\lstinline!{!'.

{[}\emph{Example}:

\begin{lstlisting}[language=modelica]
  Real hilb[:,:]= { 1/(i+j-1) for  i in 1:n, j in 1:n};
  Real hilb2[:,:]={{ 1/(i+j-1) for  j in 1:n} for i in 1:n};
\end{lstlisting}
\subsection{Array Concatenation}\doublelabel{array-concatenation}


The function \lstinline!cat(k,A,B,C,...)! concatenates arrays
\lstinline!A!,\lstinline!B!,\lstinline!C!,... along
dimension k according to the following rules:

\begin{itemize}
\item
  Arrays A, B, C, ... must have the same number of dimensions, i.e.,
  \lstinline!ndims(A)! = \lstinline!ndims(B)! = ...
\item
  Arrays A, B, C, ... must be type compatible expressions (\autoref{type-compatible-expressions})
  giving the type of the elements of the result. The maximally expanded
  types should be equivalent. Real and Integer subtypes can be mixed
  resulting in a Real result array where the Integer numbers have been
  transformed to Real numbers.
\item
  k has to characterize an existing dimension, i.e., 1 $<=$ k
  $<=$ \lstinline!ndims(A)! = \lstinline!ndims(B)! = \lstinline!ndims(C)!; k shall be a parameter expression of \lstinline!Integer! type.
\item
  Size matching: Arrays A, B, C, ... must have identical array sizes
  with the exception of the size of dimension k, i.e., \lstinline!size(A,j)! =
  \lstinline!size(B,j)!, for 1 $<=$  j $<=$  \lstinline!ndims(A)! and j
  $\neq$ k.
\end{itemize}

{[}\emph{Examples}:

\begin{lstlisting}[language=modelica]
  Real[2,3] r1 = cat(1, {{1.0, 2.0, 3}}, {{4, 5, 6}});
  Real[2,6] r2 = cat(2, r1, 2*r1);
\end{lstlisting}
{]}

Concatenation is formally defined according to:
\begin{lstlisting}[language=modelica, escapechar=!]
!Let! R = cat(k,A,B,C,...)!, and let! n = ndims(A) = ndims(B) = ndims(C) =
....!, then!
  size(R,k) = size(A,k) + size(B,k) + size(C,k) + ...
  size(R,j) = size(A,j) = size(B,j) = size(C,j) = ...., for 1 <=j <= n and j <> k.

  R[i_1, ..., i_k, ..., i_n] = A[i_1, ..., i_k, ..., i_n], for i_k <= size(A,k),
  R[i_1, ..., i_k, ..., i_n] = B[i_1, ..., i_k - size(A,i), ..., i_n], for i_k <= size(A,k) + size(B,k),
    ....
  where 1 <= i_j <= size(R,j) for 1 <= j <= n.
\end{lstlisting}


\subsubsection{Array Concatenation along First and Second Dimensions}\doublelabel{array-concatenation-along-first-and-second-dimensions}

For convenience, a special syntax is supported for the concatenation
along the first and second dimensions.

\begin{itemize}
\item
  \emph{Concatenation along first dimension}:\\
\lstinline![A; B; C; ...] = cat(1, promote(A,n), promote(B,n), promote(C,n),  ...)!
where \lstinline!n = max(2, ndims(A), ndims(B), ndims(C), ....)!. If necessary, 1-sized
  dimensions are added to the right of A, B, C before the operation is
  carried out, in order that the operands have the same number of
  dimensions which will be at least two.
\item
  \emph{Concatenation along second dimension}:\\
\lstinline![A, B, C, ...] = cat(2, promote(A,n), promote(B,n), promote(C,n), ...)!
where \lstinline!n = max(2, ndims(A), ndims(B), ndims(C), ....)!. If necessary, 1-sized
  dimensions are added to the right of A, B, C before the operation is
  carried out, especially that each operand has at least two dimensions.
\item
  The two forms can be mixed. \lstinline![...,...]! has higher precedence than
 \lstinline![...;...]!, e.g., \lstinline![a, b; c, d]! is parsed as \lstinline![[a,b];[c,d]]!.
\item
\lstinline![A] = promote(A,max(2,ndims(A)))!, i.e., \lstinline![A] = A!, if A has 2 or
  more dimensions, and it is a matrix with the elements of A, if A is a
  scalar or a vector.
\item
  There must be at least one argument (i.e. \lstinline![]! is not defined)
\end{itemize}

{[}\emph{Examples}:

\begin{lstlisting}[language=modelica]
  Real s1, s2, v1[n1], v2[n2], M1[m1,n],
  M2[m2,n], M3[n,m1], M4[n,m2], K1[m1,n,k],
  K2[m2,n,k];
  [v1;v2] is a (n1+n2) x 1 matrix
  [M1;M2] is a (m1+m2) x n matrix
  [M3,M4] is a n x (m1+m2) matrix
  [K1;K2] is a (m1+m2) x n x k array
  [s1;s2] is a 2 x 1 matrix
  [s1,s1] is a 1 x 2 matrix
  [s1] is a 1 x 1 matrix
  [v1] is a n1 x 1 matrix
  Real[3] v1 = array(1, 2, 3);
  Real[3] v2 = {4, 5, 6};
  Real[3,2] m1 = [v1, v2];
  Real[3,2] m2 = [v1, [4;5;6]]; // m1 = m2
  Real[2,3] m3 = [1, 2, 3; 4, 5, 6];
  Real[1,3] m4 = [1, 2, 3];
  Real[3,1] m5 = [1; 2; 3];
\end{lstlisting}
{]}

\subsection{Vector Construction}\doublelabel{vector-construction}

Vectors can be constructed with the general array constructor, e.g.,
\begin{lstlisting}[language=modelica]
  Real[3] v = {1,2,3}.
\end{lstlisting}
The range vector operator or colon operator of simple-expression can be
used instead of or in combination with this general constructor to
construct Real, Integer, Boolean or enumeration type vectors. Semantics
of the colon operator:

\begin{itemize}
\item
  j : k is the Integer vector \{j, j+1, ..., k\}, if j and k are of type
  Integer.
\item
  j : k is the Real vector \{j, j+1.0, ... n\}, with n = floor(k-j), if
  j and/or k are of type Real.
\item
  j : k is a Real, Integer, Boolean, or enumeration type vector with
  zero elements, if j \textgreater{} k.
\item
  j : d : k is the Integer vector \{j, j+d, ..., j+n*d\}, with n = div(k
  -- j, d), if j, d, and k are of type Integer.
\item
  j : d : k is the Real vector \{j, j+d, ..., j+n*d\}, with n =
  floor((k-j)/d), if j, d, or k are of type Real. In order to avoid
  rounding issues for the length it is recommended to use \{j+d*i for i
  in 0:n\} or linspace(j, k, n+1) -- if the number of elements are
  known.
\item
  j : d : k is a Real or Integer vector with zero elements, if d
  \textgreater{} 0 and j \textgreater{} k or if d \textless{} 0 and j
  \textless{} k.
\item
  false : true is the Boolean vector \{false, true\}.
\item
  j:j is \{j\} if j is Real, Integer, Boolean, or enumeration type.
\item
  E.ei : E.ej is the enumeration type vector \{ E.ei, ... E.ej\} where
  E.ej\textgreater{} E.ei, and ei and ej belong to some enumeration type
  E=enumeration(...ei,...ej,...).
\end{itemize}

{[}\emph{Examples}:

\begin{lstlisting}[language=modelica]
  Real v1[5] = 2.7 : 6.8;
  Real v2[5] = {2.7, 3.7, 4.7, 5.7, 6.7}; // = same as v1
  Boolean b1[2] = false:true;
  Colors = enumeration (red,blue,green);
  Colors ec[3] = Colors.red : Colors.green;
\end{lstlisting}
{]}

\section{Array Indexing}\doublelabel{array-indexing}

The array indexing operator \emph{name}\lstinline![!\emph{...}\lstinline!]! is used to
access array elements for retrieval of their values or for updating
these values. An indexing operation is subject to upper and lower array
dimension index bounds (\autoref{array-dimension-lower-and-upper-index-bounds}). {[}\emph{An indexing operation
is assumed to take constant time, i.e., largely independent of the size
of the array.}{]} The indexing operator takes two or more operands,
where the first operand is the array to be indexed and the rest of the
operands are index expressions:

arrayname{[}\emph{indexexpr1}, \emph{indexexpr2}, ...{]}

A colon is used to denote all indices of one dimension. A vector
expression can be used to pick out selected rows, columns and elements
of vectors, matrices, and arrays. The number of dimensions of the
expression is reduced by the number of scalar index arguments. If the
number of index arguments is smaller than the number of dimensions of
the array, the trailing indices will use ":".

It is also possible to use the array access operator to assign to
element/elements of an array in algorithm sections. If the index is an
array the assignments take place in the order given by the index array.
For assignments to arrays and elements of arrays, the entire right-hand
side and the index on the left-hand side are evaluated before any
element is assigned a new value.

{[}\emph{Examples}:
\begin{lstlisting}[language=modelica, escapechar=!]
  a[:, j] !\emph{is a vector of the j-th column of a,}!
  a[j] !\emph{is a vector of the j-th row of a:}! a[j, :]
  a[j : k] is {[a[j], a[j+1], ... , a[k]}
  a[:,j : k] is [a[:,j], a[:,j+1], ... , a[:,k]],
  v[2:2:8] = v[ {2,4,6,8} ] .
  v[{j,k}]:={2,3}; // Same as v[j]:=2; v[k]:=3;
  v[{1,1}]:={2,3}; // Same as v[1]:=3;
\end{lstlisting}
\emph{if} ] \lstinline!x! \emph{is a vector,} \lstinline!x[1]! \emph{is a scalar, but the
slice} \lstinline!x[1:5]! \emph{is a vector (a vector-valued or colon index
expression causes a vector to be returned).}

{]}

{[}\emph{Examples given the declaration} \lstinline!x[n,m], v[k], z[i,j,p]!:

\begin{longtable}[]{|l|l|l|}
\caption{Examples of scalars vs. array slices created with the colon index.}\\
\hline
\emph{Expression} & \emph{\# dimensions} & \emph{Type of value}\\ \hline
\endhead
\lstinline!x[1, 1]! & \lstinline!0! & Scalar\\ \hline
\lstinline!x[:, 1]! & \lstinline!1! & n -- Vector\\ \hline
\lstinline!x[1, :] or x[1]! & \lstinline!1! & m -- Vector\\ \hline
\lstinline!v[1:p]! & \lstinline!1! & p -- Vector\\ \hline
\lstinline!x[1:p, :]! & \lstinline!2! & p x m -- Matrix\\ \hline
\lstinline!x[1:1, :]! & \lstinline!2! & 1 x m - "row" matrix\\ \hline
\lstinline!x[{1, 3, 5\}, :]! & \lstinline!2! & 3 x m -- Matrix\\ \hline
\lstinline!x[: , v]! & \lstinline!2! & n x k -- Matrix\\ \hline
\lstinline!z[: , 3, :]! & \lstinline!2! & i x p -- Matrix\\ \hline
\lstinline!x[scalar([1]), :]! & \lstinline!1! & m -- Vector\\ \hline
\lstinline!x[vector([1]), :]! & \lstinline!2! & 1 x m - "row" matrix\\ \hline

\end{longtable}

{]}

\subsection{Indexing with Boolean or Enumeration Values}\doublelabel{indexing-with-boolean-or-enumeration-values}

Arrays can be indexed using values of enumeration types or the \lstinline!Boolean!
type, not only by integers. The type of the index should correspond to
the type used for declaring the dimension of the array.

{[}\emph{Example}:

\begin{lstlisting}[language=modelica]
  type ShirtSizes = enumeration(small, medium, large, xlarge);
  Real[ShirtSizes] w;
  Real[Boolean] b2;
algorithm
  w[ShirtSizes.large] := 2.28; // Assign a value to an element of w
  b2[true] := 10.0;
  b2[ShirtSizes.medium] := 4; // Error, b2 was declared with Boolean dimension
  w[1] := 3; // Error, w was declared with ShirtSizes dimension
\end{lstlisting}
{]}

\subsection{Indexing with end}\doublelabel{indexing-with-end}

The expression \lstinline!end! may only appear inside array subscripts, and if used
in the i:th subscript of an array expression \lstinline!A! it is equivalent to
\lstinline!size(A,i)! provided indices to A are a subtype of Integer. If used inside
nested array subscripts it refers to the most closely nested array.

{[}\emph{Examples}:

\begin{lstlisting}[language=modelica, escapechar=!]
  A[end -1,end] is A[size(A,1)-1,size(A,2)]
  A[v[end ],end] is A[v[size(v,1)],size(A,2)] // !\emph{since the first}! end !\emph{is referring to end of v.}!
\end{lstlisting}
{]}

\section{Scalar, Vector, Matrix, and Array Operator Functions}\doublelabel{scalar-vector-matrix-and-array-operator-functions}

The mathematical operations defined on scalars, vectors, and matrices
are the subject of linear algebra.

In all contexts that require an expression which is a subtype of Real,
an expression which is a subtype of Integer can also be used; the
Integer expression is automatically converted to Real.

The term numeric or numeric class is used below for a subtype of the
Real or Integer type classes.

\subsection{Equality and Assignment}\doublelabel{equality-and-assignment}

Equality \lstinline!a=b! and assignment \lstinline!a:=b! of scalars, vectors, matrices, and
arrays is defined element-wise and require both objects to have the same
number of dimensions and corresponding dimension sizes. The operands
need to be type equivalent. This is legal for the simple types and all
types satisfying the requirements for a record, and is in the latter
case applied to each component-element of the records.

\begin{longtable}[]{|l|l|l|l|}
\caption{Equality and assignment of arrays and scalars.}\\
\hline
\emph{Type of a} & \emph{Type of b} & \emph{Result of} a = b & \emph{Operation} (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & Scalar & a = b\\ \hline
Vector{[}n{]} & Vector{[}n{]} & Vector{[}n{]} & a{[}j{]} =
b{[}j{]}\\ \hline
Matrix{[}n, m{]} & Matrix{[}n, m{]} & Matrix{[}n, m{]} & a{[}j, k{]} =
b{[}j, k{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & Array{[}n, m,
\ldots{}{]} & a{[}j, k, \ldots{}{]} = b{[}j, k,
\ldots{}{]}\\ \hline
\end{longtable}

\subsection{Array Element-wise Addition, Subtraction, and String Concatenation}\doublelabel{array-element-wise-addition-subtraction-and-string-concatenation}

Addition \lstinline!a+b! and subtraction \lstinline!a-b! of numeric scalars, vectors, matrices,
and arrays is defined element-wise and require \lstinline!size(a)=size(b)! and a
numeric type for \lstinline!a! and \lstinline!b!. Unary plus and minus are defined element-wise.
Addition a+b of string scalars, vectors, matrices, and arrays is defined
as element-wise string concatenation of corresponding elements from \lstinline!a!
and \lstinline!b!, and require \lstinline!size(a)=size(b)!.

\begin{longtable}[]{|l|l|l|l|}
\caption{Array addition, subtraction, and string concatenation.}\\
\hline
\emph{Type of a} & \emph{Type of b} & \emph{Result of a +/- b} &
\emph{Operation c := a +/- b (j=1:n, k=1:m)}\\ \hline
\endhead
Scalar & Scalar & Scalar & c := a +/- b\\ \hline
Vector{[}n{]} & Vector{[}n{]} & Vector{[}n{]} & c{[}j{]} := a{[}j{]} +/-
b{[}j{]}\\ \hline
Matrix{[}n, m{]} & Matrix{[}n, m{]} & Matrix{[}n, m{]} & c{[}j, k{]} :=
a{[}j, k{]} +/- b{[}j, k{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & Array{[}n, m,
\ldots{}{]} & c {[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]} +/- b{[}j,
k, \ldots{}{]}\\ \hline
\end{longtable}

Element-wise addition \lstinline!a.+b! and subtraction \lstinline!a.-b! of numeric scalars,
vectors, matrices or arrays a and b requires a numeric type class for a
and b and either size(a) = size(b) or scalar a or scalar b. Element-wise
addition \lstinline!a.+b! of string scalars, vectors, matrices, and arrays is
defined as element-wise string concatenation of corresponding elements
from a and b, and require either size(a) = size(b) or scalar a or scalar
b.

\begin{longtable}[]{|l|l|l|l|}
\caption{Array element-wise addition, subtraction, and string concatenation.}\\
\hline
\emph{Type of a} & \emph{Type of b} & \emph{Result of a} \lstinline!.+/.-! \emph{b}
& \emph{Operation c := a .+/.- b (j=1:n, k=1:m)}\\ \hline
\endhead
Scalar & Scalar & Scalar & c := a +/- b\\ \hline
Scalar & Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a +/- b{[}j, k, \ldots{}{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Scalar & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a{[}j, k, \ldots{}{]} +/- b\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & Array{[}n, m,
\ldots{}{]} & c {[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]} +/- b{[}j,
k, \ldots{}{]}\\ \hline

\end{longtable}

\begin{longtable}[]{|l|l|l|}
\caption{Unary operators. The element-wise (.+, .-) and normal (+, -) operators give the same results.}\\
\hline
\emph{Type of a} & \emph{Result of} \lstinline!+/-! \emph{a} & \emph{Operation c :=
+/- a (j=1:n, k=1:m)}\\ \hline
\endhead
Scalar & Scalar & c := +/- a\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c{[}j, k,
\ldots{}{]} := +/-a{[}j, k, \ldots{}{]}\\ \hline

\end{longtable}

\subsection{Array Element-wise Multiplication}\doublelabel{array-element-wise-multiplication}

Scalar multiplication \lstinline!s*a! or \lstinline!a*s! with numeric scalar s and numeric
scalar, vector, matrix or array \lstinline!a! is defined element-wise:

\begin{longtable}[]{|l|l|l|l|}
\caption{Scalar and scalar to array multiplication of numeric elements}\\
\hline
\emph{Type of s} & \emph{Type of a} & \emph{Type of s* a and a*s} &
\emph{Operation} c := s*a or c := a*s (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & Scalar & c := s * a\\ \hline
Scalar & Vector {[}n{]} & Vector {[}n{]} & c{[}j{]} := s*
a{[}j{]}\\ \hline
Scalar & Matrix {[}n, m{]} & Matrix {[}n, m{]} & c{[}j, k{]} := s*
a{[}j, k{]}\\ \hline
Scalar & Array{[}n, m, ...{]} & Array {[}n, m, ...{]} & c{[}j, k, ...{]}
:= s*a{[}j, k, ...{]}\\ \hline
\label{tab:product}
\end{longtable}

Element-wise multiplication \lstinline!a.*b! of numeric scalars, vectors, matrices
or arrays a and b requires a numeric type class for a and b and either
size(a) = size(b) or scalar a or scalar b.

\begin{longtable}[]{|l|l|l|l|}
\caption{Array element-wise multiplication}\\
\hline
\emph{Type of a} & \emph{Type of b} & \emph{Type of a .* b} &
\emph{Operation} c:=a .* b (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & Scalar & c := a * b\\ \hline
Scalar & Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a* b{[}j, k, \ldots{}{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Scalar & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a{[}j, k, \ldots{}{]}* b\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, ...{]} & Array {[}n, m, ...{]}
& c{[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]}* b{[}j, k,
\ldots{}{]}\\ \hline
\end{longtable}

\subsection{Matrix and Vector Multiplication of Numeric Arrays}\doublelabel{matrix-and-vector-multiplication-of-numeric-arrays}

Multiplication \lstinline!a*b! of numeric vectors and matrices is defined only for
the following combinations:

\begin{longtable}[]{|l|l|l|l|}
\caption{Matrix and vector multiplication of arrays with numeric elements.}\\
\hline
\emph{Type of a} & \emph{Type of b} & \emph{Type of a* b} &
\emph{Operation c := a*b}\\ \hline
\endhead
Vector {[}n{]} & Vector {[}n{]} & Scalar & c :=
$\textrm{sum}_k$(a{[}k{]}*b{[}k{]}), k=1:n\\ \hline
Vector {[}n{]} & Matrix {[}n, m{]} & Vector {[}m{]} & c{[}j{]} :=
$\textrm{sum}_k$(a{[}k{]}*b{[}k, j{]}), j=1:m, k=1:n\\ \hline
Matrix {[}n, m{]} & Vector {[}m{]} & Vector {[}n{]} & c{[}j{]} :=
$\textrm{sum}_k$(a{[}j, k{]}*b{[}k{]})\\ \hline
Matrix {[}n, m{]} & Matrix {[}m, p{]} & Matrix {[}n, p{]} & c{[}i, j{]}
= $\textrm{sum}_k$(a{[}i, k{]}*b{[}k, j{]}), i=1:n, k=1:m,
j=1:p\\ \hline

\end{longtable}

{[}\emph{Example}:

\begin{lstlisting}[language=modelica]
  Real A[3,3], x[3], b[3], v[3];
  A*x = b;
  x*A = b; // same as transpose([x])*A*b
  [v]*transpose([v]) // outer product
  v*A*v // scalar
  tranpose([v])*A*v // vector with one element
\end{lstlisting}
{]}

\subsection{Division of Scalars or Numeric Arrays by Numeric Scalars}\doublelabel{division-of-scalars-or-numeric-arrays-by-numeric-scalars}

Division \lstinline!a/s! of numeric scalars, vectors, matrices, or arrays \lstinline!a! and
numeric scalars \lstinline!s! is defined element-wise. The result is always of real
type. In order to get integer division with truncation use the function
\lstinline!div!.

\begin{longtable}[]{|l|l|l|l|}
\caption{Division of scalars and arrays by numeric elements.}\\
\hline \endhead
\emph{Type of a} & \emph{Type of s} & \emph{Result of a / s} &
\emph{Operation c := a / s (j=1:n, k=1:m)}\\ \hline
Scalar & Scalar & Scalar & c := a / s\\ \hline
Vector{[}n{]} & Scalar & Vector{[}n{]} & c{[}k{]} := a{[}k{]} /
s\\ \hline
Matrix{[}n, m{]} & Scalar & Matrix{[}n, m{]} & c{[}j, k{]} := a{[}j,
k{]} / s\\ \hline
Array{[}n, m, \ldots{}{]} & Scalar & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a{[}j, k, \ldots{}{]} / s\\ \hline

\end{longtable}

\subsection{Array Element-wise Division}\doublelabel{array-element-wise-division}

Element-wise division \lstinline!a./b! of numeric scalars, vectors, matrices or
arrays a and b requires a numeric type class for a and b and either
size(a) = size(b) or scalar a or scalar b. The result is always of real
type. In order to get integer division with truncation use the function
\lstinline!div!.

\begin{longtable}[]{|l|l|l|l|}
\caption{Element-wise division of arrays}\\
\hline \endhead
\emph{Type of a} & \emph{Type of b} & \emph{Type of a ./ b} &
\emph{Operation} c:=a ./ b (j=1:n, k=1:m)\\ \hline
Scalar & Scalar & Scalar & c := a / b\\ \hline
Scalar & Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a / b{[}j, k, \ldots{}{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Scalar & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a{[}j, k, \ldots{}{]} / b\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, ...{]} & Array {[}n, m, ...{]}
& c{[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]} / b{[}j, k,
\ldots{}{]}\\ \hline

\end{longtable}

{[}\emph{Element-wise division by scalar (./) and division by scalar (/)
are identical: a./s = a/s.}

\emph{Example:}

\begin{lstlisting}[language=modelica]
  2./[1,2;3,4] // error, since 2.0/[1,2;3,4]
  2 ./[1,2;3,4] // fine, element-wise division
\end{lstlisting}
\emph{This is a consequence of the parsing rules, since 2. is a lexical
unit. Using a space after the literal solves the problem.}{]}

\subsection{Exponentiation of Scalars of Numeric Elements}\doublelabel{exponentiation-of-scalars-of-numeric-elements}

Exponentiation "\lstinline!a^b!" is defined as pow(double a,double b) in the ANSI
C library if both "\lstinline!a!" and "\lstinline!b!" are Real scalars. A Real scalar value is
returned. If "a" or "b" are Integer scalars, they are automatically
promoted to "Real". Consequences of exceptional situations, such as
(a==0.0 \textbf{and} b\textless{}=0.0, a\textless{}0 \textbf{and} b is
not an integer) or overflow are undefined

Element-wise exponentiation \lstinline!a.^b! of numeric scalars, vectors,
matrices, or arrays a and b requires a numeric type class for a and b
and either size(a) = size(b) or scalar a or scalar b.

\begin{longtable}[]{|l|l|l|l|}
\caption{Element-wise exponentiation of arrays}\\
\hline
\emph{Type of a} & \emph{Type of b} & \emph{Type of a .\^{} b} &
\emph{Operation} c:=a .\^{} b (j=1:n, k=1:m)\\ \hline
\endhead
Scalar & Scalar & Scalar & c := a \^{} b\\ \hline
Scalar & Array{[}n, m, \ldots{}{]} & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a \^{} b{[}j, k, \ldots{}{]}\\ \hline
Array{[}n, m, \ldots{}{]} & Scalar & Array{[}n, m, \ldots{}{]} & c{[}j,
k, \ldots{}{]} := a{[}j, k, \ldots{}{]} \^{} b\\ \hline
Array{[}n, m, \ldots{}{]} & Array{[}n, m, ...{]} & Array {[}n, m, ...{]}
& c{[}j, k, \ldots{}{]} := a{[}j, k, \ldots{}{]} \^{} b{[}j, k,
\ldots{}{]}\\ \hline

\end{longtable}

{[}\emph{Example:}

\begin{lstlisting}[language=modelica]
  2.^[1,2;3,4] // error, since 2.0^[1,2;3,4]
  2 .^[1,2;3,4] // fine, element wise exponentiation
\end{lstlisting}
\emph{This is a consequence of the parsing rules, i.e. since 2. could be
a lexical unit it seen as a lexical unit; using a space after literals
solves the problem.}{]}

\subsection{Scalar Exponentiation of Square Matrices of Numeric Elements}\doublelabel{scalar-exponentiation-of-square-matrices-of-numeric-elements}

Exponentiation \lstinline!a^s! is defined if \lstinline!a! is a square numeric matrix and \lstinline!s!
is a scalar as a subtype of Integer with \lstinline!s>=0!. The
exponentiation is done by repeated multiplication

(e.g.:
\begin{lstlisting}[language=modelica]
  a^3 = a*a*a; a^0 = identity(size(a,1));
  assert(size(a,1)==size(a,2),"Matrix must be square");
  a^1 = a;
\end{lstlisting}
{[}\emph{Non-Integer exponents are forbidden, because this would require
computing the eigenvalues and eigenvectors of ``a'' and this is no
longer an elementary operation}{]}.

\subsection{Slice Operation}\doublelabel{slice-operation}

The following holds for slice operations:

\begin{itemize}
\item
  If \lstinline!a! is an array containing scalar components and \lstinline!m! is a component of
  those components, the expression \lstinline!a.m! is interpreted as a slice operation. It returns the array of components \lstinline!{a{[1].m,  ...}!.
\item
  If \lstinline!m! is also an array component, the slice operation is valid only if \lstinline!size(a[1].m)=size(a[2].m)=...!
\item
  The slicing operation can be combined with indexing, e.g. \lstinline!a.m[1]!.
  It returns the array of components  \lstinline!{a[1].m[1],  a[2].m[1], ...}!, and does not require that
   \lstinline!size(a[1].m)=size(a[2].m)!. The number of subscripts on m must
  not be greater than the number of array dimension for m (the number
  can be smaller, in which case the missing trailing indices are assumed
  to be ":"), and is only valid if   \lstinline!size(a[1].m[...])=size(a[2].m[...])!..
\end{itemize}

{[}\emph{Example: The size-restriction on the operand is only applicable
if the indexing on the second operand uses vectors or colon as in the
example:}

\begin{lstlisting}[language=modelica]
  constant Integer m=3;
  Modelica.Blocks.Continuous.LowpassButterworth tf[m](n=2:(m+1));
  Real y[m];
  Real y2,y3;
equation
  // Extract the x1 slice even though different x1's have different lengths
  y=tf.x1[1] ; // Legal, ={tf[1].x1[1], tf[2].x1[1],
  ... tf[m].x1[1]};
  y2=sum(tf.x1[:]); // Illegal to extract all elements since they have
  // different lengths. Does not satisfy:
  // size(tf[1].x1[:])=size(tf[2].x1[:])=...=size(tf[m].x1[:])
  y3=sum(tf.x1[1:2]); // Legal.
  // Since x1 has at least 2 elements in all tf, and
  // size(tf[1].x1[1:2])=size(tf[2].x1[1:2])=...=size(tf[m].x1[1:2])={2}
\end{lstlisting}
\emph{In this example the different x1 vectors have different lengths,
but it is still possible to perform some operations on them.}{]}

\subsection{Relational Operators}\doublelabel{relational-operators}

Relational operators \textless{}, \textless{}=, \textgreater{},
\textgreater{}=, ==, \textless{}\textgreater{}, are only defined for
scalar operands of simple types, not for arrays, see \autoref{equality-relational-and-logical-operators}

\subsection{Boolean Operators}\doublelabel{boolean-operators}

The operators, \lstinline!and! and \lstinline!or! take expressions of Boolean type, which are
either scalars or arrays of matching dimensions. The operator \lstinline!not! takes
an expression of Boolean type, which is either scalar or an array. The
result is the element-wise logical operation. For short-circuit
evaluation of \lstinline!and! and \lstinline!or! see \autoref{evaluation-order}.

\subsection{Vectorized Calls of Functions}\doublelabel{vectorized-calls-of-functions}

See \autoref{scalar-functions-applied-to-array-arguments}.

\section{Empty Arrays}\doublelabel{empty-arrays}

Arrays may have dimension sizes of 0. E.g.

\begin{lstlisting}[language=modelica]
  Real x[0]; // an empty vector
  Real A[0, 3], B[5, 0], C[0, 0]; // empty matrices
\end{lstlisting}
Empty matrices can be constructed with the fill function. E.g.

\begin{lstlisting}[language=modelica]
  Real A[:,:] = fill(0.0, 0, 1); // a Real 0 x 1 matrix
  Boolean B[:, :, :] = fill(false, 0, 1, 0); // a Boolean 0 x 1 x 0 matrix
\end{lstlisting}
It is not possible to access an element of an empty matrix, e.g.
  \lstinline!v[j,k]! cannot be evaluated if \lstinline!v=[]! because the assertion fails
that the index must be bigger than one.

Size-requirements of operations, such as +, -, have also to be fulfilled
if a dimension is zero. E.g.

\begin{lstlisting}[language=modelica]
  Real[3,0] A, B;
  Real[0,0] C;
  A + B // fine, result is an empty matrix
  A + C // error, sizes do not agree
\end{lstlisting}
Multiplication of two empty matrices results in a zero matrix of
corresponding numeric type if the result matrix has no zero dimension
sizes, i.e.,

\begin{lstlisting}[language=modelica]
  Real[0,m]*Real[m,n] = Real[0,n] (empty matrix)
  Real[m,n]*Real[n,0] = Real[m,0] (empty matrix)
  Real[m,0]*Real[0,n] = fill(0.0, m, n) (non-empty matrix, with zero elements).
\end{lstlisting}
{[}\emph{Example}:

\begin{lstlisting}[language=modelica]
  Real u[p], x[n], y[q], A[n,n], B[n,p], C[q,n],
  D[q,p];
  der(x) = A*x + B*u
  y = C*x + D*u
\end{lstlisting}
\emph{Assume n=0, p\textgreater{}0, q\textgreater{}0: Results in} \lstinline!y = D*u!

{]}
