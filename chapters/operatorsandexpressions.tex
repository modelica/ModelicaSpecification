\chapter{Operators and Expressions}\label{operators-and-expressions}

The lexical units are combined to form even larger building blocks such
as expressions according to the rules given by the expression part of
the Modelica grammar in \cref{modelica-concrete-syntax}.

This chapter describes the evaluation rules for expressions, the concept
of expression variability, built-in mathematical operators and
functions, and the built-in special Modelica operators with function
syntax.

Expressions can contain variables and constants, which have types,
predefined or user defined. The predefined built-in types of Modelica
are \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, \lstinline!String!, and enumeration types which are
presented in more detail in \cref{predefined-types-and-classes}.

\section{Expressions}\label{expressions}

Modelica equations, assignments and declaration equations contain
expressions.

Expressions can contain basic operations, \lstinline!+!, \lstinline!-!, \lstinline!*!, \lstinline!/!, \lstinline!^!, etc.\ with
normal precedence as defined in the Table in \cref{operator-precedence-and-associativity} and the grammar
in \cref{modelica-concrete-syntax}. The semantics of the operations is defined for both
scalar and array arguments in \cref{scalar-vector-matrix-and-array-operator-functions}.

It is also possible to define functions and call them in a normal
fashion. The function call syntax for both positional and named
arguments is described in \cref{positional-or-named-input-arguments-of-functions} and for vectorized calls in
\cref{initialization-and-binding-equations-of-components-in-functions}. The built-in array functions are given in \cref{array-dimension-lower-and-upper-index-bounds}
and other built-in operators in \cref{built-in-intrinsic-operators-with-function-syntax}.

\section{Operator Precedence and Associativity}\label{operator-precedence-and-associativity}

Operator precedence determines the order of evaluation of operators in
an expression. An operator with higher precedence is evaluated before an
operator with lower precedence in the same expression.

The following table presents all the expression operators in order of
precedence from highest to lowest, as derived from the Modelica grammar
in \cref{modelica-concrete-syntax}. All operators are binary except the postfix operators and
those shown as unary together with \emph{expr}, the conditional
operator, the array construction operator \lstinline!{ }! and concatenation
operator \lstinline![ ]!, and the array range constructor which is either binary
  or ternary. Operators with the same precedence occur at the same line of
the table:
\begin{table}[H]
\caption{Operators.}
\begin{tabular}{|p{5cm}|p{5cm}|p{4cm}|}
\hline
\tablehead{Operator Group} & \tablehead{Operator Syntax} & \tablehead{Examples}\\ \hline
postfix array index operator & \lstinline![]! & \lstinline!arr[index]! \\ \hline
postfix access operator & \lstinline!.! & \lstinline!a.b! \\ \hline
postfix function call & \lstinline!$\mathit{funcName}$($\mathit{functionArguments}$)! & \lstinline!sin(4.36)! \\ \hline
array construct/concat & \begin{tabular}{@{}p{5cm}@{}}
\lstinline!{$\mathit{expressions}$}!\\
\lstinline![$\mathit{expressions}$]!\\
\lstinline![$\mathit{expressions}$; $\mathit{expressions}\ldots$]!
\end{tabular} & \begin{tabular}{@{}p{5cm}@{}}
\lstinline!{2,3}! \\
\lstinline![5,6]! \\
\lstinline![2,3; 7,8]!
\end{tabular} \\ \hline
exponentiation & \ \lstinline!^! & \lstinline!2^3! \\ \hline
multiplicative and array elementwise multiplicative & \lstinline!* / .* ./! & \begin{tabular}{@{}p{5cm}@{}}
\lstinline!2*3!, \lstinline!2/3! \\
\lstinline![1,2;3,4].*[2,3;5,6]!
\end{tabular} \\ \hline
additive and array elementwise additive & \lstinline!+ - +$\mathit{expr}$ -$\mathit{expr}$ .+ .-! & \lstinline![1,2;3,4].+[2,3;5,6]!\\ \hline
relational & \lstinline!< <= > >= == <>! &
\lstinline!a<b!, \lstinline!a<=b!, \lstinline!a>b!, \ldots\\ \hline
unary negation & \lstinline!not $\mathit{expr}$! & \lstinline!not b1! \\ \hline
logical and & \lstinline!and! & \lstinline!b1 and b2! \\ \hline
logical or & \lstinline!or! & \lstinline!b1 or b2!\\ \hline
array range & \begin{tabular}{@{}p{5cm}@{}}
\lstinline!$\mathit{expr}$ : $\mathit{expr}$! \\
\lstinline!$\mathit{expr}$ : $\mathit{expr}$ : $\mathit{expr}$!
\end{tabular} & \begin{tabular}{@{}p{5cm}@{}}
\lstinline!1:5! \\
\lstinline!start:step:stop!
\end{tabular} \\ \hline
conditional & \lstinline!if $\mathit{expr}$ then $\mathit{expr}$ else $\mathit{expr}$! & \lstinline!if b then 3 else x!\\ \hline
named argument & \lstinline!$\mathit{ident}$ = $\mathit{expr}$! & \lstinline!x = 2.26!\\ \hline
\end{tabular}
\label{tab:operator-precedence}
\end{table}

The conditional operator may also include elseif-clauses. Equality \lstinline!=! and
assignment \lstinline!:=! are not expression operators since they are allowed only
in equations and in assignment statements respectively. All binary
expression operators are left associative, except exponentiation which
is non-associative. The array range operator is non-associative.

\begin{nonnormative}
The unary minus and plus in Modelica is slightly different than in Mathematica\footnote{\emph{Mathematica} is a registered trademark of Wolfram Research Inc.} and in MATLAB\footnote{\emph{MATLAB} is
a registered trademark of MathWorks Inc.}, since the following expressions are illegal (whereas in Mathematica and in MATLAB these are valid expressions):
\begin{lstlisting}[language=modelica]
2*-2  // = -4 in Mathematica/MATLAB; is illegal in Modelica
--2   // = 2 in Mathematica/MATLAB; is illegal in Modelica
++2   // = 2 in Mathematica/MATLAB; is illegal in Modelica
2--2  // = 4 in Mathematica/MATLAB; is illegal in Modelica
\end{lstlisting}

Non-associative exponentiation and array range operator:
\begin{lstlisting}[language=modelica]
x^y^z         // Not legal, use parenthesis to make it clear
a:b:c:d:e:f:g // Not legal, and scalar arguments gives no legal interpretation.
\end{lstlisting}
\end{nonnormative}

\section{Evaluation Order}\label{evaluation-order}

A tool is free to solve equations, reorder expressions and to not evaluate expressions if their values do not influence the result (e.g.\ short-circuit
evaluation of Boolean expressions).  If-statements and if-expressions guarantee that their clauses are only evaluated if the appropriate condition is true,
but relational operators generating state or time events will during continuous integration have the value from the most recent event.

If a numeric operation overflows the result is undefined. For literals
it is recommended to automatically convert the number to another type
with greater precision.

\subsection{Example: Guarding Expressions Against Incorrect Evaluation}\label{example-guarding-expressions-against-incorrect-evaluation}

\begin{example}
If one wants to guard an expression against incorrect evaluation, it should be guarded by an \lstinline!if!:
\begin{lstlisting}[language=modelica]
  Boolean v[n];
  Boolean b;
  Integer I;
equation
  b=(I>=1 and I<=n) and v[I]; // Invalid
  b=if (I>=1 and I<=n) then v[I] else false; // Correct
\end{lstlisting}

To guard square against square root of negative number use \lstinline!noEvent!:
\begin{lstlisting}[language=modelica]
der(h)=if h>0 then -c*sqrt(h) else 0; // Incorrect
der(h)=if noEvent(h>0) then -c*sqrt(h) else 0; // Correct
\end{lstlisting}
\end{example}

\section{Arithmetic Operators}\label{arithmetic-operators}

Modelica supports five binary arithmetic operators that operate on any
numerical type:
\begin{longtable}[c]{ll}
\lstinline!^! & Exponentiation\\
\lstinline!*! & Multiplication\\
\lstinline!/! & Division\\
\lstinline!+! & Addition\\
\lstinline!-! & Subtraction\\
\end{longtable}

Some of these operators can also be applied to a combination of a scalar
type and an array type, see \cref{scalar-vector-matrix-and-array-operator-functions}.

The syntax of these operators is defined by the following rules from the
Modelica grammar:
\begin{lstlisting}[language=grammar]
arithmetic-expression :
   [ add-operator ] term { add-operator term }

add-operator :
   "+" | "-"

term :
   factor { mul-operator factor }

mul-operator :
   "*" | "/"

factor :
   primary [ "^" primary ]
\end{lstlisting}

\section{Equality, Relational, and Logical Operators}\label{equality-relational-and-logical-operators}

Modelica supports the standard set of relational and logical operators,
all of which produce the standard boolean values \lstinline!true! or \lstinline!false!.


\begin{longtable}[]{ll}
\lstinline!>! & greater than\\
\lstinline!>=! & greater than or equal\\
\lstinline!<! & less than\\
\lstinline!<=! & less than or equal to\\
\lstinline!==! & equality within expressions\\
\lstinline!<>! & Inequality\\
\end{longtable}

A single equals sign \lstinline!=! is never used in relational expressions, only in
equations (\cref{equations}, \cref{equality-and-assignment}) and in function calls using named
parameter passing (\cref{positional-or-named-input-arguments-of-functions}).

The following logical operators are defined:
\begin{longtable}[]{ll}
\lstinline!not! & negation, unary operator\\
\lstinline!and! & logical and\\
\lstinline!or! & logical or\\
\end{longtable}

The grammar rules define the syntax of the relational and logical
operators.

\begin{lstlisting}[language=grammar]
logical-expression :
   logical-term { or logical-term }

logical-term :
   logical-factor { and logical-factor }

logical-factor :
   [ not ] relation

relation :
   arithmetic-expression [ relational-operator arithmetic-expression ]

relational-operator :
   "<" | "<=" | ">" | ">=" | "==" | "<>"
\end{lstlisting}

The following holds for relational operators:
\begin{itemize}
\item
  Relational operators \lstinline!<!, \lstinline!<=!,\lstinline!>!,
\lstinline!>=!, \lstinline!==!, \lstinline!<>!, are only defined for
  scalar operands of simple types. The result is \lstinline!Boolean! and is true or
  false if the relation is fulfilled or not, respectively.
\item
  For operands of type \lstinline!String!, \lstinline!str1 op str2! is for each relational
  operator, \lstinline!op!, defined in terms of the C-function \lstinline!strcmp! as
  \lstinline!strcmp(str1,str2) op 0!.
\item
  For operands of type \lstinline!Boolean!, \lstinline!false < true!.
\item
  For operands of enumeration types, the order is given by the order of
  declaration of the enumeration literals.
\item
  In relations of the form \lstinline!v1 == v2 or v1 <> v2!,
  \lstinline!v1! or \lstinline!v2! shall, unless used in a function, not be a subtype of \lstinline!Real!.
  \begin{nonnormative}
  The reason for this rule is that relations with \lstinline!Real! arguments are transformed to state events (see Events, \cref{events-and-synchronization})
  and this transformation becomes unnecessarily complicated for the \lstinline!==! and \lstinline!<>! relational operators (e.g.\ two crossing functions instead
  of one crossing function needed, epsilon strategy needed even at event instants). Furthermore, testing on equality of Real variables is questionable on machines
  where the number length in registers is different to number length in main memory.
  \end{nonnormative}
\item
  Relational operators can generate events, see \cref{discrete-time-expressions}.
\end{itemize}

\section{Miscellaneous Operators and Variables}\label{miscellaneous-operators-and-variables}

Modelica also contains a few built-in operators which are not standard
arithmetic, relational, or logical operators. These are described below,
including \lstinline!time!, which is a built-in variable, not an operator.

\subsection{String Concatenation}\label{string-concatenation}

Concatenation of strings (see the Modelica grammar) is denoted by the \lstinline!+!
operator in Modelica.

\begin{example}
\lstinline!"a" + "b"! becomes \lstinline!"ab"!.
\end{example}

\subsection{Array Constructor Operator}\label{array-constructor-operator}

The array constructor operator \lstinline!{ $\ldots$ }! is described in \cref{vector-matrix-and-array-constructors}.

\subsection{Array Concatenation Operator}\label{array-concatenation-operator}

The array concatenation operator \lstinline![ $\ldots$ ]! is described in \cref{array-concatenation}.

\subsection{Array Range Operator}\label{array-range-operator}

The array range constructor operator \lstinline!:! is described in \cref{vector-construction}.

\subsection{If-Expressions}\label{if-expressions}

An expression
\begin{lstlisting}[language=modelica]
if expression1 then expression2 else expression3
\end{lstlisting}
is one example of if-expression. First \lstinline!expression1!, which must be
\lstinline!Boolean! expression, is evaluated. If \lstinline!expression1! is true \lstinline!expression2! is
evaluated and is the value of the if-expression, else \lstinline!expression3! is
evaluated and is the value of the if-expression. The two expressions,
\lstinline!expression2! and \lstinline!expression3!, must be type compatible expressions
(\cref{type-compatible-expressions}) giving the type of the if-expression. If-expressions with
\lstinline!elseif! are defined by replacing \lstinline!elseif! by \lstinline!else if!. For
short-circuit evaluation see \cref{evaluation-order}.

\begin{nonnormative}
\lstinline!elseif! in expressions has been added to the Modelica language for symmetry with if-clauses.
\end{nonnormative}

\begin{example}
\begin{lstlisting}[language=modelica]
Integer i;
Integer sign_of_i1=if i<0 then -1 elseif i==0 then 0 else 1;
Integer sign_of_i2=if i<0 then -1 else if i==0 then 0 else 1;
\end{lstlisting}
\end{example}

\subsection{Member Access Operator}\label{member-access-operator}

It is possible to access members of a class instance using dot notation,
i.e., the \lstinline!.! operator.

\begin{example}
\lstinline!R1.R! for accessing the resistance component \lstinline!R!
of resistor \lstinline!R1!. Another use of dot notation: local classes
which are members of a class can of course also be accessed using dot
notation on the name of the class, not on instances of the class.
\end{example}

\subsection{Built-in Variable time}\label{built-in-variable-time}

All declared variables are functions of the independent variable \lstinline!time!.
The variable \lstinline!time! is a built-in variable available in all models and
blocks, which is treated as an input variable. It is implicitly defined
as:
\begin{lstlisting}[language=modelica]
input Real time (final quantity = "Time",
                 final unit = "s");
\end{lstlisting}

The value of the start attribute of time is set to the time instant at
which the simulation is started.

\begin{example}
\begin{lstlisting}[language=modelica]
encapsulated model SineSource
  import Modelica.Math.sin;
  connector OutPort=output Real;
  OutPort y=sin(time); // Uses the built-in variable time.
end SineSource;
\end{lstlisting}
\end{example}

\section{Built-in Intrinsic Operators with Function Syntax}\label{built-in-intrinsic-operators-with-function-syntax}

Certain built-in operators of Modelica have the same syntax as a
function call. However, they do not behave as a mathematical function,
because the result depends not only on the input arguments but also on
the status of the simulation.

There are also built-in functions that depend only on the input
argument, but also may trigger events in addition to returning a value.
Intrinsic means that they are defined at the Modelica language level,
not in the Modelica library. The following built-in intrinsic
operators/functions are available:
\begin{itemize}
\item
  Mathematical functions and conversion functions, see \cref{numeric-functions-and-conversion-functions}
  below.
\item
  Derivative and special purpose operators with function syntax, see
  \cref{derivative-and-special-purpose-operators-with-function-syntax} below.
\item
  Event-related operators with function syntax, see \cref{event-related-operators-with-function-syntax} below.
\item
  Array operators/functions, see \cref{array-dimension-lower-and-upper-index-bounds}.
\end{itemize}

Note that when the specification references a function having the name
of a built-in function it references the built-in function, not a
user-defined function having the same name, see also \cref{built-in-functions}. With
exception of the built-in \lstinline!String! operator, all operators in this section
can only be called with positional arguments.

\subsection{Numeric Functions and Conversion Functions}\label{numeric-functions-and-conversion-functions}

The following mathematical operators and functions, also including some
conversion functions, are predefined in Modelica, and are vectorizable
according to \cref{scalar-functions-applied-to-array-arguments}, except for the \lstinline!String! function. The
functions which do not trigger events are described in the table below,
whereas the event-triggering mathematical functions are described in
\cref{event-triggering-mathematical-functions}.

\begin{longtable}{|p{4.5cm}|p{10cm}|} \hline
\endhead
\lstinline!abs(v)! & Is expanded into \lstinline!noEvent(if v >= 0 then v else -v)!. Argument v needs to be an Integer or Real expression.\\ \hline
\lstinline!sign(v)! & Is expanded into \lstinline!noEvent(if v>0 then 1 else if v<0 then -1 else 0)!. Argument v needs to be an Integer or Real
expression.\\ \hline
\lstinline!sqrt(v)! & Returns the square root of \lstinline!v if v>=0!, otherwise
an error occurs. Argument v needs to be an Integer or Real
expression.\\ \hline

\lstinline!Integer(e)! & Returns the ordinal number of the expression \lstinline!e! of
enumeration type that evaluates to the enumeration value \lstinline!E.enumvalue!,
where \lstinline!Integer(E.e1)=1!, \lstinline!Integer(E.en)=n!, for an enumeration type
\lstinline!E=enumeration(e1, ..., en)!. See also \cref{type-conversion-of-enumeration-values-to-string-or-integer}.\\ \hline
\lstinline!EnumTypeName(i)! &
For any enumeration type \lstinline!EnumTypeName!, returns the enumeration
value \lstinline!EnumTypeName!.e such that \lstinline!Integer(EnumTypeName.e) = i!. Refer to the definition of
\lstinline!Integer! above.

It is an error to attempt to convert values of i that do not correspond
to values of the enumeration type. See also \cref{type-conversion-of-integer-to-enumeration-values}.
\\ \hline

\begin{tabular}{@{}p{4.5cm}@{}}
\lstinline!String(b, <options>)!\\
\lstinline!String(i, <options>)!\\
\lstinline!String(r,!
\hspace*{1ex}\lstinline!significantDigits=d,!
\hspace*{1ex}\lstinline!<options>)!\\
\lstinline!String(r, format=s)!\\
\lstinline!String(e, <options>)!
\end{tabular}
&
Convert a scalar non-\lstinline!String! expression to a \lstinline!String! representation. The
first argument may be a \lstinline!Boolean b!, an \lstinline!Integer i!, a \lstinline!Real r! or an
\lstinline!Enumeration e! (\cref{type-conversion-of-enumeration-values-to-string-or-integer}). The other arguments must use named
arguments. The optional \textless{}options\textgreater{} are:

\lstinline!Integer minimumLength=0!: minimum length of the resulting string. If
necessary, the blank character is used to fill up unused space.

\lstinline!Boolean leftJustified = true!: if true, the converted result is left
justified in the string; if false it is right justified in the string.

For \lstinline!Real! expressions the output shall be according to the Modelica
grammar. \lstinline!Integer significantDigits!=6: defines the number of significant
digits in the result string.

\begin{nonnormative}
Examples of \lstinline!Real! values formatted with 6 significant digits: \emph{12.3456}, \emph{0.0123456}, \emph{12345600}, \emph{1.23456E-10}.
\end{nonnormative}

The format string corresponding to options is:
\begin{itemize}
\item
  for Reals: %\newline
  \lstinline!(if leftJustified then "-" else "") +  String(minimumLength)+"."+ String(signficantDigits)+"g"!,
\item
  for Integers: %\newline
  \lstinline!(if leftJustified then "-" else "")+ String(minimumLength)+"d"!.
\end{itemize}

Format string: According to ANSI-C the format string specifies one
conversion specifier (excluding the leading \%), may not contain length
modifiers, and may not use `\lstinline!*!' for width and/or precision. For all
numeric values the format specifiers `\lstinline!f!', `\lstinline!e!', `\lstinline!E!', `\lstinline!g!', `\lstinline!G!' are allowed. For
integral values it is also allowed to use the `\lstinline!d!', `\lstinline!i!', `\lstinline!o!', `\lstinline!x!', `\lstinline!X!', `\lstinline!u!', and
`\lstinline!c!' format specifiers (for non-integral values a tool may~round, truncate
or use a different format if the integer conversion characters are
used).

The x,X-formats (hexa-decimal)~and c (character) for Integers does not
lead to input~that agrees with the Modelica-grammar.\\ \hline
\end{longtable}

\subsubsection{Event Triggering Mathematical Functions}\label{event-triggering-mathematical-functions}

The built-in operators in this section trigger events if used outside of
a when-clause and outside of a clocked discrete-time partition (see
\cref{clocked-discrete-time-and-clocked-discretized-continuous-time-partition}).
These expression for \lstinline!div!, \lstinline!ceil!, \lstinline!floor!, and \lstinline!integer! are
event generating expression. The event generating expression for
\lstinline!mod(x,y)! is \lstinline!floor(x/y)!, and for \lstinline!rem(x,y)! it is \lstinline!div(x,y)! -- i.e.\ events
are not generated when \lstinline!mod! or \lstinline!rem! changes continuously in an interval,
but when they change discontinuously from one interval to the next.

\begin{nonnormative}
If this is not desired, the \lstinline!noEvent! function can be applied to them.  E.g.\ \lstinline!noEvent(integer(v))!.
\end{nonnormative}

\begin{longtable}{|p{2cm}|p{12cm}|} \hline
\endhead
\lstinline!div(x,y)! & Returns the algebraic quotient \lstinline!x/y! with any fractional part
discarded (also known as truncation toward zero).
\begin{nonnormative}
This is defined for \lstinline!/! in C99; in C89 the result for negative numbers is implementation-defined, so the standard function \lstinline[language=C]!div! must be used.
\end{nonnormative}
Result and arguments shall have type \lstinline!Real! or \lstinline!Integer!. If
either of the arguments is \lstinline!Real! the result is \lstinline!Real! otherwise
\lstinline!Integer!.\\ \hline
\lstinline!mod(x,y)! & Returns the integer modulus of \lstinline!x/y!, i.e.
\lstinline!mod(x,y)=x-floor(x/y)*y!. Result and arguments shall have type \lstinline!Real! or
\lstinline!Integer!. If either of the arguments is \lstinline!Real! the result is \lstinline!Real! otherwise
\lstinline!Integer!.
\par
\begin{nonnormative*}
Note, outside of a when-clause state events are triggered when the return value changes discontinuously. Examples:
\lstinline!mod(3,1.4)=0.2!, \lstinline!mod(-3,1.4)=1.2!, \lstinline!mod(3,-1.4)=-1.2!.
\end{nonnormative*}
\\ \hline
\lstinline!rem(x,y)! & Returns the integer remainder of \lstinline!x/y!, such that \lstinline!div(x,y)*y + rem(x, y) = x!. Result and arguments shall have type \lstinline!Real! or \lstinline!Integer!. If
either of the arguments is \lstinline!Real! the result is \lstinline!Real! otherwise \lstinline!Integer!.
\par
\begin{nonnormative*}
Note, outside of a when-clause state events are triggered when the return value changes discontinuously. Examples:
\lstinline!rem(3,1.4)=0.2!, \lstinline!rem(-3,1.4)=-0.2!
\end{nonnormative*}
\\ \hline
\lstinline!ceil(x)! & Returns the smallest integer not less than \lstinline!x!. Result and
argument shall have type \lstinline!Real!.
\par
\begin{nonnormative*}
Note, outside of a when-clause state events are triggered when the return value changes discontinuously.
\end{nonnormative*}
\\ \hline
\lstinline!floor(x)! & Returns the largest integer not greater than \lstinline!x!. Result and
argument shall have type \lstinline!Real!.
\par
\begin{nonnormative*}
Note, outside of a when-clause state events are triggered when the return value changes discontinuously.
\end{nonnormative*}
\\ \hline
\lstinline!integer(x)! & Returns the largest integer not greater
than \lstinline!x!. The argument shall have type \lstinline!Real!. The result has type
\lstinline!Integer!.
\par
\begin{nonnormative*}
Note, outside of a when-clause state events are triggered when the return value changes discontinuously.
\end{nonnormative*}
\\ \hline
\end{longtable}

\subsubsection{Built-in Mathematical Functions and External Built-in Functions}\label{built-in-mathematical-functions-and-external-built-in-functions}

The following built-in mathematical functions are available in Modelica
and can be called directly without any package prefix added to the
function name. They are also available as external built-in functions in
the \lstinline!Modelica.Math! library.

\begin{longtable}{|l|p{8cm}|}
\hline \endhead
\lstinline!sin(x)! & sine\\ \hline
\lstinline!cos(x)! & cosine\\ \hline
\lstinline!tan(x)! & tangent ($x$ shall not be: ..., -$\pi$/2, $\pi$/2, 3$\pi$/2, ...)\\ \hline
\lstinline!asin(x)! & inverse sine (-1 $\le x \le$ 1)\\ \hline
\lstinline!acos(x)! & inverse cosine (-1 $\le x \le$ 1)\\ \hline
\lstinline!atan(x)! & inverse tangent\\ \hline
\lstinline!atan2(y, x)! & the \lstinline!atan2(y, x)! function calculates the principal value of the arc tangent of $y/x$, using the signs of the two arguments to determine the quadrant of the result\\ \hline
\lstinline!sinh(x)! & hyperbolic sine\\ \hline
\lstinline!cosh(x)! & hyperbolic cosine\\ \hline
\lstinline!tanh(x)! & hyperbolic tangent\\ \hline
\lstinline!exp(x)! & exponential, base $e$\\ \hline
\lstinline!log(x)! & natural (base $e$) logarithm ($x > 0$)\\ \hline
\lstinline!log10(x)! & base 10 logarithm ($x > 0$)\\ \hline
\end{longtable}

\subsection{Derivative and Special Purpose Operators with Function Syntax}\label{derivative-and-special-purpose-operators-with-function-syntax}

The following derivative operator and special purpose operators with
function syntax are predefined. The special purpose operators with
function syntax where the call below uses named arguments can be called
with named arguments (with the specified names), or with positional
arguments (the inputs of the functions are in the order given in the
calls below).

\begin{longtable}{|p{5.1cm}|p{8cm}|}
\hline \endhead

\lstinline!der!(expr) &
The time derivative of \lstinline!expr!. If the expression \lstinline!expr! is a
scalar it needs to be a subtype of Real. The expression and all its
time-varying subexpressions must be continuous and semi-differentiable.
If \lstinline!expr! is an array, the operator
is applied to all elements of the array. For non-scalar arguments the
function is vectorized according to \cref{vectorized-calls-of-functions}.
\par
\begin{nonnormative*}
For Real parameters and constants the result is a zero scalar or array of the same size as the variable.
\end{nonnormative*}
\\
\hline

\begin{tabular}{@{}p{5.1cm}@{}}

% delay
\lstinline!delay(expr,delayTime,delayMax)!\\
\lstinline!delay(expr,delayTime)!
\end{tabular} &
Returns: \lstinline!expr(time-delayTime)! for \lstinline!time>time.start + delayTime! and \lstinline!expr(time.start)! for \lstinline!time <= time.start + delayTime!. The arguments, i.e., \lstinline!expr!, \lstinline!delayTime! and \lstinline!delayMax!, need to be
subtypes of Real. \lstinline!delayMax! needs to be additionally a parameter
expression. The following relation shall hold: \lstinline!0 <= delayTime <= delayMax!, otherwise an error occurs. If \lstinline!delayMax! is not
supplied in the argument list, \lstinline!delayTime! needs to be a parameter
expression. See also \cref{delay}. For non-scalar arguments the
function is vectorized according to \cref{vectorized-calls-of-functions}.\\
\hline

% cardinality
\lstinline!cardinality(c)! &
\begin{nonnormative*}
This is a deprecated operator. It should no longer be used, since it will be removed in one of the next Modelica releases.
\end{nonnormative*}

Returns the number of (inside and outside) occurrences of connector
instance \lstinline!c! in a connect-equation as an \lstinline!Integer! number. See also \cref{cardinality-deprecated}.\\
\hline

% homotopy
\lstinline!homotopy(actual=actual,!\\
\lstinline!   simplified=simplified)! & The scalar expressions \lstinline!actual! and \lstinline!simplified! are subtypes of
\lstinline!Real!. A Modelica translator should map this operator into either of the two forms:
\begin{enumerate}
\item
  Returns \lstinline!actual! (trivial implementation).
\item
  In order to solve algebraic systems of equations, the operator might
  during the solution process return a combination of the two arguments,
  ending at actual.
  \begin{example}
  \lstinline!actual*lambda + simplified*(1-lambda)!, where \lstinline!lambda! is a homotopy parameter going from 0 to 1.
  \end{example}
  The solution must fulfill the equations for homotopy returning \lstinline!actual!.
\end{enumerate}

See also \cref{homotopy}. For non-scalar arguments the function is
vectorized according to \cref{scalar-functions-applied-to-array-arguments}.\\
\hline

% semiLinear
\begin{tabular}{@{}p{5.1cm}@{}}
\lstinline!semiLinear(x,!\\
\lstinline!  positiveSlope,!\\
\lstinline!  negativeSlope)!\\
\end{tabular}&
Returns:
\lstinline!smooth(0, if x>=0 then positiveSlope*x else negativeSlope*x)!.
The result is of type \lstinline!Real!. See \cref{semilinear} (especially in
the case when $x = 0$). For non-scalar arguments the function is
vectorized according to \cref{vectorized-calls-of-functions}.\\
\hline

% inStream
\lstinline!inStream(v)! & \lstinline!inStream(v)! is only allowed for stream
variables \lstinline!v! defined in stream connectors, and is the value of the stream
variable \lstinline!v! close to the connection point assuming that the flow is from
the connection point into the component. This value is computed from the
stream connection equations of the flow variables and of the stream
variables. The operator is vectorizable. For more details see \cref{stream-operator-instream-and-connection-equations}.\\
\hline

% actualStream
\lstinline!actualStream(v)! & \lstinline!actualStream(v)! returns the actual value
of the stream variable \lstinline!v! for any flow direction. The operator is
vectorizable. For more details, see \cref{stream-operator-actualstream}.\\
\hline

% spatialDistribution
\begin{tabular}{@{}p{5.1cm}@{}}
\lstinline!spatialDistribution(!\\
\lstinline!  in0=in0, in1=in1, x=x,!\\
\lstinline!  positiveVelocity=...,!\\
\lstinline!  initialPoints=...,!\\
\lstinline!  initialValues=...)!
\end{tabular} &
\lstinline!spatialDistribution! allows approximation of variable-speed transport of properties, see \cref{spatialdistribution}.\\
\hline

% getInstanceName
\lstinline!getInstanceName()! & Returns a string with the name of the model/block
that is simulated, appended with the fully qualified name of the
instance in which this function is called, see \cref{getinstancename}.\\
\hline
\end{longtable}

A few of these operators are described in more detail in the following.

\subsubsection{delay}\label{delay}

\begin{nonnormative}
\lstinline!delay! allows a numerical sound
implementation by interpolating in the (internal) integrator
polynomials, as well as a more simple realization by interpolating
linearly in a buffer containing past values of expression expr. Without
further information, the complete time history of the delayed signals
needs to be stored, because the delay time may change during simulation.
To avoid excessive storage requirements and to enhance efficiency, the
maximum allowed delay time has to be given via \lstinline!delayMax!.

This gives an upper bound on the values of the delayed signals
which have to be stored. For real-time simulation where fixed step size
integrators are used, this information is sufficient to allocate the
necessary storage for the internal buffer before the simulation starts.
For variable step size integrators, the buffer size is dynamic during
integration. In principle, \lstinline!delay! could break algebraic
loops. For simplicity, this is not supported because the minimum delay
time has to be give as additional argument to be fixed at compile time.
Furthermore, the maximum step size of the integrator is limited by this
minimum delay time in order to avoid extrapolation in the delay
buffer.
\end{nonnormative}

\subsubsection{spatialDistribution}\label{spatialdistribution}

\begin{nonnormative}
Many applications involve the modelling of variable-speed
transport of properties. One option to model this infinite-dimensional
system is to approximate it by an ODE, but this requires a large number
of state variables and might introduce either numerical diffusion or
numerical oscillations. Another option is to use a built-in operator
that keeps track of the spatial distribution of $z(x, t)$, by suitable
sampling, interpolation, and shifting of the stored distribution. In
this case, the internal state of the operator is hidden from the ODE
solver.
\end{nonnormative}

\lstinline!spatialDistribution! allows to approximate efficiently the solution of the infinite-dimensional problem
\begin{align*}
\frac{\partial z(y,t)}{\partial t}+v(t)\frac{\partial z(y,t)}{\partial y} &= 0.0\\
z(0.0, t) &= \mathrm{in}_0(t) \text{ if $v\ge 0$}\\
z(1.0, t) &= \mathrm{in}_1(t) \text{ if $v<0$}
\end{align*}
where $z(y, t)$ is the transported quantity, $y$ is the
normalized spatial coordinate ($0.0 \le y \le 1.0$), $t$ is the
time, $v(t)=\mathrm{der}(x)$ is the normalized
transport velocity and the boundary conditions are set at either
$y=0.0$ or $y=1.0$, depending on the sign of the velocity.
The calling syntax is:
\begin{lstlisting}[language=modelica]
(out0, out1) = spatialDistribution(in0, in1, x, positiveVelocity,
                                   initialPoints = {0.0, 1.0},
                                   initialValues = {0.0, 0.0});
\end{lstlisting}
where \lstinline!in0!, \lstinline!in1!, \lstinline!out0!, \lstinline!out1!, \lstinline!x!, \lstinline!v! are all subtypes of Real,
\lstinline!positiveVelocity! is a Boolean, \lstinline!initialPoints! and \lstinline!initialValues! are
arrays of subtypes of Real of equal size, containing the y coordinates
and the $z$ values of a finite set of points describing the initial
distribution of $z(y, \mathit{t0})$. The \lstinline!out0! and \lstinline!out1! are given by
the solutions at $z(0.0, t)$ and $z(1.0, t)$; and \lstinline!in0! and \lstinline!in1!
are the boundary conditions at $z(0.0, t)$ and $z(1.0, t)$ (at
each point in time only one of in0 and in1 is used). Elements in the
initialPoints array must be sorted in non-descending order. The operator
can not be vectorized according to the vectorization rules described in
\cref{scalar-functions-applied-to-array-arguments}. The operator can be vectorized only with respect to the
arguments in0 and in1 (which must have the same size), returning
vectorized outputs out0 and out1 of the same size; the arguments
initialPoints and initialValues are vectorized accordingly.

The solution, $z$, can be described in terms of characteristics:
\begin{equation*}
z(y+\int_{t}^{t+\beta} v(\alpha) \mathrm{d}\alpha, t+\beta) = z(y, t),\quad\text{for all $\beta$ as long as staying inside the domain}
\end{equation*}

This allows to directly compute the solution based on interpolating the
boundary conditions.

\lstinline!spatialDistribution! can be described in terms of the pseudo-code given as a block:
\begin{lstlisting}[language=modelica]
block spatialDistribution
  input Real in0;
  input Real in1;
  input Real x;
  input Boolean positiveVelocity;
  parameter Real initialPoints(each min=0, each max=1)[:] = {0.0, 1.0};
  parameter Real initialValues[:] = {0.0, 0.0};
  output Real out0;
  output Real out1;
protected
  Real points[:];
  Real values[:];
  Real x0;
  Integer m;
algorithm
  if positiveVelocity then
    out1:=interpolate(points, values, 1-(x-x0));
    out0:=values[1]; // similar to in0 but avoiding algebraic loop
  else
    out0:=interpolate(points, values, 0-(x-x0));
    out1:=values[end]; // similar to in1 but avoiding algebraic loop
  end if;
  when <acceptedStep> then
    if x>x0 then
      m:=size(points,1);
      while (if m>0 then points[m]+(x-x0)>=1 else false) then
        m:=m-1;
      end while;
      values:=cat(1, {in0}, values[1:m], {interpolate(points, values,1-(x-x0))} );
      points:=cat(1, {0}, points[1:m] .+ (x-x0), {1} );
    elseif x<x0 then
      m:=1;
      while (if m<size(points,1) then points[m]+(x-x0)<=0 else false) then
        m:=m+1;
      end while;
      values:=cat(1, {interpolate(points, values, 0-(x-x0))},values[m:end],{in1});
      points:=cat(1, {0}, points[m:end] .+ (x-x0), {1});
    end if;
    x0:=x;
  end when;
initial algorithm
  x0:=x;
  points:=initialPoints;
  values:=initialValues;
end spatialDistribution;
\end{lstlisting}

\begin{nonnormative}
Note that the implementation has an internal state and thus
cannot be described as a function in Modelica; initialPoints and
initialValues are declared as parameters to indicate that they are only
used during initialization.

The infinite-dimensional problem stated above can then be formulated in the following way:
\begin{lstlisting}[language=modelica]
der(x) = v;
(out0, out1) = spatialDistribution(in0, in1, x,v >=0, initialPoints, initialValues);
\end{lstlisting}

Events are generated at the exact instants when the velocity
changes sign -- if this is not needed, \lstinline!noEvent! can be used to
suppress event generation.

If the velocity is known to be always positive, then \lstinline!out0! can be omitted, e.g.:
\begin{lstlisting}[language=modelica]
der(x) = v;
(,out1) = spatialDistribution(in0, 0, x, true, initialPoints, initialValues);
\end{lstlisting}
Technically relevant use cases for the use of
\lstinline!spatialDistribution! are modeling of electrical
transmission lines, pipelines and pipeline networks for gas, water and
district heating, sprinkler systems, impulse propagation in elongated
bodies, conveyor belts, and hydraulic systems. Vectorization is needed
for pipelines where more than one quantity is transported with velocity
v in the example above.
\end{nonnormative}

\subsubsection{cardinality (deprecated)}\label{cardinality-deprecated}

\begin{nonnormative}
\lstinline!cardinality! is deprecated for the following reasons and will be removed in a future release:
\begin{itemize}
\item
  Reflective operator may make early type checking more difficult.
\item
  Almost always abused in strange ways
\item
  Not used for Bond graphs even though it was originally introduced for that purpose.
\end{itemize}
\end{nonnormative}

\begin{nonnormative}
\lstinline!cardinality! allows the definition of connection dependent equations in a model, for example:
\begin{lstlisting}[language=modelica]
connector Pin
  Real v;
  flow Real i;
end Pin;
model Resistor
  Pin p, n;
equation
  assert(cardinality(p) > 0 and cardinality(n) > 0, "Connectors p and n of Resistor must be connected");
  // Equations of resistor
  ...
end Resistor;
\end{lstlisting}
\end{nonnormative}

The cardinality is counted after removing conditional components, and may not be applied to expandable connectors, elements in expandable connectors, or to arrays of connectors (but can be applied to
the scalar elements of array of connectors).  \lstinline!cardinality! should only be used in the condition of assert and if-statements that do not contain \lstinline!connect! and similar operators,
see \cref{clocked-discrete-time-and-clocked-discretized-continuous-time-partition}).

\subsubsection{homotopy}\label{homotopy}

\begin{nonnormative}
During the initialization phase of a dynamic simulation
problem, it often happens that large nonlinear systems of equations must
be solved by means of an iterative solver. The convergence of such
solvers critically depends on the choice of initial guesses for the
unknown variables. The process can be made more robust by providing an
alternative, simplified version of the model, such that convergence is
possible even without accurate initial guess values, and then by
continuously transforming the simplified model into the actual model.
This transformation can be formulated using expressions of this kind:

$$\lambda\cdot\text{actual} + (1-\lambda)\cdot\text{simplified}$$

in the formulation of the system equations, and is usually called
a homotopy transformation. If the simplified expression is chosen
carefully, the solution of the problem changes continuously with $\lambda$,
so by taking small enough steps it is possible to eventually obtain the
solution of the actual problem.

The operator can be called with ordered arguments or preferably
with named arguments for improved readability.

It is recommended to perform (conceptually) one homotopy iteration
over the whole model, and not several homotopy iterations over the
respective non-linear algebraic equation systems. The reason is that the
following structure can be present:
\begin{lstlisting}[language=modelica]
w = $f_1$(x) // has homotopy
0 = $f_2$(der(x), x, z, w)
\end{lstlisting}

Here, a non-linear equation system $f_2$
is present. \lstinline!homotopy! is, however used on a variable
that is an ``input'' to the non-linear algebraic equation system, and
modifies the characteristics of the non-linear algebraic equation
system. The only useful way is to perform the homotopy iteration over
$f_1$ and $f_2$ together.

The suggested approach is ``conceptual'', because more efficient
implementations are possible, e.g.\ by determining the smallest iteration
loop, that contains the equations of the first BLT block in which
\lstinline!homotopy! is present and all equations up to the last BLT block
that describes a non-linear algebraic equation system.

A trivial implementation of \lstinline!homotopy! is obtained by
defining the following function in the global scope:
\begin{lstlisting}[language=modelica]
function homotopy
  input Real actual;
  input Real simplified;
  output Real y;
algorithm
  y := actual;
  annotation(Inline = true);
end homotopy;
\end{lstlisting}
\end{nonnormative}

\begin{example}[1] In electrical systems it is often difficult to solve non-linear
algebraic equations if switches are part of the algebraic loop. An
idealized diode model might be implemented in the following way, by
starting with a ``flat'' diode characteristic and then move with
\lstinline!homotopy! to the desired ``steep'' characteristic:
\begin{lstlisting}[language=modelica]
model IdealDiode
  ...
  parameter Real Goff = 1e-5;
protected
  Real Goff_flat = max(0.01, Goff);
  Real Goff2;
equation
  off = s < 0;
  Goff2 = homotopy(actual=Goff, simplified=Goff_flat);
  u = s*(if off then 1 else Ron2) + Vknee;
  i = s*(if off then Goff2 else 1 ) + Goff2*Vknee;
  ...
end IdealDiode;
\end{lstlisting}
\end{example}

\begin{example}[2] In electrical systems it is often useful that all voltage sources
start with zero voltage and all current sources with zero current, since
steady state initialization with zero sources can be easily obtained. A
typical voltage source would then be defined as:
\begin{lstlisting}[language=modelica]
model ConstantVoltageSource
  extends Modelica.Electrical.Analog.Interfaces.OnePort;
  parameter Modelica.Units.SI.Voltage V;
equation
  v = homotopy(actual=V, simplified=0.0);
end ConstantVoltageSource;
\end{lstlisting}
\end{example}

\begin{example}[3] In fluid system modelling, the pressure/flowrate relationships are
highly nonlinear due to the quadratic terms and due to the dependency on
fluid properties. A simplified linear model, tuned on the nominal
operating point, can be used to make the overall model less nonlinear
and thus easier to solve without accurate start values. Named arguments
are used here in order to further improve the readability.
\begin{lstlisting}[language=modelica]
model PressureLoss
  import Modelica.Units.SI;
  ...
  parameter SI.MassFlowRate m_flow_nominal "Nominal mass flow rate";
  parameter SI.Pressure dp_nominal "Nominal pressure drop";
  SI.Density rho "Upstream density";
  SI.DynamicViscosity lambda "Upstream viscosity";
equation
  ...
  m_flow = homotopy(actual = turbulentFlow_dp(dp, rho, lambda),
  simplified = dp/dp_nominal*m_flow_nominal);
  ...
end PressureLoss;
\end{lstlisting}
\end{example}

\begin{example}[4] Note that \lstinline!homotopy! \emph{shall not} be used to
combine unrelated expressions, since this can generate singular systems
from combining two well-defined systems.
\begin{lstlisting}[language=modelica]
model DoNotUse
  Real x;
  parameter Real x0 = 0;
equation
  der(x) = 1-x;
initial equation
  0 = homotopy(der(x), x - x0);
end DoNotUse;
\end{lstlisting}

The initial equation is expanded into
$$ 0 = \lambda*\mathrm{der}(x)+(1-\lambda)(x-x_0)$$
and you can solve the two equations to give
$$ x=\frac{\lambda+(\lambda-1)x_0}{2\lambda-1}$$
which has the correct value of $x_0$ at $\lambda = 0$ and of 1 at $\lambda= 1$, but unfortunately has a singularity at $\lambda = 0.5 $.
\end{example}


\subsubsection{semiLinear}\label{semilinear}

(See definition of \lstinline!semiLinear! in \cref{derivative-and-special-purpose-operators-with-function-syntax}). In some situations,
equations with \lstinline!semiLinear! become underdetermined if the
first argument (\lstinline!x!) becomes zero, i.e., there are an infinite number of
solutions. It is recommended that the following rules are used to
transform the equations during the translation phase in order to select
one meaningful solution in such cases:
\begin{itemize}
\item
The equations
\begin{lstlisting}[language=modelica]
y = semiLinear(x, sa, s1);
y = semiLinear(x, s1, s2);
y = semiLinear(x, s2, s3);
...
y = semiLinear(x, sN, sb);
...
\end{lstlisting}
may be replaced by
\begin{lstlisting}[language=modelica]
s1 = if x >= 0 then sa else sb
s2 = s1;
s3 = s2;
...
$s_N = s_{N-1}$;
y = semiLinear(x, sa, sb);
\end{lstlisting}

\item
The equations
\begin{lstlisting}[language=modelica]
x = 0;
y = 0;
y = semiLinear(x, sa, sb);
\end{lstlisting}
may be replaced by
\begin{lstlisting}[language=modelica]
x = 0
y = 0;
sa = sb;
\end{lstlisting}
\end{itemize}

\begin{nonnormative}
For symbolic transformations, the following property is useful
(this follows from the definition):
\begin{lstlisting}[language=modelica]
semiLinear(m_flow, port_h, h);
\end{lstlisting}
is identical to:
\begin{lstlisting}[language=modelica]
-semiLinear(-m_flow, h, port_h);
\end{lstlisting}

The \lstinline!semiLinear! function is designed to handle reversing
flow in fluid systems, such as
\begin{lstlisting}[language=modelica]
H_flow =semiLinear(m_flow, port.h, h);
\end{lstlisting}
i.e., the enthalpy flow rate \lstinline!H_flow! is computed from the
mass flow rate \lstinline!m_flow! and the upstream specific enthalpy
depending on the flow direction.
\end{nonnormative}

\subsubsection{getInstanceName}\label{getinstancename}

Returns a string with the name of the model/block that is simulated,
appended with the fully qualified name of the instance in which this
function is called.

\begin{example}
\begin{lstlisting}[language=modelica]
package MyLib
  model Vehicle
    Engine engine;
    ...
  end Vehicle;
  model Engine
    Controller controller;
    ...
  end Engine;
  model Controller
  equation
    Modelica.Utilities.Streams.print("Info from: " + getInstanceName());
  end Controller;
end MyLib;
\end{lstlisting}
If \lstinline!MyLib.Vehicle! is simulated, the call of \lstinline!getInstanceName()!
returns \lstinline!"Vehicle.engine.controller"!.
\end{example}

If this function is not called inside a model or block (e.g.\ the
function is called in a function or in a constant of a package), the
return value is not specified.

\begin{nonnormative}
The simulation result should not depend on the return value of this function.
\end{nonnormative}

\subsection{Event-Related Operators with Function Syntax}\label{event-related-operators-with-function-syntax}

The following event-related operators with function syntax are
supported. The operators \lstinline!noEvent!, \lstinline!pre!, \lstinline!edge!, and \lstinline!change!, are
vectorizable according to \cref{scalar-functions-applied-to-array-arguments}

\begin{longtable}{|p{5cm}|p{8cm}|}
\hline \endhead

% initial
\lstinline!initial()! & Returns \lstinline!true! during the initialization phase and \lstinline!false!
otherwise.
\par
\begin{nonnormative*}
Hereby, \lstinline!initial()! triggers a time event at the beginning of a simulation.
\end{nonnormative*}
\\ \hline

% terminal
\lstinline!terminal()! & Returns \lstinline!true! at the end of a successful analysis.
\par
\begin{nonnormative*}
Hereby, \lstinline!terminal()! ensures an event at the end of successful simulation.
\end{nonnormative*}
\\ \hline

% noEvent
\lstinline!noEvent(expr)! & Real elementary relations within \lstinline!expr! are taken literally, i.e., no state or time event is triggered. See also \cref{noevent-and-smooth} and \cref{events-and-synchronization}.\\ \hline

% smooth
\lstinline!smooth(p, expr)! & If $p>=0$ \lstinline!smooth(p,expr)!
returns \lstinline!expr! and states that \lstinline!expr! is \lstinline!p! times continuously
differentiable, i.e.: \lstinline!expr! is continuous in all real variables appearing
in the expression and all partial derivatives with respect to all
appearing real variables exist and are continuous up to order
\lstinline!p!. The argument \lstinline!p! should be a scalar integer parameter
expression. The only allowed types for \lstinline!expr! in \lstinline!smooth! are: real
expressions, arrays of allowed expressions, and records containing only
components of allowed expressions. See also \cref{noevent-and-smooth}.\\ \hline

% sample
\lstinline!sample(start, interval)! & Returns \lstinline!true! and triggers time events at time
instants \lstinline!start + i*interval (i=0,1,...)!, and is only true during the first event iteration at those times.
At event iterations after the first one at each event and during continuous integration
the operator always returns \lstinline!false!. The starting time \lstinline!start! and the
sample interval \lstinline!interval! must be parameter expressions and need to be
a subtype of Real or Integer. The sample interval \lstinline!interval! must be a
positive number.\\ \hline

% pre
\lstinline!pre(y)! & Returns the \emph{left limit} $y(t^{-})$ of
variable $y(t)$ at a time instant $t$.  At an event instant,
$y(t^{-})$ is the value of $y$ after the last event
iteration at time instant $t$ (see comment below).
Any subscripts in the component expression $y$ must be parameter expressions.
\lstinline!pre! can be applied if the following three conditions are fulfilled
simultaneously: (a) variable $y$ is either a subtype of a simple type or
is a record component, (b) $y$ is a discrete-time expression (c) the
operator is \emph{not} applied in a function class.
\begin{nonnormative}
This can be applied to continuous-time variables in when-clauses, see \cref{discrete-time-expressions} for the definition of discrete-time expression.
\end{nonnormative}
The first value of \lstinline!pre(y)! is determined in the initialization phase. See
also \cref{pre}.\\ \hline

% edge
\lstinline!edge(b)! & Is expanded into \lstinline!(b and not pre(b))! for Boolean variable
\lstinline!b!. The same restrictions as for \lstinline!pre! apply (e.g.\ not to be
used in function classes).\\ \hline

% change
\lstinline!change(v)! & Is expanded into \lstinline!(v<>pre(v))!. The same restrictions as for \lstinline!pre! apply.\\ \hline

% reinit
\lstinline!reinit(x, expr)! & In the body of a when clause, reinitializes \lstinline!x! with
\lstinline!expr! at an event instant. \lstinline!x! is a scalar or array \lstinline!Real! variable that is implicitly defined to have \lstinline!StateSelect.always!.
\begin{nonnormative}
It is an error if the variable cannot be selected as a state.
\end{nonnormative}
\lstinline!expr! needs to be type-compatible with \lstinline!x!.
\lstinline!reinit! can only be applied once for the same variable -- either
as an individual variable or as part of an array of variables. It can
only be applied in the body of a when clause in an equation section. See
also \cref{reinit}.\\ \hline
\end{longtable}

A few of these operators are described in more detail in the following.

\subsubsection{pre}\label{pre}

A new event is triggered if there is at least for one variable \lstinline!v! such that \lstinline!pre(v)<> v! after the active model equations are
evaluated at an event instant. In this case the model is at once
reevaluated. This evaluation sequence is called \emph{event
iteration}. The integration is restarted, if for all \lstinline!v! used in
pre-operators the following condition holds: \lstinline!pre(v) == v!.

\begin{nonnormative}
If \lstinline!v! and \lstinline!pre(v)! are only used in when-clauses,
the translator might mask event iteration for variable v since v cannot
change during event iteration. It is a \emph{quality of implementation} to
find the minimal loops for event iteration, i.e., not all parts of the
model need to be reevaluated.

The language allows mixed algebraic systems of equations where the
unknown variables are of type \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, or an enumeration.
These systems of equations can be solved by a global fix point iteration
scheme, similarly to the event iteration, by fixing the \lstinline!Boolean!,
\lstinline!Integer!, and/or enumeration unknowns during one iteration. Again, it is
a quality of implementation to solve these systems more efficiently,
e.g., by applying the fix point iteration scheme to a subset of the
model equations.
\end{nonnormative}

\subsubsection{noEvent and smooth}\label{noevent-and-smooth}

\lstinline!noEvent! implies that real elementary relations/functions
are taken literally instead of generating crossing functions, \cref{events-and-synchronization}.
\lstinline!smooth! should be used instead of \lstinline!noEvent!, in order to
avoid events for efficiency reasons. A tool is free to not generate
events for expressions inside \lstinline!smooth!. However, \lstinline!smooth! does not guarantee
that no events will be generated, and thus it can be necessary to use
\lstinline!noEvent! inside \lstinline!smooth!.

\begin{nonnormative}
Note that \lstinline!smooth! does not guarantee a smooth output if any of the occurring variables change discontinuously.
\end{nonnormative}

\begin{example}
\begin{lstlisting}[language=modelica]
  Real x,y,z;
  parameter Real p;
equation
  x = if time<1 then 2 else time-2;
  z = smooth(0, if time<0 then 0 else time);
  y = smooth(1, noEvent(if x<0 then 0 else sqrt(x)*x));
  // noEvent is necessary.
\end{lstlisting}
\end{example}

\section{Variability of Expressions}\label{variability-of-expressions}

The concept of variability of an expression indicates to what extent the
expression can vary over time. See also \cref{component-variability-prefixes-discrete-parameter-constant} regarding the
concept of variability. There are four levels of variability of
expressions, starting from the least variable:
\begin{itemize}
\item
  constant variability
\item
  parameter variability
\item
  discrete-time variability
\item
  continuous-time variability
\end{itemize}

While many invalid models can be rejected based on the declared variabilities of variables alone (without the concept of expression
variability), the following rules both help enforcing compliance of computed solutions to declared variability, and impose additional
restrictions that simplify reasoning and reporting of errors:
\begin{itemize}
\item
  For an assignment \lstinline!v:=expr! or binding equation \lstinline!v=expr!, \lstinline!v! must be declared
  to be at least as variable as \lstinline!expr!.
\item
  When determining whether an equation can contribute to solving for a variable \lstinline!v! (for instance,
  when applying the perfect matching rule, see \cref{synchronous-data-flow-principle-and-single-assignment-rule}),
  the equation can only be considered contributing if the resulting solution would be at most as variable as \lstinline!v!.
\item
  The right-hand side expression in a binding equation (that is, \lstinline!expr!) of a parameter component and of the base type attributes
  (such as \lstinline!start!) needs to be a parameter or constant expression.
\item
  If \lstinline!v! is a discrete-time component then \lstinline!expr! needs to be a
  discrete-time expression.
\end{itemize}

\subsection{Constant Expressions}\label{constant-expressions}

Constant expressions are:
\begin{itemize}
\item
  \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, \lstinline!String!, and \lstinline!enumeration! literals.
\item
  Variables declared as constant.
\item
  Except for the special built-in operators \lstinline!initial!, \lstinline!terminal!, \lstinline!der!,
  \lstinline!edge!, \lstinline!change!, \lstinline!sample!, and \lstinline!pre!, a function or operator with constant
  subexpressions as argument (and no parameters defined in the function)
  is a constant expression.
\item
  Some function calls are constant expressions regardless of the arguments:
  \begin{itemize}
  \item
    \lstinline!ndims(A)!
  \end{itemize}
\end{itemize}

Components declared as constant shall have an associated declaration
equation with a constant expression, if the constant is directly in the
simulation model, or used in the simulation model. The value of a
constant can be modified after it has been given a value, unless the
constant is declared final or modified with a final modifier. A constant
without an associated declaration equation can be given one by using a
modifier.

\subsection{Parameter Expressions}\label{parameter-expressions}

Parameter expressions are:
\begin{itemize}
\item
  Constant expressions.
\item
  Variables declared as parameter.
\item
  Input variables in functions behave as though they were parameter expressions.
\item
  Except for the special built-in operators \lstinline!initial!, \lstinline!terminal!, \lstinline!der!,
  \lstinline!edge!, \lstinline!change!, \lstinline!sample!, and \lstinline!pre!, a function or operator with parameter
  subexpressions is a parameter expression.
\item
  Some function calls are parameter expressions even if the arguments are not:
  \begin{itemize}
  \item
    \lstinline!cardinality(c)!, see restrictions for use in \cref{cardinality-deprecated}.
  \item
    \lstinline!end! in \lstinline!A[$\ldots$ end $\ldots$]! if \lstinline!A! is variable declared in a non-function class.
  \item
    \lstinline!size(A)! (including \lstinline!size(A, j)! where \lstinline!j! is parameter expression) if \lstinline!A! is variable declared in a non-function class.
  \item
    \lstinline!Connections.isRoot(A.R)!
  \item
    \lstinline!Connections.rooted(A.R)!
  \end{itemize}
\end{itemize}

\subsection{Discrete-Time Expressions}\label{discrete-time-expressions}

Discrete-time expressions are:
\begin{itemize}
\item
  Parameter expressions.
\item
  Discrete-time variables, i.e., \lstinline!Integer!, \lstinline!Boolean!, \lstinline!String! variables and
  \lstinline!enumeration! variables, as well as \lstinline!Real! variables assigned in
  \lstinline!when!-clauses
\item
  Function calls where all input arguments of the function are
  discrete-time expressions.
\item
  Expressions where all the subexpressions are discrete-time
  expressions.
\item
  Expressions in the body of a \lstinline!when!-clause, \lstinline!initial equation!, or \lstinline!initial algorithm!.
\item
  Unless inside \lstinline!noEvent!: Ordered relations (\lstinline!>!, \lstinline!<!, \lstinline!>=!, \lstinline!<=!) and the event
  generating functions \lstinline!ceil!, \lstinline!floor!, \lstinline!div!, and \lstinline!integer!, if at least one
  argument is non-discrete time expression and subtype of \lstinline!Real!.
  \begin{nonnormative}
  These will generate events, see \cref{events-and-synchronization}.  Note that \lstinline!rem! and \lstinline!mod! generate events but are not discrete-time
  expressions. In other words, relations inside \lstinline!noEvent!, such as \lstinline!noEvent(x>1)!, are not discrete-time expressions.
  \end{nonnormative}
\item
  The functions \lstinline!pre!, \lstinline!edge!, and \lstinline!change! result in discrete-time
  expressions.
\item
  Expressions in functions behave as though they were discrete-time
  expressions.
\end{itemize}

For an equation \lstinline!expr1 = expr2! where neither expression is of base type
\lstinline!Real!, both expressions must be discrete-time expressions. For record
equations the equation is split into basic types before applying this
test.

\begin{nonnormative}
This restriction guarantees that \lstinline!noEvent! cannot be applied to \lstinline!Boolean!, \lstinline!Integer!, \lstinline!String!, or \lstinline!enumeration!
equations outside of a \lstinline!when!-clause, because then one of the two expressions is not discrete-time.
\end{nonnormative}

Inside an if-expression, \lstinline!if!-clause, \lstinline!while!-statement or \lstinline!for!-clause, that
is controlled by a non-discrete-time (that is continuous-time, but not
discrete-time) switching expression and not in the body of a
\lstinline!when!-clause, it is not legal to have assignments to discrete-time variables,
equations between discrete-time expressions, or real elementary
relations/functions that should generate events.

\begin{nonnormative}
The restriction above is necessary in order to guarantee that all equations for discrete-time variable are discrete-time expressions, and to ensure that crossing
functions do not become active between events.
\end{nonnormative}

\begin{example}
The (underdetermined) model \lstinline!Test! below illustrates two kinds of consequences due to variability constraints.
First, it contains variability errors for declaration equations and assignments.
Second, it illustrates the impact of variability on the matching of equations to variables, which can
lead to violation of the perfect matching rule.
\begin{lstlisting}[language=modelica]
model Constants
  parameter Real p1 = 1;
  constant Real c1 = p1 + 2; // error, not a constant expression
  parameter Real p2 = p1 + 2; // fine
end Constants;
model Test
  Constants c1(p1=3); // fine
  Constants c2(p2=7); // fine, declaration equation can be modified
  Real x;
  Boolean b1 = noEvent(x > 1); // error, since b1 is a discrete-time variable
                               // and noEvent(x > 1) is not discrete-time.
  Boolean b2;
  Integer i1;
  Integer i2;
algorithm
  i1 := x; // error, assignment to variable of lesser variability.
equation
  b2 = noEvent(x > 1); // no variability error, but equation cannot be matched.
  i2 = x;              // no variability error, and can be matched to x.
end Test;
\end{lstlisting}
\end{example}

\subsection{Continuous-Time Expressions}\label{continuous-time-expressions}

All expressions are continuous-time expressions including constant,
parameter and discrete expressions. The term \emph{non-discrete-time
expression} refers to expressions that are not constant, parameter or
discrete expressions.
