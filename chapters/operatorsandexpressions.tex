\chapter{Operators and Expressions}\label{operators-and-expressions}

The lexical units are combined to form even larger building blocks such as \firstuse[expression]{expressions} according to the rules given by the \lstinline[language=grammar]!expression! part of the Modelica grammar in \cref{modelica-concrete-syntax}.
For example, they can be built from operators, function references, components, or component references (referring to components) and literals.
Each expression has a type and a variability.

This chapter describes the evaluation rules for expressions, the concept of expression variability, built-in mathematical operators and functions, and the built-in special Modelica operators with function syntax.

Expressions can contain variables and constants, which have types, predefined or user defined.
The predefined built-in types of Modelica are \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, \lstinline!String!, and enumeration types which are presented in more detail in \cref{predefined-types-and-classes}.

\section{Expressions}\label{expressions}

Modelica equations, assignments and declaration equations contain expressions.

Expressions can contain basic operations, \lstinline!+!, \lstinline!-!, \lstinline!*!, \lstinline!/!, \lstinline!^!, etc.\ with normal precedence as defined in \cref{tab:operator-precedence} in \cref{operator-precedence-and-associativity} and the grammar in \cref{modelica-concrete-syntax}.
The semantics of the operations is defined for both scalar and array arguments in \cref{scalar-vector-matrix-and-array-operator-functions}.

It is also possible to define functions and call them in a normal fashion.
The function call syntax for both positional and named arguments is described in \cref{positional-or-named-input-arguments-of-functions} and for vectorized calls in \cref{initialization-and-binding-equations-of-components-in-functions}.
The built-in array functions are given in \cref{array-dimension-lower-and-upper-index-bounds} and other built-in operators in \cref{built-in-intrinsic-operators-with-function-syntax}.

\section{Operator Precedence and Associativity}\label{operator-precedence-and-associativity}

Operator precedence determines the order of evaluation of operators in an expression.
An operator with higher precedence is evaluated before an operator with lower precedence in the same expression.

The following table presents all the expression operators in order of precedence.
\begin{table}[H]
\caption{%
Operators in order of precedence from highest to lowest, as derived from the Modelica grammar in \cref{modelica-concrete-syntax}.
All operators are binary except the postfix operators and those shown as unary together with \emph{expr}, the conditional operator, the array construction operator
% Beware that the array construction operator, normally expressed as \lstinline!{ }! needs escaped braces inside \caption.
% This isn't handled correctly by LaTeXML, as reported here:
% - https://github.com/brucemiller/LaTeXML/issues/1377
\ifpdf
\lstinline!\{ \}! % Intentional space at end of line.
\else
\lstinline!{ }! % Intentional space at end of line.
\fi
and concatenation operator \lstinline![ ]!, and the array range constructor which is either binary or ternary.
Operators with the same precedence occur at the same table row.
}\label{tab:operator-precedence}
\begin{center}
\begin{tabular}{l l l}
\hline
\tablehead{Operator group} & \tablehead{Operator syntax} & \tablehead{Examples}\\
\hline
\hline
Postfix array index operator & \lstinline![]! & \lstinline!arr[index]!\\
\hline
Postfix access operator & \lstinline!.! & \lstinline!a.b!\\
\hline
Postfix function call & \lstinline!$\mathit{funcName}$($\mathit{functionArguments}$)! & \lstinline!sin(4.36)!\\
\hline
Array construction & \lstinline!{$\mathit{expressions}$}! & \lstinline!{2, 3}!\\
Horizontal concatenation & \lstinline![$\mathit{expressions}$]! & \lstinline![5, 6]!\\
Vertical concatenation & \lstinline![$\mathit{expressions}$; $\mathit{expressions}\ldots$]! & \lstinline![2, 3; 7, 8]!\\
\hline
Exponentiation & \ \lstinline!^! & \lstinline!2 ^ 3!\\
\hline
Multiplicative  & \lstinline!* /! & \lstinline!2 * 3!, \lstinline!2 / 3!\\
Elementwise multiplicative & \lstinline!.* ./! & \lstinline![1, 2; 3, 4] .* [2, 3; 5, 6]!\\
\hline
Additive & \lstinline!+ -! & \lstinline!1 + 2!\\
Additive unary & \lstinline!+$\mathit{expr}$ -$\mathit{expr}$! & \lstinline!-0.5!\\
Array elementwise additive & \lstinline!.+ .-! & \lstinline![1, 2; 3, 4] .+ [2, 3; 5, 6]!\\
\hline
Relational & \lstinline!< <= > >= == <>! & \lstinline!a < b!, \lstinline!a <= b!, \lstinline!a > b!, \ldots\\
\hline
Unary negation & \lstinline!not $\mathit{expr}$! & \lstinline!not b1!\\
\hline
Logical and & \lstinline!and! & \lstinline!b1 and b2!\\
\hline
Logical or & \lstinline!or! & \lstinline!b1 or b2!\\
\hline
\multirow{2}{*}{Array range} & \lstinline!$\mathit{expr}$ : $\mathit{expr}$! & \lstinline!1 : 5!\\
                             & \lstinline!$\mathit{expr}$ : $\mathit{expr}$ : $\mathit{expr}$! & \lstinline!start : step : stop!\\
\hline
Conditional & \lstinline!if $\mathit{expr}$ then $\mathit{expr}$ else $\mathit{expr}$! & \lstinline!if b then 3 else x!\\
\hline
Named argument & \lstinline!$\mathit{ident}$ = $\mathit{expr}$! & \lstinline!x = 2.26!\\
\hline
\end{tabular}
\end{center}
\end{table}

The conditional operator may also include \lstinline!elseif!-branches.
Equality \lstinline!=! and assignment \lstinline!:=! are not expression operators since they are allowed only in equations and in assignment statements respectively.
All binary expression operators are left associative, except exponentiation which is non-associative.
The array range operator is non-associative.

\begin{nonnormative}
The unary minus and plus in Modelica is slightly different than in Mathematica\footnote{\emph{Mathematica} is a registered trademark of Wolfram Research Inc.} and in MATLAB\footnote{\emph{MATLAB} is a registered trademark of MathWorks Inc.}, since the following expressions are illegal (whereas in Mathematica and in MATLAB these are valid expressions):
\begin{lstlisting}[language=modelica]
2*$\hspace{0pt}$-2 // = -4 in Mathematica/MATLAB; is illegal in Modelica
-$\hspace{0pt}$-2  // = 2 in Mathematica/MATLAB; is illegal in Modelica
+$\hspace{0pt}$+2  // = 2 in Mathematica/MATLAB; is illegal in Modelica
2-$\hspace{0pt}$-2 // = 4 in Mathematica/MATLAB; is illegal in Modelica
\end{lstlisting}
% Using $\hspace{0pt}$ to work around https://github.com/brucemiller/LaTeXML/issues/1399

Non-associative exponentiation and array range operator (note that the array range operator only takes scalar operands):
\begin{lstlisting}[language=modelica]
x ^ y ^ z     // Not legal, use parentheses to make it clear.
a : b : c : d // Not legal, and parentheses cannot make it legal.
\end{lstlisting}
\end{nonnormative}

\section{Evaluation Order}\label{evaluation-order}

A tool is free to solve equations, reorder expressions and to not evaluate expressions if their values do not influence the result (e.g.\ short-circuit evaluation of \lstinline!Boolean! expressions).
\lstinline!if!-statements and \lstinline!if!-expressions guarantee that their branches are only evaluated if the appropriate condition is true, but relational operators generating state or time events will during continuous integration have the value from the most recent event.

If a numeric operation overflows the result is undefined.
For literals it is recommended to automatically convert the number to another type with greater precision.

\begin{example}
If one wants to guard an expression against incorrect evaluation, it should be guarded by an \lstinline!if!:
\begin{lstlisting}[language=modelica]
  Boolean v[n];
  Boolean b;
  Integer I;
equation
  b = (I >= 1 and I <= n) and v[I];                // Invalid
  b = if (I >= 1 and I <= n) then v[I] else false; // Correct
\end{lstlisting}

To guard square against square root of negative number use \lstinline!noEvent!:
\begin{lstlisting}[language=modelica]
der(h) = if h > 0 then -c * sqrt(h) else 0;          // Incorrect
der(h) = if noEvent(h > 0) then -c * sqrt(h) else 0; // Correct
\end{lstlisting}
\end{example}

\section{Arithmetic Operators}\label{arithmetic-operators}

Modelica supports five binary arithmetic operators that operate on any numerical type:
\begin{center}
\begin{tabular}{c|l}
\tablehead{Operator} & \tablehead{Description} \\
\hline
\hline
\lstinline!^! & Exponentiation\\
\lstinline!*! & Multiplication\\
\lstinline!/! & Division\\
\lstinline!+! & Addition\\
\lstinline!-! & Subtraction\\
\hline
\end{tabular}
\end{center}

Some of these operators can also be applied to a combination of a scalar type and an array type, see \cref{scalar-vector-matrix-and-array-operator-functions}.

The syntax of these operators is defined by the following rules from the Modelica grammar:
\begin{lstlisting}[language=grammar]
arithmetic-expression :
   [ add-operator ] term { add-operator term }

add-operator :
   "+" | "-"

term :
   factor { mul-operator factor }

mul-operator :
   "*" | "/"

factor :
   primary [ "^" primary ]
\end{lstlisting}

\section{Equality, Relational, and Logical Operators}\label{equality-relational-and-logical-operators}

Modelica supports the standard set of relational and logical operators, all of which produce the standard boolean values \lstinline!true! or \lstinline!false!:
\begin{center}
\begin{tabular}{c|l}
\tablehead{Operator} & \tablehead{Description} \\
\hline
\hline
\lstinline!>! & Greater than\\
\lstinline!>=! & Greater than or equal\\
\lstinline!<! & Less than\\
\lstinline!<=! & Less than or equal to\\
\lstinline!==! & Equality within expressions\\
\lstinline!<>! & Inequality\\
\hline
\end{tabular}
\end{center}

A single equals sign \lstinline!=! is never used in relational expressions, only in equations (\cref{equations}, \cref{equality-and-assignment}) and in function calls using named parameter passing (\cref{positional-or-named-input-arguments-of-functions}).

The following logical operators are defined:
\begin{center}
\begin{tabular}{c|l}
\tablehead{Operator} & \tablehead{Description} \\
\hline
\hline
\lstinline!not!\indexinline{not} & Logical negation (unary operator)\\
\lstinline!and!\indexinline{and} & Logical \emph{and} (conjunction)\\
\lstinline!or!\indexinline{or} & Logical \emph{or} (disjunction)\\
\hline
\end{tabular}
\end{center}

The grammar rules define the syntax of the relational and logical operators.
\begin{lstlisting}[language=grammar]
logical-expression :
   logical-term { or logical-term }

logical-term :
   logical-factor { and logical-factor }

logical-factor :
   [ not ] relation

relation :
   arithmetic-expression [ relational-operator arithmetic-expression ]

relational-operator :
   "<" | "<=" | ">" | ">=" | "==" | "<>"
\end{lstlisting}

The following holds for relational operators:
\begin{itemize}
\item
  Relational operators \lstinline!<!, \lstinline!<=!,\lstinline!>!, \lstinline!>=!, \lstinline!==!, \lstinline!<>!, are only defined for scalar operands of simple types.
  The result is \lstinline!Boolean! and is true or false if the relation is fulfilled or not, respectively.
\item
  For operands of type \lstinline!String!, \lstinline!str1 $\mathit{op}$ str2! is for each relational operator, $\mathit{op}$, defined in terms of the C function \lstinline[language=C]!strcmp! as \lstinline[language=C]!strcmp(str1, str2) $\mathit{op}$ 0!.
\item
  For operands of type \lstinline!Boolean!, \lstinline!false < true!.
\item
  For operands of enumeration types, the order is given by the order of declaration of the enumeration literals.
\item
  In relations of the form \lstinline!v1 == v2 or v1 <> v2!, \lstinline!v1! or \lstinline!v2! shall, unless used in a function, not be a subtype of \lstinline!Real!.
  \begin{nonnormative}
  The reason for this rule is that relations with \lstinline!Real! arguments are transformed to state events (see \cref{events-and-synchronization}) and this transformation becomes unnecessarily complicated for the \lstinline!==! and \lstinline!<>! relational operators (e.g.\ two crossing functions instead of one crossing function needed, epsilon strategy needed even at event instants).
  Furthermore, testing on equality of \lstinline!Real! variables is questionable on machines where the number length in registers is different to number length in main memory.
  \end{nonnormative}
\item
  Relational operators can generate events, see \cref{discrete-time-expressions}.
\end{itemize}

\section{Miscellaneous Operators and Variables}\label{miscellaneous-operators-and-variables}

Modelica also contains a few built-in operators which are not standard arithmetic, relational, or logical operators.
These are described below, including \lstinline!time!, which is a built-in variable, not an operator.

\subsection{String Concatenation}\label{string-concatenation}

Concatenation of strings (see the Modelica grammar) is denoted by the \lstinline!+! operator in Modelica.

\begin{example}
\lstinline!"a" + "b"! becomes \lstinline!"ab"!.
\end{example}

\subsection{Array Constructor Operator}\label{array-constructor-operator}

The array constructor operator \lstinline!{ $\ldots$ }! is described in \cref{vector-matrix-and-array-constructors}.

\subsection{Array Concatenation Operator}\label{array-concatenation-operator}

The array concatenation operator \lstinline![ $\ldots$ ]! is described in \cref{array-concatenation}.

\subsection{Array Range Operator}\label{array-range-operator}

The array range constructor operator \lstinline!:! is described in \cref{vector-construction}.

\subsection{If-Expressions}\label{if-expressions}

An expression
\begin{lstlisting}[language=modelica]
if expression1 then expression2 else expression3
\end{lstlisting}%
\index{if@\robustinline{if}!expression}\index{then@\robustinline{then}!if-expression@\robustinline{if}-expression}\index{else@\robustinline{else}!if-expression@\robustinline{if}-expression} is one example of \lstinline!if!-expression.
First \lstinline!expression1!, which must be \lstinline!Boolean! expression, is evaluated.
If \lstinline!expression1! is true \lstinline!expression2! is evaluated and is the value of the \lstinline!if!-expression, else \lstinline!expression3! is evaluated and is the value of the \lstinline!if!-expression.
The two expressions, \lstinline!expression2! and \lstinline!expression3!, must be type compatible expressions (\cref{type-compatible-expressions}) giving the type of the \lstinline!if!-expression.
The \lstinline!if!-expressions with \lstinline!elseif!\index{elseif@\robustinline{elseif}!if-expression} are defined by replacing \lstinline!elseif! by \lstinline!else if!.
For short-circuit evaluation see \cref{evaluation-order}.

\begin{nonnormative}
\lstinline!elseif! in expressions has been added to the Modelica language for symmetry with \lstinline!if!-equations.
\end{nonnormative}

\begin{example}
\begin{lstlisting}[language=modelica]
Integer i;
Integer sign_of_i1 = if i < 0 then -1 elseif i == 0 then 0 else 1;
Integer sign_of_i2 = if i < 0 then -1 else if i == 0 then 0 else 1;
\end{lstlisting}
\end{example}

\subsection{Member Access Operator}\label{member-access-operator}

It is possible to access members of a class instance using dot notation, i.e., the \lstinline!.! operator.

\begin{example}
\lstinline!R1.R! for accessing the resistance component \lstinline!R! of resistor \lstinline!R1!.
Another use of dot notation: local classes which are members of a class can of course also be accessed using dot notation on the name of the class, not on instances of the class.
\end{example}

\subsection{Built-in Variable time}\label{built-in-variable-time}

All declared variables are functions of the independent variable \lstinline!time!.
The variable \lstinline!time! is a built-in variable available in all models and blocks, which is treated as an input variable.
It is implicitly defined as:
\begin{lstlisting}[language=modelica]
input Real time (final quantity = "Time",
                 final unit = "s");
\end{lstlisting}

The value of the \lstinline!start!-attribute of \lstinline!time! is set to the time instant at which the simulation is started.

\begin{example}
\begin{lstlisting}[language=modelica]
encapsulated model SineSource
  import Modelica.Math.sin;
  connector OutPort = output Real;
  OutPort y = sin(time); // Uses the built-in variable time.
end SineSource;
\end{lstlisting}
\end{example}

\section{Built-in Intrinsic Operators with Function Syntax}\label{built-in-intrinsic-operators-with-function-syntax}

Certain built-in operators of Modelica have the same syntax as a function call.
However, they do not behave as a mathematical function, because the result depends not only on the input arguments but also on the status of the simulation.

There are also built-in functions that depend only on the input argument, but also may trigger events in addition to returning a value.
Intrinsic means that they are defined at the Modelica language level, not in the Modelica library.
The following built-in intrinsic operators/functions are available:
\begin{itemize}
\item
  Mathematical functions and conversion functions, see \cref{numeric-functions-and-conversion-functions} below.
\item
  Derivative and special purpose operators with function syntax, see \cref{derivative-and-special-purpose-operators-with-function-syntax} below.
\item
  Event-related operators with function syntax, see \cref{event-related-operators-with-function-syntax} below.
\item
  Array operators/functions, see \cref{array-dimension-lower-and-upper-index-bounds}.
\end{itemize}

Note that when the specification references a function having the name of a built-in function it references the built-in function, not a user-defined function having the same name, see also \cref{built-in-functions}.
With exception of the built-in \lstinline!String! operator, all operators in this section can only be called with positional arguments.

\subsection{Numeric Functions and Conversion Functions}\label{numeric-functions-and-conversion-functions}

The mathematical functions and conversion operators are listed below do not generate events.
\begin{center}
\begin{tabular}{l|l l}
\hline
\tablehead{Expression} & \tablehead{Description} & \tablehead{Details}\\
\hline
\hline
\lstinline!abs($v$)! & Absolute value (event-free) & \Cref{modelica:abs} \\
\lstinline!sign($v$)! & Sign of argument (event-free) & \Cref{modelica:sign} \\
\lstinline!sqrt($v$)! & Square root & \Cref{modelica:sqrt} \\
\lstinline!Integer($e$)! & Conversion from enumeration to \lstinline!Integer! & \Cref{modelica:integer-of-enumeration} \\
\lstinline!EnumTypeName($i$)! & Conversion from \lstinline!Integer! to enumeration & \Cref{modelica:enumeration-of-integer} \\
\lstinline!String($\ldots$)! & Conversion to \lstinline!String! & \Cref{modelica:to-String} \\
\hline
\end{tabular}
\end{center}

All of these except for the \lstinline!String! conversion operator are vectorizable according to \cref{scalar-functions-applied-to-array-arguments}.

Additional non-event generating mathematical functions are described in \cref{built-in-mathematical-functions-and-external-built-in-functions}, whereas the event-triggering mathematical functions are described in \cref{event-triggering-mathematical-functions}.

\begin{functiondefinition}[abs]
\begin{synopsis}\begin{lstlisting}
abs($v$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Expands into \lstinline!noEvent(if $v$ >= 0 then $v$ else -$v$)!.
Argument $v$ needs to be an \lstinline!Integer! or \lstinline!Real! expression.
\end{semantics}
\end{functiondefinition}

\begin{functiondefinition}[sign]
\begin{synopsis}\begin{lstlisting}
sign($v$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Expands into \lstinline!noEvent(if $v$ > 0 then 1 else if $v$ < 0 then -1 else 0)!.
Argument $v$ needs to be an \lstinline!Integer! or \lstinline!Real! expression.
\end{semantics}
\end{functiondefinition}

\begin{functiondefinition}[sqrt]
\begin{synopsis}\begin{lstlisting}
sqrt($v$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Square root of $v$ if $v \geq 0$, otherwise an error occurs.
Argument $v$ needs to be an \lstinline!Integer! or \lstinline!Real! expression.
\end{semantics}
\end{functiondefinition}

\begin{operatordefinition*}[Integer]\label{modelica:integer-of-enumeration}\index{Integer@\robustinline{Integer}!conversion operator}
\begin{synopsis}\begin{lstlisting}
Integer($e$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Ordinal number of the expression $e$ of enumeration type that evaluates to the enumeration value \lstinline!E.enumvalue!, where \lstinline!Integer(E.e1) = 1!, \lstinline!Integer(E.en) = n!, for an enumeration type \lstinline!E = enumeration(e1, $\ldots$, en)!.
See also \cref{type-conversion-of-enumeration-values-to-string-or-integer}.
\end{semantics}
\end{operatordefinition*}

\begin{operatordefinition*}[<EnumTypeName>]\label{modelica:enumeration-of-integer}\index{enumeration@\robustinline{enumeration}!conversion operator}
\begin{synopsis}\begin{lstlisting}
EnumTypeName($i$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
For any enumeration type \lstinline!EnumTypeName!, returns the enumeration value \lstinline!EnumTypeName.e! such that $\text{\lstinline!Integer(EnumTypeName.e)!} = i$.
Refer to the definition of \lstinline!Integer! above.

It is an error to attempt to convert values of $i$ that do not correspond to values of the enumeration type.
See also \cref{type-conversion-of-integer-to-enumeration-values}.
\end{semantics}
\end{operatordefinition*}

\begin{operatordefinition*}[String]\label{modelica:to-String}\index{String@\robustinline{String}!conversion operator}
\begin{synopsis}\begin{lstlisting}
String($b$, <options>)
String($i$, <options>)
String($r$, significantDigits = $d$, <options>)
String($r$, format = $s$)
String($e$, <options>)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Convert a scalar non-\lstinline!String! expression to a \lstinline!String! representation.
The first argument may be a \lstinline!Boolean! $b$, an \lstinline!Integer! $i$, a \lstinline!Real! $r$ or an enumeration value $e$ (\cref{type-conversion-of-enumeration-values-to-string-or-integer}).
The other arguments must use named arguments.
For \lstinline!Real! expressions the output shall be according to the Modelica grammar.

The optional \lstinline!<options>! are:
\begin{itemize}
\item
  \lstinline!Integer minimumLength = 0!: Minimum length of the resulting string.
  If necessary, the blank character is used to fill up unused space.
\item
  \lstinline!Boolean leftJustified = true!: If true, the converted result is left justified in the string; if false it is right justified in the string.
\item
  \lstinline!Integer significantDigits = 6!: Number of significant digits in the result string.
\end{itemize}

\begin{nonnormative}
Examples of \lstinline!Real! values formatted with 6 significant digits: \emph{12.3456}, \emph{0.0123456}, \emph{12345600}, \emph{1.23456E-10}.
\end{nonnormative}

The \lstinline!format! string corresponding to \lstinline!<options>! is:
\begin{itemize}
\item
  For \lstinline!Real!:\\
  \lstinline!(if leftJustified then "-" else "") + String(minimumLength)!\\
  \lstinline!  + "." + String(signficantDigits) + "g"!
\item
  For \lstinline!Integer!:\\
  \lstinline!(if leftJustified then "-" else "") + String(minimumLength) + "d"!
\end{itemize}

Form of the \lstinline!format! string:
According to ANSI-C the format string specifies one conversion specifier (excluding the leading \%), shall not contain length modifiers, and shall not use `\lstinline!*!' for width and/or precision.
For all numeric values the format specifiers `\lstinline!f!', `\lstinline!e!', `\lstinline!E!', `\lstinline!g!', `\lstinline!G!' are allowed.
For integral values it is also allowed to use the `\lstinline!d!', `\lstinline!i!', `\lstinline!o!', `\lstinline!x!', `\lstinline!X!', `\lstinline!u!', and `\lstinline!c!' format specifiers (for non-integral values a tool may round, truncate or use a different format if the integer conversion characters are used).

The `\lstinline!x!'/`\lstinline!X!' formats (hexa-decimal) and \lstinline!c! (character) for \lstinline!Integer! values give results that do not agree with the Modelica grammar.
\end{semantics}
\end{operatordefinition*}


\subsection{Event Triggering Mathematical Functions}\label{event-triggering-mathematical-functions}

The operators listed below trigger events if used outside of a \lstinline!when!-clause and outside of a clocked discrete-time partition (see \cref{clocked-discrete-time-and-clocked-discretized-continuous-time-partition}).
\begin{center}
\begin{tabular}{l|l l}
\hline
\tablehead{Expression} & \tablehead{Description} & \tablehead{Details}\\
\hline
\hline
\lstinline!div($x$, $y$)! & Division with truncation toward zero & \Cref{modelica:div} \\
\lstinline!mod($x$, $y$)! & Integer modulus & \Cref{modelica:mod} \\
\lstinline!rem($x$, $y$)! & Integer remainder & \Cref{modelica:rem} \\
\lstinline!ceil($x$)! & Smallest integer \lstinline!Real! not less than $x$ & \Cref{modelica:ceil} \\
\lstinline!floor($x$)! & Largest integer \lstinline!Real! not greater than $x$ & \Cref{modelica:floor} \\
\lstinline!integer($x$)! & Largest \lstinline!Integer! not greater than $x$ & \Cref{modelica:integer} \\
\hline
\end{tabular}
\end{center}

These expression for \lstinline!div!, \lstinline!ceil!, \lstinline!floor!, and \lstinline!integer! are event generating expression.
The event generating expression for \lstinline!mod(x,y)! is \lstinline!floor(x/y)!, and for \lstinline!rem(x,y)! it is \lstinline!div(x,y)! -- i.e.\ events are not generated when \lstinline!mod! or \lstinline!rem! changes continuously in an interval, but when they change discontinuously from one interval to the next.

\begin{nonnormative}
If this is not desired, the \lstinline!noEvent! operator can be applied to them.
E.g., \lstinline!noEvent(integer(v))!.
\end{nonnormative}

\begin{operatordefinition}[div]
\begin{synopsis}\begin{lstlisting}
div($x$, $y$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Algebraic quotient $x / y$ with any fractional part discarded (also known as truncation toward zero).
\begin{nonnormative}
This is defined for \lstinline!/! in C99; in C89 the result for negative numbers is implementation-defined, so the standard function \lstinline[language=C]!div! must be used.
\end{nonnormative}
Result and arguments shall have type \lstinline!Real! or \lstinline!Integer!.
If either of the arguments is \lstinline!Real! the result is \lstinline!Real! otherwise \lstinline!Integer!.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[mod]
\begin{synopsis}\begin{lstlisting}
mod($x$, $y$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Integer modulus of $x / y$, i.e., \lstinline!mod($x$, $y$) = $x$ - floor($x$ / $y$) * $y$!.
Result and arguments shall have type \lstinline!Real! or \lstinline!Integer!.
If either of the arguments is \lstinline!Real! the result is \lstinline!Real! otherwise \lstinline!Integer!.
\begin{nonnormative}
Note, outside of a \lstinline!when!-clause state events are triggered when the return value changes discontinuously.
Examples: \lstinline!mod(3, 1.4) = 0.2!, \lstinline!mod(-3, 1.4) = 1.2!, \lstinline!mod(3, -1.4) = -1.2!.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[rem]
\begin{synopsis}\begin{lstlisting}
rem($x$, $y$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Integer remainder of $x / y$, such that \lstinline!div($x$, $y$) * $y$ + rem($x$, $y$) = $x$!.
Result and arguments shall have type \lstinline!Real! or \lstinline!Integer!.
If either of the arguments is \lstinline!Real! the result is \lstinline!Real! otherwise \lstinline!Integer!.
\begin{nonnormative}
Note, outside of a \lstinline!when!-clause state events are triggered when the return value changes discontinuously.
Examples: \lstinline!rem(3, 1.4) = 0.2!, \lstinline!rem(-3, 1.4) = -0.2!.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[ceil]
\begin{synopsis}\begin{lstlisting}
ceil($x$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Smallest integer not less than $x$.
Result and argument shall have type \lstinline!Real!.
\begin{nonnormative}
Note, outside of a \lstinline!when!-clause state events are triggered when the return value changes discontinuously.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[floor]
\begin{synopsis}\begin{lstlisting}
floor($x$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Largest integer not greater than $x$.
Result and argument shall have type \lstinline!Real!.
\begin{nonnormative}
Note, outside of a \lstinline!when!-clause state events are triggered when the return value changes discontinuously.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[integer]
\begin{synopsis}\begin{lstlisting}
integer($x$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Largest integer not greater than $x$.
The argument shall have type \lstinline!Real!.
The result has type \lstinline!Integer!.
\begin{nonnormative}
Note, outside of a \lstinline!when!-clause state events are triggered when the return value changes discontinuously.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\subsection{Elementary Mathematical Functions}\label{built-in-mathematical-functions-and-external-built-in-functions}

The functions listed below are elementary mathematical functions.
Tools are expected to utilize well known properties of these functions (derivatives, inverses, etc) for symbolic processing of expressions and equations.
\begin{center}
\begin{tabular}{l|l l}
\hline
\tablehead{Expression} & \tablehead{Description} & \tablehead{Details}\\
\hline
\hline
\lstinline!sin($x$)!        \indexinline{sin}   & Sine & \\
\lstinline!cos($x$)!        \indexinline{cos}   & Cosine & \\
\lstinline!tan($x$)!        \indexinline{tan}   & Tangent ($x$ shall not be: $\ldots$, -$\pi/2$, $\pi/2$, $3\pi/2$, $\ldots$) & \\
\lstinline!asin($x$)!       \indexinline{asin}  & Inverse sine ($-1 \le x \le 1$) & \\
\lstinline!acos($x$)!       \indexinline{acos}  & Inverse cosine ($-1 \le x \le 1$) & \\
\lstinline!atan($x$)!       \indexinline{atan}  & Inverse tangent & \\
\lstinline!atan2($y$, $x$)! \indexinline{atan2} & Principal value of the arc tangent of $y/x$ & \Cref{modelica:atan2} \\
\lstinline!sinh($x$)!       \indexinline{sinh}  & Hyperbolic sine & \\
\lstinline!cosh($x$)!       \indexinline{cosh}  & Hyperbolic cosine & \\
\lstinline!tanh($x$)!       \indexinline{tanh}  & Hyperbolic tangent & \\
\lstinline!exp($x$)!        \indexinline{exp}   & Exponential, base $\mathrm{e}$ & \\
\lstinline!log($x$)!        \indexinline{log}   & Natural (base $\mathrm{e}$) logarithm ($x > 0$) & \\
\lstinline!log10($x$)!      \indexinline{log10} & Base 10 logarithm ($x > 0$) & \\
\hline
\end{tabular}
\end{center}

These functions are the only ones that can also be called using the deprecated \lstinline!"builtin"! external language, see \cref{external-function-interface}.

\begin{nonnormative}
End user oriented information about the elementary mathematical functions can be found for the corresponding functions in the \lstinline!Modelica.Math! package.
\end{nonnormative}

\begin{functiondefinition}[atan2]
\begin{synopsis}\begin{lstlisting}
atan2($y$, $x$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Principal value of the arc tangent of $y/x$, using the signs of the two arguments to determine the quadrant of the result.
The result $\varphi$ is in the interval $\left[-\pi,\, \pi\right]$ and satisfies:
\begin{equation*}
\begin{aligned}
\abs{(x,\, y)}\, \cos(\varphi) &= x\\
\abs{(x,\, y)}\, \sin(\varphi) &= y
\end{aligned}
\end{equation*}
\end{semantics}
\end{functiondefinition}

\subsection{Derivative and Special Purpose Operators with Function Syntax}\label{derivative-and-special-purpose-operators-with-function-syntax}

The operators listed below include the derivative operator and special purpose operators with function syntax.
\begin{center}
\begin{tabular}{l|l l}
\hline
\tablehead{Expression} & \tablehead{Description} & \tablehead{Details}\\
\hline
\hline
\lstinline!der($\mathit{expr}$)! & Time derivative & \Cref{modelica:der} \\
\lstinline!delay($\mathit{expr}$, $\ldots$)! & Time delay & \Cref{modelica:delay} \\
\lstinline!cardinality($c$)! & Number of occurrences in \lstinline!connect!-equations & \Cref{modelica:cardinality} \\
\lstinline!homotopy($\mathit{actual}$, $\mathit{simplified}$)! & Homotopy initialization & \Cref{modelica:homotopy} \\
\lstinline!semiLinear($x$, $k^{+}$, $k^{-}$)! & Sign-dependent slope & \Cref{modelica:semiLinear} \\
\lstinline!inStream($v$)! & Stream variable flow into component & \Cref{modelica:inStream} \\
\lstinline!actualStream($v$)! & Actual value of stream variable & \Cref{modelica:actualStream} \\
\lstinline!spatialDistribution($\ldots$)! & Variable-speed transport & \Cref{modelica:spatialDistribution} \\
\lstinline!getInstanceName()! & Name of instance at call site & \Cref{modelica:getInstanceName} \\
\hline
\end{tabular}
\end{center}

The special purpose operators with function syntax where the call below uses named arguments can be called with named arguments (with the specified names), or with positional arguments (the inputs of the functions are in the order given in the calls below).

\begin{operatordefinition}[der]
\begin{synopsis}\begin{lstlisting}
der($\mathit{expr}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
The time derivative of $\mathit{expr}$.
If the expression $\mathit{expr}$ is a scalar it needs to be a subtype of \lstinline!Real!.
The expression and all its time-varying subexpressions must be continuous and semi-differentiable.
If $\mathit{expr}$ is an array, the operator is applied to all elements of the array.
For non-scalar arguments the function is vectorized according to \cref{vectorized-calls-of-functions}.
\begin{nonnormative}
For \lstinline!Real! parameters and constants the result is a zero scalar or array of the same size as the variable.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[delay]
\begin{synopsis}\begin{lstlisting}
delay($\mathit{expr}$, $\mathit{delayTime}$, $\mathit{delayMax}$)
delay($\mathit{expr}$, $\mathit{delayTime}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Evaluates to \lstinline!$\mathit{expr}$(time - $\mathit{delayTime}$)! for $\text{\lstinline!time!} > \text{\lstinline!time.start!} + \mathit{delayTime}$ and \lstinline!$\mathit{expr}$(time.start)! for $\text{\lstinline!time!} \leq \text{\lstinline!time.start!} + \mathit{delayTime}$.
The arguments, i.e., $\mathit{expr}$, $\mathit{delayTime}$ and $\mathit{delayMax}$, need to be subtypes of \lstinline!Real!.
$\mathit{delayMax}$ needs to be additionally a parameter expression.
The following relation shall hold: $0 \leq \mathit{delayTime} \leq \mathit{delayMax}$, otherwise an error occurs.
If $\mathit{delayMax}$ is not supplied in the argument list, $\mathit{delayTime}$ needs to be a parameter expression.
For non-scalar arguments the function is vectorized according to \cref{vectorized-calls-of-functions}.
For further details, see \cref{delay}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[cardinality]
\begin{synopsis}\begin{lstlisting}
cardinality($c$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
\begin{nonnormative}
This is a deprecated operator.
It should no longer be used, since it will be removed in one of the next Modelica releases.
\end{nonnormative}
Returns the number of (inside and outside) occurrences of connector instance $c$ in a \lstinline!connect!-equation as an \lstinline!Integer! number.
For further details, see \cref{cardinality-deprecated}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[homotopy]
\begin{synopsis}\begin{lstlisting}
homotopy(actual = $\mathit{actual}$, simplified = $\mathit{simplified}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
The scalar expressions $\mathit{actual}$ and $\mathit{simplified}$ are subtypes of \lstinline!Real!.
A Modelica translator should map this operator into either of the two forms:
\begin{enumerate}
\item
  Returns $\mathit{actual}$ (trivial implementation).
\item
  In order to solve algebraic systems of equations, the operator might during the solution process return a combination of the two arguments, ending at actual.
  \begin{example}
  $\mathit{actual} \cdot \lambda + \mathit{simplified} \cdot (1 - \lambda)$, where $\lambda$ is a homotopy parameter going from 0 to 1.
  \end{example}
  The solution must fulfill the equations for \lstinline!homotopy! returning $\mathit{actual}$.
\end{enumerate}
For non-scalar arguments the function is vectorized according to \cref{scalar-functions-applied-to-array-arguments}.
For further details, see \cref{homotopy}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[semiLinear]
\begin{synopsis}\begin{lstlisting}
semiLinear($x$, $k^{+}$, $k^{-}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns: \lstinline!smooth(0, if $x$ >= 0 then $k^{+}$ * $x$ else $k^{-}$ * $x$)!.
The result is of type \lstinline!Real!.
For non-scalar arguments the function is vectorized according to \cref{vectorized-calls-of-functions}.
For further details, see \cref{semilinear} (especially in the case when $x = 0$).
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[inStream]
\begin{synopsis}\begin{lstlisting}
inStream($v$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
\lstinline!inStream($v$)! is only allowed for stream variables $v$ defined in stream connectors, and is the value of the stream variable $v$ close to the connection point assuming that the flow is from the connection point into the component.
This value is computed from the stream connection equations of the flow variables and of the stream variables.
The operator is vectorizable.
For further details, see \cref{stream-operator-instream-and-connection-equations}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[actualStream]
\begin{synopsis}\begin{lstlisting}
actualStream($v$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
\lstinline!actualStream($v$)! returns the actual value of the stream variable $v$ for any flow direction.
The operator is vectorizable.
For further details, see \cref{stream-operator-actualstream}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[spatialDistribution]
\begin{synopsis}\begin{lstlisting}
spatialDistribution(
  in0 = $\mathit{in0}$, in1 = $\mathit{in1}$, x = $x$,
  positiveVelocity = $\ldots$,
  initialPoints = $\ldots$,
  initialValues = $\ldots$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
\lstinline!spatialDistribution! allows approximation of variable-speed transport of properties.
For further details, see \cref{spatialdistribution}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[getInstanceName]
\begin{synopsis}\begin{lstlisting}
getInstanceName()
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns a string with the name of the model/block that is simulated, appended with the fully qualified name of the instance in which this function is called.
For further details, see \cref{getinstancename}.
\end{semantics}
\end{operatordefinition}

A few of these operators are described in more detail in the following.

\subsubsection{delay}\label{delay}

\begin{nonnormative}
\lstinline!delay! allows a numerical sound implementation by interpolating in the (internal) integrator polynomials, as well as a more simple realization by interpolating linearly in a buffer containing past values of expression $\mathit{expr}$.
Without further information, the complete time history of the delayed signals needs to be stored, because the delay time may change during simulation.
To avoid excessive storage requirements and to enhance efficiency, the maximum allowed delay time has to be given via $\mathit{delayMax}$.
This gives an upper bound on the values of the delayed signals which have to be stored.
For real-time simulation where fixed step size integrators are used, this information is sufficient to allocate the necessary storage for the internal buffer before the simulation starts.
For variable step size integrators, the buffer size is dynamic during integration.

In principle, \lstinline!delay! could break algebraic loops.
For simplicity, this is not supported because the minimum delay time has to be given as additional argument to be fixed at compile time.
Furthermore, the maximum step size of the integrator is limited by this minimum delay time in order to avoid extrapolation in the delay buffer.
\end{nonnormative}

\subsubsection{spatialDistribution}\label{spatialdistribution}

\begin{nonnormative}
Many applications involve the modelling of variable-speed transport of properties.
One option to model this infinite-dimensional system is to approximate it by an ODE, but this requires a large number of state variables and might introduce either numerical diffusion or numerical oscillations.
Another option is to use a built-in operator that keeps track of the spatial distribution of $z(x, t)$, by suitable sampling, interpolation, and shifting of the stored distribution.
In this case, the internal state of the operator is hidden from the ODE solver.
\end{nonnormative}

\lstinline!spatialDistribution! allows the infinite-dimensional problem below to be solved efficiently with good accuracy
\begin{align*}
\frac{\partial z(x,t)}{\partial t}+v(t)\frac{\partial z(x,t)}{\partial x} &= 0.0\\
z(0.0, t) &= \mathrm{in}_0(t) \text{ if $v\geq 0$}\\
z(1.0, t) &= \mathrm{in}_1(t) \text{ if $v<0$}
\end{align*}
where $z(x, t)$ is the transported quantity, $x$ is the normalized spatial coordinate ($0.0 \le x \le 1.0$), $t$ is the time, $v(t)=\mathrm{der}(x)$ is the normalized transport velocity and the boundary conditions are set at either $x=0.0$ or $x=1.0$, depending on the sign of the velocity.
The calling syntax is:
\begin{lstlisting}[language=modelica]
(out0, out1) = spatialDistribution(in0, in1, x, positiveVelocity,
                                   initialPoints = {0.0, 1.0},
                                   initialValues = {0.0, 0.0});
\end{lstlisting}
where \lstinline!in0!, \lstinline!in1!, \lstinline!out0!, \lstinline!out1!, and \lstinline!x! are all subtypes of \lstinline!Real!, \lstinline!positiveVelocity! is a \lstinline!Boolean!, \lstinline!initialPoints! and \lstinline!initialValues! are arrays of subtypes of \lstinline!Real! of equal size, containing the x coordinates and the $z$ values of a finite set of points describing the initial distribution of $z(x, \mathit{t0})$.
The \lstinline!out0! and \lstinline!out1! are given by the solutions at $z(0.0, t)$ and $z(1.0, t)$; and \lstinline!in0! and \lstinline!in1! are the boundary conditions at $z(0.0, t)$ and $z(1.0, t)$ (at each point in time only one of \lstinline!in0! and \lstinline!in1! is used).
Elements in the \lstinline!initialPoints! array must be sorted in non-descending order.
The operator can not be vectorized according to the vectorization rules described in \cref{scalar-functions-applied-to-array-arguments}.
The operator can be vectorized only with respect to the arguments \lstinline!in0! and \lstinline!in1! (which must have the same size), returning vectorized outputs \lstinline!out0! and \lstinline!out1! of the same size; the arguments \lstinline!initialPoints! and \lstinline!initialValues! are vectorized accordingly.

The solution, $z$, can be described in terms of characteristics:
\begin{equation*}
z(x+\int_{t}^{t+\beta} v(\alpha) \mathrm{d}\alpha, t+\beta) = z(x, t),\quad\text{for all $\beta$ as long as staying inside the domain}
\end{equation*}

This allows the direct computation of the solution based on interpolating the boundary conditions.

\lstinline!spatialDistribution! can be described in terms of the pseudo-code given as a block:
\begin{lstlisting}[language=modelica]
block spatialDistribution
  input Real in0;
  input Real in1;
  input Real x;
  input Boolean positiveVelocity;
  parameter Real initialPoints(each min=0, each max=1)[:] = {0.0, 1.0};
  parameter Real initialValues[:] = {0.0, 0.0};
  output Real out0;
  output Real out1;
protected
  Real points[:];
  Real values[:];
  Real x0;
  Integer m;
algorithm
  /* The notation
   *   x <and then> y
   * is used below as a shorthand for
   *   if x then y else false
   * also known as "short-circuit evaluation of x and y".
   */
  if positiveVelocity then
    out1 := interpolate(points, values, 1 - (x - x0));
    out0 := values[1]; // Similar to in0 but avoiding algebraic loop.
  else
    out0 := interpolate(points, values, 0 - (x - x0));
    out1 := values[end]; // Similar to in1 but avoiding algebraic loop.
  end if;
  when <acceptedStep> then
    if x > x0 then
      m := size(points, 1);
      while m > 0 <and then> points[m] + (x - x0) >= 1 loop
        m := m - 1;
      end while;
      values := cat(1,
                    {in0},
                    values[1:m],
                    {interpolate(points, values, 1 - (x - x0))});
      points := cat(1, {0}, points[1:m] .+ (x-x0), {1});
    elseif x < x0 then
      m := 1;
      while m < size(points, 1) <and then> points[m] + (x - x0) <= 0 loop
        m := m + 1;
      end while;
      values := cat(1,
                    {interpolate(points, values, 0 - (x - x0))},
                    values[m:end],
                    {in1});
      points := cat(1, {0}, points[m:end] .+ (x - x0), {1});
    end if;
    x0 := x;
  end when;
initial algorithm
  x0 := x;
  points := initialPoints;
  values := initialValues;
end spatialDistribution;
\end{lstlisting}

\begin{nonnormative}
Note that the implementation has an internal state and thus cannot be described as a function in Modelica; \lstinline!initialPoints! and \lstinline!initialValues! are declared as parameters to indicate that they are only used during initialization.

The infinite-dimensional problem stated above can then be formulated in the following way:
\begin{lstlisting}[language=modelica]
der(x) = v;
(out0, out1) = spatialDistribution(in0, in1, x, v >= 0,
                                   initialPoints, initialValues);
\end{lstlisting}

Events are generated at the exact instants when the velocity changes sign -- if this is not needed, \lstinline!noEvent! can be used to suppress event generation.

If the velocity is known to be always positive, then \lstinline!out0! can be omitted, e.g.:
\begin{lstlisting}[language=modelica]
der(x) = v;
(, out1) = spatialDistribution(in0, 0, x, true, initialPoints, initialValues);
\end{lstlisting}
Technically relevant use cases for the use of \lstinline!spatialDistribution! are modeling of electrical transmission lines, pipelines and pipeline networks for gas, water and district heating, sprinkler systems, impulse propagation in elongated bodies, conveyor belts, and hydraulic systems.
Vectorization is needed for pipelines where more than one quantity is transported with velocity \lstinline!v! in the example above.
\end{nonnormative}

\subsubsection{cardinality (deprecated)}\label{cardinality-deprecated}

\begin{nonnormative}
\lstinline!cardinality! is deprecated for the following reasons and will be removed in a future release:
\begin{itemize}
\item
  Reflective operator may make early type checking more difficult.
\item
  Almost always abused in strange ways
\item
  Not used for Bond graphs even though it was originally introduced for that purpose.
\end{itemize}
\end{nonnormative}

\begin{nonnormative}
\lstinline!cardinality! allows the definition of connection dependent equations in a model, for example:
\begin{lstlisting}[language=modelica]
connector Pin
  Real v;
  flow Real i;
end Pin;
model Resistor
  Pin p, n;
equation
  assert(cardinality(p) > 0 and cardinality(n) > 0,
         "Connectors p and n of Resistor must be connected");
  // Equations of resistor
  $\ldots$
end Resistor;
\end{lstlisting}
\end{nonnormative}

The cardinality is counted after removing conditional components, and shall not be applied to expandable connectors, elements in expandable connectors, or to arrays of connectors (but can be applied to the scalar elements of array of connectors).
\lstinline!cardinality! should only be used in the condition of assert and \lstinline!if!-statements that do not contain \lstinline!connect! and similar operators, see \cref{clocked-discrete-time-and-clocked-discretized-continuous-time-partition}).

\subsubsection{homotopy}\label{homotopy}

\begin{nonnormative}
During the initialization phase of a dynamic simulation problem, it often happens that large nonlinear systems of equations must be solved by means of an iterative solver.
The convergence of such solvers critically depends on the choice of initial guesses for the unknown variables.
The process can be made more robust by providing an alternative, simplified version of the model, such that convergence is possible even without accurate initial guess values, and then by continuously transforming the simplified model into the actual model.
This transformation can be formulated using expressions of this kind:
\begin{equation*}
\lambda\cdot\text{\lstinline!actual!} + (1-\lambda)\cdot\text{\lstinline!simplified!}
\end{equation*}
in the formulation of the system equations, and is usually called a homotopy transformation.
If the simplified expression is chosen carefully, the solution of the problem changes continuously with $\lambda$, so by taking small enough steps it is possible to eventually obtain the solution of the actual problem.

The operator can be called with ordered arguments or preferably with named arguments for improved readability.

It is recommended to perform (conceptually) one homotopy iteration over the whole model, and not several homotopy iterations over the respective non-linear algebraic equation systems.
The reason is that the following structure can be present:
\begin{lstlisting}[language=modelica]
w = $f_1$(x) // has homotopy
0 = $f_2$(der(x), x, z, w)
\end{lstlisting}

Here, a non-linear equation system $f_2$ is present.
\lstinline!homotopy! is, however used on a variable that is an ``input'' to the non-linear algebraic equation system, and modifies the characteristics of the non-linear algebraic equation system.
The only useful way is to perform the homotopy iteration over $f_1$ and $f_2$ together.

The suggested approach is ``conceptual'', because more efficient implementations are possible, e.g.\ by determining the smallest iteration loop, that contains the equations of the first BLT block in which \lstinline!homotopy! is present and all equations up to the last BLT block that describes a non-linear algebraic equation system.

A trivial implementation of \lstinline!homotopy! is obtained by defining the following function in the global scope:
\begin{lstlisting}[language=modelica]
function homotopy
  input Real actual;
  input Real simplified;
  output Real y;
algorithm
  y := actual;
  annotation(Inline = true);
end homotopy;
\end{lstlisting}
\end{nonnormative}

\begin{example}[1]
In electrical systems it is often difficult to solve non-linear algebraic equations if switches are part of the algebraic loop.
An idealized diode model might be implemented in the following way, by starting with a ``flat'' diode characteristic and then move with \lstinline!homotopy! to the desired ``steep'' characteristic:
\begin{lstlisting}[language=modelica]
model IdealDiode
  $\ldots$
  parameter Real Goff = 1e-5;
protected
  Real Goff_flat = max(0.01, Goff);
  Real Goff2;
equation
  off = s < 0;
  Goff2 = homotopy(actual = Goff, simplified = Goff_flat);
  u = s * (if off then 1 else Ron2) + Vknee;
  i = s * (if off then Goff2 else 1 ) + Goff2*Vknee;
  $\ldots$
end IdealDiode;
\end{lstlisting}
\end{example}

\begin{example}[2]
In electrical systems it is often useful that all voltage sources start with zero voltage and all current sources with zero current, since steady state initialization with zero sources can be easily obtained.
A typical voltage source would then be defined as:
\begin{lstlisting}[language=modelica]
model ConstantVoltageSource
  extends Modelica.Electrical.Analog.Interfaces.OnePort;
  parameter Modelica.Units.SI.Voltage V;
equation
  v = homotopy(actual = V, simplified = 0.0);
end ConstantVoltageSource;
\end{lstlisting}
\end{example}

\begin{example}[3]
In fluid system modelling, the pressure/flowrate relationships are highly nonlinear due to the quadratic terms and due to the dependency on fluid properties.
A simplified linear model, tuned on the nominal operating point, can be used to make the overall model less nonlinear and thus easier to solve without accurate start values.
Named arguments are used here in order to further improve the readability.
\begin{lstlisting}[language=modelica]
model PressureLoss
  import Modelica.Units.SI;
  $\ldots$
  parameter SI.MassFlowRate m_flow_nominal "Nominal mass flow rate";
  parameter SI.Pressure dp_nominal "Nominal pressure drop";
  SI.Density rho "Upstream density";
  SI.DynamicViscosity lambda "Upstream viscosity";
equation
  $\ldots$
  m_flow = homotopy(actual = turbulentFlow_dp(dp, rho, lambda),
                    simplified = dp/dp_nominal*m_flow_nominal);
  $\ldots$
end PressureLoss;
\end{lstlisting}
\end{example}

\begin{example}[4] Note that \lstinline!homotopy! \emph{shall not} be used to combine unrelated expressions, since this can generate singular systems from combining two well-defined systems.
\begin{lstlisting}[language=modelica]
model DoNotUse
  Real x;
  parameter Real x0 = 0;
equation
  der(x) = 1-x;
initial equation
  0 = homotopy(der(x), x - x0);
end DoNotUse;
\end{lstlisting}

The initial equation is expanded into
\begin{equation*}
0 = \lambda*\mathrm{der}(x)+(1-\lambda)(x-x_0)
\end{equation*}
and you can solve the two equations to give
\begin{equation*}
x = \frac{\lambda+(\lambda-1)x_0}{2\lambda-1}
\end{equation*}
which has the correct value of $x_0$ at $\lambda = 0$ and of 1 at $\lambda = 1$, but unfortunately has a singularity at $\lambda = 0.5$.
\end{example}


\subsubsection{semiLinear}\label{semilinear}

(See definition of \lstinline!semiLinear! in \cref{derivative-and-special-purpose-operators-with-function-syntax}).
In some situations, equations with \lstinline!semiLinear! become underdetermined if the first argument (\lstinline!x!) becomes zero, i.e., there are an infinite number of solutions.
It is recommended that the following rules are used to transform the equations during the translation phase in order to select one meaningful solution in such cases:
\begin{itemize}
\item
The equations
\begin{lstlisting}[language=modelica]
y = semiLinear(x, sa, s1);
y = semiLinear(x, s1, s2);
y = semiLinear(x, s2, s3);
$\ldots$
y = semiLinear(x, sN, sb);
$\ldots$
\end{lstlisting}
may be replaced by
\begin{lstlisting}[language=modelica]
s1 = if x >= 0 then sa else sb
s2 = s1;
s3 = s2;
$\ldots$
$s_N = s_{N-1}$;
y = semiLinear(x, sa, sb);
\end{lstlisting}

\item
The equations
\begin{lstlisting}[language=modelica]
x = 0;
y = 0;
y = semiLinear(x, sa, sb);
\end{lstlisting}
may be replaced by
\begin{lstlisting}[language=modelica]
x = 0
y = 0;
sa = sb;
\end{lstlisting}
\end{itemize}

\begin{nonnormative}
For symbolic transformations, the following property is useful (this follows from the definition):
\begin{lstlisting}[language=modelica]
semiLinear(m_flow, port_h, h);
\end{lstlisting}
is identical to:
\begin{lstlisting}[language=modelica]
-semiLinear(-m_flow, h, port_h);
\end{lstlisting}

The \lstinline!semiLinear! function is designed to handle reversing flow in fluid systems, such as
\begin{lstlisting}[language=modelica]
H_flow = semiLinear(m_flow, port.h, h);
\end{lstlisting}
i.e., the enthalpy flow rate \lstinline!H_flow! is computed from the mass flow rate \lstinline!m_flow! and the upstream specific enthalpy depending on the flow direction.
\end{nonnormative}

\subsubsection{getInstanceName}\label{getinstancename}

Returns a string with the name of the model/block that is simulated, appended with the fully qualified name of the instance in which this function is called.

\begin{example}
\begin{lstlisting}[language=modelica]
package MyLib
  model Vehicle
    Engine engine;
    $\ldots$
  end Vehicle;
  model Engine
    Controller controller;
    $\ldots$
  end Engine;
  model Controller
  equation
    Modelica.Utilities.Streams.print("Info from: " + getInstanceName());
  end Controller;
end MyLib;
\end{lstlisting}
If \lstinline!MyLib.Vehicle! is simulated, the call of \lstinline!getInstanceName()! returns \lstinline!"Vehicle.engine.controller"!.
\end{example}

If this function is not called inside a model or block (e.g.\ the function is called in a function or in a constant of a package), the return value is not specified.

\begin{nonnormative}
The simulation result should not depend on the return value of this function.
\end{nonnormative}

\subsection{Event-Related Operators with Function Syntax}\label{event-related-operators-with-function-syntax}

The operators listed below are event-related operators with function syntax.
The operators \lstinline!noEvent!, \lstinline!pre!, \lstinline!edge!, and \lstinline!change!, are vectorizable according to \cref{scalar-functions-applied-to-array-arguments}.
\begin{center}
\begin{tabular}{l|l l}
\hline
\tablehead{Expression} & \tablehead{Description} & \tablehead{Details}\\
\hline
\hline
\lstinline!initial()! & Predicate for the initialization phase & \Cref{modelica:initial}\\
\lstinline!terminal()! & Predicate for the end of a successful analysis & \Cref{modelica:terminal}\\
\lstinline!noEvent($\mathit{expr}$)! & Evaluate $\mathit{expr}$ without triggering events & \Cref{modelica:noEvent}\\
\lstinline!smooth($p$, $\mathit{expr}$)! & Treat $\mathit{expr}$ as $p$ times continuously differentiable & \Cref{modelica:smooth}\\
\lstinline!sample($\mathit{start}$, $\mathit{interval}$)! & Periodic triggering of events & \Cref{modelica:event-sample}\\
\lstinline!pre($y$)! & Left limit $y(t^{-})$ of variable $y(t)$ & \Cref{modelica:pre}\\
\lstinline!edge($b$)! & Expands into \lstinline!($b$ and not pre($b$))! & \Cref{modelica:edge}\\
\lstinline!change($v$)! & Expands into \lstinline!($v$ <> pre($v$))! & \Cref{modelica:change}\\
\lstinline!reinit($x$, $\mathit{expr}$)! & Reinitialize $x$ with $\mathit{expr}$ & \Cref{modelica:reinit}\\
\hline
\end{tabular}
\end{center}

\begin{operatordefinition}[initial]
\begin{synopsis}\begin{lstlisting}
initial()
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns \lstinline!true! during the initialization phase and \lstinline!false! otherwise.
\begin{nonnormative}
Hereby, \lstinline!initial()! triggers a time event at the beginning of a simulation.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[terminal]
\begin{synopsis}\begin{lstlisting}
terminal()
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns \lstinline!true! at the end of a successful analysis.
\begin{nonnormative}
Hereby, \lstinline!terminal()! ensures an event at the end of successful simulation.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[noEvent]
\begin{synopsis}\begin{lstlisting}
noEvent($\mathit{expr}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
\lstinline!Real! elementary relations within $\mathit{expr}$ are taken literally, i.e., no state or time event is triggered.
No zero crossing functions shall be used to monitor any of the normally event-generating subexpressions inside $\mathit{expr}$.
See also \crefnameref{modelica:smooth} and \cref{events-and-synchronization}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[smooth]
\begin{synopsis}\begin{lstlisting}
smooth($p$, $\mathit{expr}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
If $p \geq 0$ \lstinline!smooth($p$, $\mathit{expr}$)! returns $\mathit{expr}$ and states that $\mathit{expr}$ is $p$ times continuously differentiable, i.e.: $\mathit{expr}$ is continuous in all \lstinline!Real! variables appearing in the expression and all partial derivatives with respect to all appearing real variables exist and are continuous up to order $p$.
The argument $p$ should be a scalar \lstinline!Integer! parameter expression.
The only allowed types for $\mathit{expr}$ in \lstinline!smooth! are: \lstinline!Real! expressions, arrays of allowed expressions, and records containing only components of allowed expressions.

\lstinline!smooth! should be used instead of \lstinline!noEvent! in order to avoid events for efficiency reasons.
A tool is free to not generate events for expressions inside \lstinline!smooth!.
However, \lstinline!smooth! does not guarantee that no events will be generated, and thus it can be necessary to use \lstinline!noEvent! inside \lstinline!smooth!.

\begin{nonnormative}
Note that \lstinline!smooth! does not guarantee a smooth output if any of the occurring variables change discontinuously.
\end{nonnormative}

\begin{example}
\begin{lstlisting}[language=modelica]
  Real x, y, z;
equation
  x = if time < 1 then 2 else time - 2;
  z = smooth(0, if time < 0 then 0 else time);
  y = smooth(1,
        noEvent(if x < 0 then 0 else sqrt(x) * x)); // Needs noEvent.
\end{lstlisting}
\end{example}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition*}[sample]\label{modelica:event-sample}\index{sample@\robustinline{sample}!event-generating}
\begin{synopsis}\begin{lstlisting}
sample($\mathit{start}$, $\mathit{interval}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns \lstinline!true! and triggers time events at time instants $\mathit{start} + i \cdot \mathit{interval}$ for $i = 0,\, 1\, \ldots$, and is only true during the first event iteration at those times.
At event iterations after the first one at each event and during continuous integration the operator always returns \lstinline!false!.
The starting time $\mathit{start}$ and the sample interval $\mathit{interval}$ must be parameter expressions and need to be a subtype of \lstinline!Real! or \lstinline!Integer!.
The sample interval $\mathit{interval}$ must be a positive number.
\end{semantics}
\end{operatordefinition*}

\begin{operatordefinition}[pre]
\begin{synopsis}\begin{lstlisting}
pre($y$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns the \emph{left limit} $y(t^{-})$ of variable $y(t)$ at a time instant $t$.
At an event instant, $y(t^{-})$ is the value of $y$ after the last event iteration at time instant $t$ (see comment below).
% Warning "component expression" is a term defined for synchronous operator argument restrictions; this seems to conflict with also defining the present argument restriction below.
Any subscripts in the component expression $y$ must be parameter expressions.
\lstinline!pre! can be applied if the following three conditions are fulfilled simultaneously: (a) variable $y$ is either a subtype of a simple type or is a record component, (b) $y$ is a discrete-time expression (c) the operator is \emph{not} applied in a \lstinline!function! class.
\begin{nonnormative}
This can be applied to continuous-time variables in \lstinline!when!-clauses, see \cref{discrete-time-expressions} for the definition of discrete-time expression.
\end{nonnormative}
The first value of \lstinline!pre($y$)! is determined in the initialization phase.

A new event is triggered if there is at least for one variable \lstinline!v! such that \lstinline!pre(v) <> v! after the active model equations are evaluated at an event instant.
In this case the model is at once reevaluated.
This evaluation sequence is called \emph{event iteration}.
The integration is restarted once \lstinline!pre(v) == v! for all \lstinline!v! appearing inside \lstinline!pre($\ldots$)!.

\begin{nonnormative}
If \lstinline!v! and \lstinline!pre(v)! are only used in \lstinline!when!-clauses, the translator might mask event iteration for variable \lstinline!v! since \lstinline!v! cannot change during event iteration.
It is a quality of implementation to find the minimal loops for event iteration, i.e., not all parts of the model need to be reevaluated.

The language allows mixed algebraic systems of equations where the unknown variables are of type \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, or an enumeration.
These systems of equations can be solved by a global fix point iteration scheme, similarly to the event iteration, by fixing the \lstinline!Boolean!, \lstinline!Integer!, and/or enumeration unknowns during one iteration.
Again, it is a quality of implementation to solve these systems more efficiently, e.g., by applying the fix point iteration scheme to a subset of the model equations.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[edge]
\begin{synopsis}\begin{lstlisting}
edge($b$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Expands into \lstinline!($b$ and not pre($b$))! for \lstinline!Boolean! variable $b$.
The same restrictions as for \lstinline!pre! apply (e.g.\ not to be used in \lstinline!function! classes).
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[change]
\begin{synopsis}\begin{lstlisting}
change(v)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Expands into \lstinline!($v$ <> pre($v$))!.
The same restrictions as for \lstinline!pre! apply.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[reinit]
\begin{synopsis}\begin{lstlisting}
reinit($x$, $\mathit{expr}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
In the body of a \lstinline!when!-clause, reinitializes $x$ with $\mathit{expr}$ at an event instant.
$x$ is a scalar or array \lstinline!Real! variable that is implicitly defined to have \lstinline!StateSelect.always!.
\begin{nonnormative}
It is an error if the variable cannot be selected as a state.
\end{nonnormative}
$\mathit{expr}$ needs to be type-compatible with $x$.
\lstinline!reinit! can only be applied once for the same variable -- either as an individual variable or as part of an array of variables.
It can only be applied in the body of a \lstinline!when!-clause in an equation section.
See also \cref{reinit}.
\end{semantics}
\end{operatordefinition}

\section{Variability of Expressions}\label{variability-of-expressions}

The concept of \firstuse[expression variability]{variability of an expression}\index{variability!expression|see{expression variability}} indicates to what extent the expression can vary over time.
See also \cref{component-variability-prefixes-discrete-parameter-constant} regarding the concept of variability.
% It seems wrong to not mention 'clocked discrete-time' here.
There are four levels of variability of expressions, starting from the least variable:
\begin{itemize}
\item
  constant variability
\item
  parameter variability
\item
  discrete-time variability
\item
  continuous-time variability
\end{itemize}

While many invalid models can be rejected based on the declared variabilities of variables alone (without the concept of expression variability), the following rules both help enforcing compliance of computed solutions to declared variability, and impose additional restrictions that simplify reasoning and reporting of errors:
\begin{itemize}
\item
  For an assignment \lstinline!v := expr! or binding equation \lstinline!v = expr!, \lstinline!v! must be declared to be at least as variable as \lstinline!expr!.
\item
  When determining whether an equation can contribute to solving for a variable \lstinline!v! (for instance,
  when applying the perfect matching rule, see \cref{synchronous-data-flow-principle-and-single-assignment-rule}),
  the equation can only be considered contributing if the resulting solution would be at most as variable as \lstinline!v!.
\item
  The right-hand side expression in a binding equation (that is, \lstinline!expr!) of a parameter component and of the base type attributes
  (such as \lstinline!start!) needs to be a parameter or constant expression.
\item
  If \lstinline!v! is a discrete-time component then \lstinline!expr! needs to be a
  discrete-time expression.
\end{itemize}

\begin{example}
The (underdetermined) model \lstinline!Test! below illustrates two kinds of consequences due to variability constraints.
First, it contains variability errors for declaration equations and assignments.
Second, it illustrates the impact of variability on the matching of equations to variables, which can lead to violation of the perfect matching rule.
Details of how variabilities are determined are given in the sections below.
The \willintroduce{discrete-valued equation variability rule} mentioned in the comments below refer to the rule in \cref{discrete-time-expressions} that requires both sides of the \lstinline!Boolean! equation to be discrete-time.
\begin{lstlisting}[language=modelica]
model Constants
  parameter Real p1 = 1;
  constant Real c1 = p1 + 2; // Error, not a constant expression.
  parameter Real p2 = p1 + 2; // Fine.
end Constants;
model Test
  Constants c1(p1 = 3); // Fine.
  Constants c2(p2 = 7); // Fine, declaration equation can be modified.
  Real x;
  Boolean b1 = noEvent(x > 1); // Error, since b1 is a discrete-time variable
                               // and noEvent(x > 1) is not discrete-time.
  Boolean b2;
  Integer i1;
  Integer i2;
algorithm
  i1 := x; // Error, assignment to variable of lesser variability.
equation
  /* The equation below can be rejected for two reasons:
   * 1. Discrete-valued equation variability rule requires both sides to be
   *    discrete-time.
   * 2. It violates the perfect matching rule, as no variable can be solved
   *    with correct variability using this equation.
   */
  b2 = noEvent(x > 1); // Error, see above.
  i2 = x;              // No variability error, and can be matched to x.
end Test;
\end{lstlisting}
\end{example}

\subsection{Function Variability}\label{function-variability}

The variability of function calls needs to consider both the variability of arguments directly given in the function and the variability of the used default arguments, if any.
This is especially a concern for functions given as a short class, see \cref{inheritance-of-functions}.
This has additional implications for redeclarations, see \cref{function-compatibility}.
The purity of the function, see \cref{pure-modelica-functions}, does not influence the variability of the function call.

\begin{nonnormative}
The restrictions for calling functions declared as \lstinline!impure! serve a similar purpose as the variability restrictions, see \cref{pure-modelica-functions}, and thus it is not necessary to consider purity in the definition of variability.
Consider a function reading an external file and returning some value from that file.
Different uses can have the file updated before the simulation (as a parameter-expression), or during the simulation (as a discrete-time expression).
Thus it depends on the use case and the specific file, not the function itself, and it would even be possible to update the file in continuous time (as part of an algorithm) and still use the same function.
\end{nonnormative}

\subsection{Constant Expressions}\label{constant-expressions}

Constant expressions\index{constant!expression}\index{expression variability!constant} are:
\begin{itemize}
\item
  \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, \lstinline!String!, and \lstinline!enumeration! literals.
\item
  Constant variables, see \cref{component-variability-prefixes-discrete-parameter-constant}.
\item
  Except for the special built-in operators \lstinline!initial!, \lstinline!terminal!, \lstinline!der!,
  \lstinline!edge!, \lstinline!change!, \lstinline!sample!, and \lstinline!pre!, a function or operator with constant
  subexpressions as argument (and no parameters defined in the function)
  is a constant expression.
\item
  Some function calls are constant expressions regardless of the arguments:
  \begin{itemize}
  \item
    \lstinline!ndims(A)!
  \end{itemize}
\end{itemize}

\subsection{Parameter Expressions}\label{parameter-expressions}

Parameter expressions\index{parameter!expression}\index{expression variability!parameter}\index{parametric variability|see{parameter, expression}} are:
\begin{itemize}
\item
  Constant expressions.
\item
  Parameter variables, see \cref{component-variability-prefixes-discrete-parameter-constant}.
\item
  Input variables in functions behave as though they were parameter expressions.
\item
  Except for the special built-in operators \lstinline!initial!, \lstinline!terminal!, \lstinline!der!,
  \lstinline!edge!, \lstinline!change!, \lstinline!sample!, and \lstinline!pre!, a function or operator with parameter
  subexpressions is a parameter expression.
\item
  Some function calls are parameter expressions even if the arguments are not:
  \begin{itemize}
  \item
    \lstinline!cardinality(c)!, see restrictions for use in \cref{cardinality-deprecated}.
  \item
    \lstinline!end! in \lstinline!A[$\ldots$ end $\ldots$]! if \lstinline!A! is variable declared in a non-\lstinline!function! class.
  \item
    \lstinline!size(A)! (including \lstinline!size(A, j)! where \lstinline!j! is parameter expression) if \lstinline!A! is variable declared in a non-function class.
  \item
    \lstinline!Connections.isRoot(A.R)!
  \item
    \lstinline!Connections.rooted(A.R)!
  \end{itemize}
\end{itemize}

\subsection{Discrete-Time Expressions}\label{discrete-time-expressions}

Discrete-time expressions\index{discrete-time!expression}\index{expression variability!discrete-time} are:
\begin{itemize}
\item
  Parameter expressions.
\item
  Discrete-time variables, see \cref{component-variability-prefixes-discrete-parameter-constant}.
\item
  Function calls where all input arguments of the function are discrete-time expressions.
\item
  Expressions where all the subexpressions are discrete-time expressions.
\item
  Expressions in the body of a \lstinline!when!-clause, \lstinline!initial equation!, or \lstinline!initial algorithm!.
\item
  Unless inside \lstinline!noEvent!: Ordered relations (\lstinline!>!, \lstinline!<!, \lstinline!>=!, \lstinline!<=!) and the event generating functions \lstinline!ceil!, \lstinline!floor!, \lstinline!div!, and \lstinline!integer!, if at least one argument is non-discrete time expression and subtype of \lstinline!Real!.
  \begin{nonnormative}
  These will generate events, see \cref{events-and-synchronization}.
  Note that \lstinline!rem! and \lstinline!mod! generate events but are not discrete-time expressions.
  In other words, relations inside \lstinline!noEvent!, such as \lstinline!noEvent(x>1)!, are not discrete-time expressions.
  \end{nonnormative}
\item
  The functions \lstinline!pre!, \lstinline!edge!, and \lstinline!change! result in discrete-time expressions.
\item
  Expressions in functions behave as though they were discrete-time expressions.
\end{itemize}

Inside an \lstinline!if!-expression, \lstinline!if!-clause, \lstinline!while!-statement or \lstinline!for!-clause, that is controlled by a non-discrete-time (that is continuous-time, but not discrete-time) switching expression and not in the body of a \lstinline!when!-clause, it is not legal to have assignments to discrete-time variables, equations between discrete-time expressions, or real elementary relations/functions that should generate events.

\begin{nonnormative}
The restriction above is necessary in order to guarantee that all equations for discrete-time variable are discrete-time expressions, and to ensure that crossing functions do not become active between events.
\end{nonnormative}

For a scalar or array equation \lstinline!expr1 = expr2! where neither expression is of base type \lstinline!Real!, both expressions must be discrete-time expressions.
For a record equation, the rule applies recursively to each of the components of the record.
This is called the \firstuse{discrete-valued equation variability rule}.

\begin{nonnormative}
For a scalar equation, the rule follows from the observation that a discrete-valued equation does not provide sufficient information to solve for a continuous-valued variable.
Hence, and according to the perfect matching rule (see \cref{synchronous-data-flow-principle-and-single-assignment-rule}), such an equation must be used to solve for a discrete-valued variable.
By the interpretation of \eqref{eq:dae-discrete-valued} in \cref{modelica-dae-representation}, it follows that one of \lstinline!expr1! and \lstinline!expr2! must be the variable, and the other expression its solution.
Since a discrete-valued variable is a discrete-time expression, it follows that its solution on the other side of the equation must have at most discrete-time variability.
That is, both sides of the equation are discrete-time expressions.

For example, this rule shows that (outside of a \lstinline!when!-clause) \lstinline!noEvent! cannot be applied to either side of a \lstinline!Boolean!, \lstinline!Integer!, \lstinline!String!, or \lstinline!enumeration! equation, as this would result in a non-discrete-time expression.

For an array equation, note that each array can have only one element type, so if one element is \lstinline!Real!, then all other entries must also be \lstinline!Real!, possibly making use of standard type coercion, \cref{standard-type-coercion}.
Hence, if the base type is not \lstinline!Real!, all elements of the array are discrete-valued, allowing the argument above for a scalar equation to be applied elementwise to the array equation.
That is, all array elements on both sides of the array equation will have discrete-time variability, showing that also the entire arrays \lstinline!expr1! and \lstinline!expr2! are discrete-time expressions.

For a record equation, the components of the record have independent types, and the equation is seen as a collection of equations for the individual components of the record.
In order to support records with components of mixed variability, a record equation with sides given by either record variables or record constructors is conceptually split before variability is determined.
\end{nonnormative}

\begin{example}
Discrete-valued equation variability rule applied to record equations.
In the first of the equations below, having a record constructor on both sides of the equation, the equation is conceptually split, and variabilities of \lstinline!time! and \lstinline!true! are considered separately.
In the second equation, the \lstinline!makeR! function call -- regardless of inlining -- means that the equation cannot be conceptually split into individual components of the record.
The variability of the \lstinline!makeR! call is continuous-time due to the \lstinline!time! argument, which also becomes the variability of the \lstinline!b! member of the call.
\begin{lstlisting}[language=modelica]
record R
  Real x;
  Boolean b;
end R;

function makeR "Function wrapper around record constructor"
  input Real xx;
  input Boolean bb;
  output R r = R(xx, bb);
  annotation(Inline = true); // Inlining doesn't help.
end makeR;

model Test
  R r1, r2;
equation
  r1 = R(time, true);     // OK: Discrete-time Boolean member.
  r2 = makeR(time, true); // Error: Continuous-time Boolean member.
end Test;
\end{lstlisting}
\end{example}

\subsection{Continuous-Time and Non-Discrete-Time Expressions}\label{continuous-time-expressions}

All expressions are continuous-time expressions\index{continuous-time!expression}\index{expression variability!continuous-time} including constant, parameter and discrete-time expressions.
The term \firstuse{non-discrete-time expression}\index{expression variability!non-discrete-time} refers to expressions that are neither constant, parameter nor discrete-time expressions.
For example, \lstinline!time! is a continuous-time built-in variable (see \cref{component-variability-prefixes-discrete-parameter-constant}) and \lstinline!time + 1! is a non-discrete-time expression.
Note that plain \lstinline!time! may, depending on context, refer to the continuous-time variable or the non-discrete-time expression.
