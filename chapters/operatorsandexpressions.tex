\chapter{Operators and Expressions}\label{operators-and-expressions}

The lexical units are combined to form even larger building blocks such as \firstuse[expression]{expressions} according to the rules given by the \lstinline[language=grammar]!expression! part of the Modelica grammar in \cref{modelica-concrete-syntax}.
For example, they can be built from operators, function references, components, or component references (referring to components) and literals.
Each expression has a type and a variability.

This chapter describes the evaluation rules for expressions, the concept of expression variability, built-in mathematical operators and functions, and the built-in special Modelica operators with function syntax.

Expressions can contain variables and constants, which have types, predefined or user defined.
The predefined built-in types of Modelica are \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, \lstinline!String!, and enumeration types which are presented in more detail in \cref{predefined-types-and-classes}.


\section{Expressions}\label{expressions}

Modelica equations, assignments and declaration equations contain expressions.

Expressions can contain basic operations, \lstinline!+!, \lstinline!-!, \lstinline!*!, \lstinline!/!, \lstinline!^!, etc.\ with normal precedence as defined in \cref{tab:operator-precedence} in \cref{operator-precedence-and-associativity} and the grammar in \cref{modelica-concrete-syntax}.
The semantics of the operations is defined for both scalar and array arguments in \cref{scalar-vector-matrix-and-array-operator-functions}.

It is also possible to define functions and call them in a normal fashion.
The function call syntax for both positional and named arguments is described in \cref{positional-or-named-input-arguments-of-functions} and for vectorized calls in \cref{initialization-and-binding-equations-of-components-in-functions}.
The built-in array functions are given in \cref{array-dimension-lower-and-upper-index-bounds} and other built-in operators in \cref{built-in-intrinsic-operators-with-function-syntax}.


\section{Operator Precedence and Associativity}\label{operator-precedence-and-associativity}

Operator precedence determines the implicit subexpression structure of expressions with operators.
(Explicit subexpression structure can be expressed by wrapping the subexpression in parentheses.)
An operator with higher precedence ties harder to its operands than an operator with lower precedence.
For example, `\lstinline!*!' having higher precedence than `\lstinline!+!' means that \lstinline!1 + 2 * 3! is implicitly structured as \lstinline!1 + (2 * 3)!.

Precedence group associativity is used to determine the implicit subexpression structure when operators belong to the same group of equal precedence.
Left associativity means that subexpressions are formed from left to right.
For example, left associativity of binary additive operators means that \lstinline!1 - 2 - 3! is implicitly structured as \lstinline!(1 - 2) - 3!.
A precedence group may also be non-associative, meaning that there is no implicit subexpression structure defined based on associativity.
For example, non-associativity of relational operators means that \lstinline!1 < 2 < 3! is an invalid expression.
Note that the operators don't need to be identical for associativity to matter; also \lstinline!1 == 2 < 3! is invalid, and \lstinline!1 - 2 + 3! is implicitly structured as \lstinline!(1 - 2) + 3!.
Also note that the non-associative array range in Modelica can be used with either two or three operands separated by `\lstinline!:!', meaning that \lstinline!1 : 2 : 5! is one valid ternary use of the operator rather than two invalid binary uses of the operator.

At the parsing stage -- which is where the here defined operator precedence and associativity matters -- the subexpression structure is fixed.
Since Modelica tools have the freedom to symbolically manipulate expressions, this subexpression structure cannot be expected to reflect order of evaluation, compare \cref{evaluation-order}.

The following table presents the precedence and associativity of all the expression operators, consistent with and complementing information that can be derived from the Modelica grammar in \cref{modelica-concrete-syntax}.
\begin{table}[H]
\caption{
  Operators in order of precedence from highest to lowest.
  Operators with different precedence are separated by horizontal lines.
  All operators are binary except array index, member access, function call, those shown as unary together with \emph{expr}, the conditional operator, the array construction operator
% Beware that the array construction operator, normally expressed as \lstinline!{ }! needs escaped braces inside \caption.
% This isn't handled correctly by LaTeXML, as reported here:
% - https://github.com/brucemiller/LaTeXML/issues/1377 (fixed on master 2022-12-10)
\ifpdf
\lstinline!\{ \}! % Intentional space at end of line.
\else
\lstinline!{ }! % Intentional space at end of line.
\fi
  and concatenation operator \lstinline![ ]!, and the array range constructor which is either binary or ternary.\\
  $^{\dagger}$ The associativity of array construction and concatenation refers to the separator (`\lstinline!,!' or `\lstinline!;!'), not the enclosing delimiters.
}
\label{tab:operator-precedence}
\begin{center}
\begin{tabular}{l c l l}
\hline
\tablehead{Operator group} & \tablehead{Assoc.} & \tablehead{Operator syntax} & \tablehead{Examples}\\
\hline
\hline
Array index & left & {\lstinline![]!} & {\lstinline!arr[index]!}\\
\hline
Member access & left & {\lstinline!.!} & {\lstinline!a.b!}\\
\hline
Function call & none & {\lstinline!$\mathit{funcName}$($\mathit{args}$)!} & {\lstinline!sin(4.36)!}\\
\hline
Array construction & left$^{\dagger}$ & {\lstinline!{$\mathit{expr}$, $\mathit{expr}$, $\ldots$}!} & {\lstinline!{2, 3}!}\\
Horizontal concatenation & left$^{\dagger}$ & {\lstinline![$\mathit{expr}$, $\mathit{expr}$, $\ldots$]!} & {\lstinline![5, 6]!}\\
\hline
Vertical concatenation & left$^{\dagger}$ & {\lstinline![$\mathit{expr}$; $\mathit{expr}$; $\ldots$]!} & {\lstinline![2, 3; 7, 8]!}\\
\hline
Exponentiation & none & {\lstinline!^!} & {\lstinline!2 ^ 3!}\\
\hline
Multiplicative & left & {\lstinline!* /!} & {\lstinline!2 * 3!}, {\lstinline!2 / 3!}\\
Elementwise multiplicative & left & {\lstinline!.* ./!} & {\lstinline!{2, 3} .* {4, 5}!}\\
\hline
Additive unary & none & {\lstinline!+$\mathit{expr}$ -$\mathit{expr}$!} & {\lstinline!-0.5!}\\
\hline
Additive & left & {\lstinline!+ -!} & {\lstinline!1 + 2!}\\
Elementwise additive & left & {\lstinline!.+ .-!} & {\lstinline!{2, 3} .+ {4, 5}!}\\
\hline
Relational & none & {\lstinline!< <= > >= == <>!} & {\lstinline!a < b!}, {\lstinline!a <= b!}, {\lstinline!a > b!}\\
\hline
Unary negation & none & {\lstinline!not $\mathit{expr}$!} & {\lstinline!not b1!}\\
\hline
Logical and & left & {\lstinline!and!} & {\lstinline!b1 and b2!}\\
\hline
Logical or & left & {\lstinline!or!} & {\lstinline!b1 or b2!}\\
\hline
\multirow{2}{*}{Array range} & none & {\lstinline!$\mathit{expr}$ : $\mathit{expr}$!} & {\lstinline!1 : 5!}\\
                             & none & {\lstinline!$\mathit{expr}$ : $\mathit{expr}$ : $\mathit{expr}$!} & {\lstinline!start : step : stop!}\\
\hline
Conditional & none & {\lstinline!if $\mathit{expr}$ then $\mathit{expr}$ else $\mathit{expr}$!} & {\lstinline!if b then 3 else x!}\\
\hline
Named argument & none & {\lstinline!$\mathit{ident}$ = $\mathit{expr}$!} & {\lstinline!x = 2.26!}\\
\hline
\end{tabular}
\end{center}
\end{table}

The array index and member access operators can both be part of a \lstinline[language=grammar]!component-reference! (one of the alternative productions for \lstinline[language=grammar]!primary! in the grammar) and be applied to general expressions when the left operand is parenthesized.
Directly using both member access and array index in a \lstinline[language=grammar]!component-reference! has a special intuitive meaning.
See \cref{indexing} and \cref{member-access-operator}.

\begin{example}
Relative precedence of array index and member access.
Consider the following definition of the array variable \lstinline!a!:
\begin{lstlisting}[language=modelica]
record R
  Real[2] x;
end R;
R[3] a;
\end{lstlisting}
These are some valid as well as invalid ways to using array index and member access:
\begin{lstlisting}[language=modelica]
a[3].x[2]   // OK: Component reference of type Real
a[3].x      // OK: Component reference of type Real[2]
a.x[2]      // OK: Component reference of type Real[3]
a.x[2, :]   // Error.
a.x         // OK: Component reference of type Real[3, 2]
(a.x)[2]    // OK: Component reference of type Real[2] - same as a[2].x[:]
(a.x)[2, :] // OK: Component reference of type Real[2] - same as a[2].x[:]
a[3]        // OK: Component reference of type R
(a[3]).x    // OK: Like a[3].x, but not a component reference
(a[3]).x[1] // Error.
((a[3]).x)[1] // OK: Like a[3].x[1], but not a component reference
\end{lstlisting}
The relation between \lstinline!a.x!, \lstinline!a.x[2]!, and \lstinline!(a.x)[2]! illustrates the effect of giving higher precedence to array index than member access.
Had the precedence been equal, this would have changed the meaning of \lstinline!a.x[2]! to the same thing that \lstinline!(a.x)[2]! expresses, being a component reference of type \lstinline!Real[2]!.
\end{example}

\begin{example}
Non-associative exponentiation and array range operator (note that the array range operator only takes scalar operands):
\begin{lstlisting}[language=modelica]
x ^ y ^ z     // Not legal, use parentheses to make it clear.
a : b : c : d // Not legal, and parentheses cannot make it legal.
\end{lstlisting}
\end{example}

The additive unary expressions are only allowed in the first term of a sum, that is, not immediately to the right of any of the additive or elementwise additive operators.
For example, \lstinline!1 + -1 + 1! is an invalid expression (not parseable according to \cref{modelica-concrete-syntax}), whereas both \lstinline!1 + (-1) + 1! and \lstinline!-1 + 1 + 1! are fine.

\begin{example}
The unary minus and plus in Modelica is slightly different than in Mathematica\footnote{\emph{Mathematica} is a registered trademark of Wolfram Research Inc.} and in MATLAB\footnote{\emph{MATLAB} is a registered trademark of MathWorks Inc.}, since the following expressions are illegal (whereas in Mathematica and in MATLAB these are valid expressions):
% Using $\hspace{0pt}$ below to work around https://github.com/brucemiller/LaTeXML/issues/1399
\begin{lstlisting}[language=modelica]
2*$\hspace{0pt}$-2 // = -4 in Mathematica/MATLAB; is illegal in Modelica
-$\hspace{0pt}$-2  // = 2 in Mathematica/MATLAB; is illegal in Modelica
+$\hspace{0pt}$+2  // = 2 in Mathematica/MATLAB; is illegal in Modelica
2-$\hspace{0pt}$-2 // = 4 in Mathematica/MATLAB; is illegal in Modelica
\end{lstlisting}
\end{example}

The conditional operator may also include \lstinline!elseif!-branches.

Equality \lstinline!=! and assignment \lstinline!:=! are not expression operators since they are allowed only in equations and in assignment statements respectively.

\begin{nonnormative}
The operator precedence table is useful when generating textual representations of Modelica expression trees.
When doing this, attention must be paid to the rule that the unary additive operators are only allowed for the first term in a sum.
A naive implementation might not produce all the required parentheses for an expression tree such as \lstinline!1 + (-1)!, as it might think that the higher precedence of the unary operator makes the parentheses redundant.
A trick that solves this problem is to instead treat the additive unary operators as left associative with the same precedence as the binary additive operators.
\end{nonnormative}


\section{Evaluation Order}\label{evaluation-order}

A tool is free to solve equations, reorder expressions and to not evaluate expressions if their values do not influence the result (e.g., short-circuit evaluation of \lstinline!Boolean! expressions).
\lstinline!if!-statements and \lstinline!if!-expressions guarantee that their branches are only evaluated if the appropriate condition is true, but relational operators generating state or time events will during continuous integration have the value from the most recent event.

If a numeric operation overflows the result is undefined.
For literals it is recommended to automatically convert the number to another type with greater precision.

\begin{example}
If one wants to guard an expression against incorrect evaluation, it should be guarded by an \lstinline!if!:
\begin{lstlisting}[language=modelica]
  Boolean v[n];
  Boolean b;
  Integer I;
equation
  b = (I >= 1 and I <= n) and v[I];                // Unsafe, may result in error
  b = if (I >= 1 and I <= n) then v[I] else false; // Safe
\end{lstlisting}

To guard square against square root of negative number use \lstinline!noEvent!:
\begin{lstlisting}[language=modelica]
der(h) = if h > 0 then -c * sqrt(h) else 0;          // Incorrect
der(h) = if noEvent(h > 0) then -c * sqrt(h) else 0; // Correct
\end{lstlisting}
\end{example}

\section{Arithmetic Operators}\label{arithmetic-operators}

Modelica supports five binary arithmetic operators that operate on any numerical type:
\begin{center}
\begin{tabular}{c|l|l}
\tablehead{Operator} & \tablehead{Description} & \tablehead{Reference} \\
\hline
\hline
{\lstinline!+!, \lstinline!.+!} & Addition & \cref{addition-subtraction-and-string-concatenation}\\
{\lstinline!-!, \lstinline!.-!} & Subtraction & \cref{addition-subtraction-and-string-concatenation}\\
{\lstinline!*!, \lstinline!.*!} & Multiplication & \Cref{array-element-wise-multiplication} and \cref{matrix-and-vector-multiplication-of-numeric-arrays}\\
{\lstinline!/!, \lstinline!./!} & Division & \Cref{division-by-numeric-scalars} and \cref{array-element-wise-division}\\
{\lstinline!^!, \lstinline!.^!} & Exponentiation & \Cref{element-wise-exponentiation} and \cref{scalar-exponentiation-of-matrices}\\
\hline
\end{tabular}
\end{center}

The semantics of these operators are given in \cref{scalar-vector-matrix-and-array-operator-functions} (both when applied to scalar operands and when one or both operands are of array type).
For arrays this explains both the matrix algebra operators and the element-wise operators that start with a dot.

The syntax of these operators is defined by Modelica grammar in \cref{expressions1}, under the \lstinline[language=grammar]!arithmetic-expression! rule.

\section{Equality, Relational, and Logical Operators}\label{equality-relational-and-logical-operators}

Modelica supports the standard set of relational and logical operators, all of which produce the standard boolean values \lstinline!true! or \lstinline!false!:
\begin{center}
\begin{tabular}{c|l}
\tablehead{Operator} & \tablehead{Description} \\
\hline
\hline
{\lstinline!>!} & Greater than\\
{\lstinline!>=!} & Greater than or equal\\
{\lstinline!<!} & Less than\\
{\lstinline!<=!} & Less than or equal to\\
{\lstinline!==!} & Equality within expressions\\
{\lstinline!<>!} & Inequality\\
\hline
\end{tabular}
\end{center}

A single equals sign \lstinline!=! is never used in relational expressions, only in equations (\cref{equations}, \cref{equality-and-assignment}) and in function calls using named parameter passing (\cref{positional-or-named-input-arguments-of-functions}).

The following logical operators are defined:
\begin{center}
\begin{tabular}{c|l}
\tablehead{Operator} & \tablehead{Description} \\
\hline
\hline
{\lstinline!not!}\indexinline{not} & Logical negation (unary operator)\\
{\lstinline!and!}\indexinline{and} & Logical \emph{and} (conjunction)\\
{\lstinline!or!}\indexinline{or} & Logical \emph{or} (disjunction)\\
\hline
\end{tabular}
\end{center}

The grammar rules define the syntax of the relational and logical operators.
\begin{lstlisting}[language=grammar]
logical-expression :
   logical-term { or logical-term }

logical-term :
   logical-factor { and logical-factor }

logical-factor :
   [ not ] relation

relation :
   arithmetic-expression [ relational-operator arithmetic-expression ]

relational-operator :
   "<" | "<=" | ">" | ">=" | "==" | "<>"
\end{lstlisting}

The following holds for relational operators:
\begin{itemize}
\item
  Relational operators \lstinline!<!, \lstinline!<=!,\lstinline!>!, \lstinline!>=!, \lstinline!==!, \lstinline!<>!, are only defined for scalar operands of simple types.
  The result is \lstinline!Boolean! and is true or false if the relation is fulfilled or not, respectively.
\item
  For operands of type \lstinline!String!, \lstinline!str1 $\mathit{op}$ str2! is for each relational operator, $\mathit{op}$, defined in terms of the C function \lstinline[language=C]!strcmp! as \lstinline[language=C]!strcmp(str1, str2) $\mathit{op}$ 0!.
\item
  For operands of type \lstinline!Boolean!, \lstinline!false < true!.
\item
  For operands of enumeration types, the order is given by the order of declaration of the enumeration literals.
\item
  In relations of the form \lstinline!v1 == v2 or v1 <> v2!, \lstinline!v1! or \lstinline!v2! shall, unless used in a function, not be a subtype of \lstinline!Real!.
  \begin{nonnormative}
  The reason for this rule is that relations with \lstinline!Real! arguments are transformed to state events (see \cref{events-and-synchronization}) and this transformation becomes unnecessarily complicated for the \lstinline!==! and \lstinline!<>! relational operators (e.g., two crossing functions instead of one crossing function needed, epsilon strategy needed even at event instants).
  Furthermore, testing on equality of \lstinline!Real! variables is questionable on machines where the number length in registers is different to number length in main memory.
  \end{nonnormative}
\item
  Relational operators can generate events, see \cref{discrete-time-expressions}.
\end{itemize}

\section{Miscellaneous Operators and Variables}\label{miscellaneous-operators-and-variables}

Modelica also contains a few built-in operators which are not standard arithmetic, relational, or logical operators.
These are described below, including \lstinline!time!, which is a built-in variable, not an operator.

\subsection{String Concatenation}\label{string-concatenation}

Concatenation of strings (see the Modelica grammar) is denoted by the \lstinline!+! operator in Modelica.

\begin{example}
\lstinline!"a" + "b"! becomes \lstinline!"ab"!.
\end{example}

\subsection{Array Constructor Operator}\label{array-constructor-operator}

The array constructor operator \lstinline!{ $\ldots$ }! is described in \cref{vector-matrix-and-array-constructors}.

\subsection{Array Concatenation Operator}\label{array-concatenation-operator}

The array concatenation operator \lstinline![ $\ldots$ ]! is described in \cref{array-concatenation}.

\subsection{Array Range Operator}\label{array-range-operator}

The array range constructor operator \lstinline!:! is described in \cref{vector-construction}.

\subsection{If-Expressions}\label{if-expressions}

An expression
\begin{lstlisting}[language=modelica]
if expression1 then expression2 else expression3
\end{lstlisting}%
\index{if@\robustinline{if}!expression}\index{then@\robustinline{then}!if-expression@\robustinline{if}-expression}\index{else@\robustinline{else}!if-expression@\robustinline{if}-expression} is one example of \lstinline!if!-expression.
First \lstinline!expression1!, which must be \lstinline!Boolean! expression, is evaluated.
If \lstinline!expression1! is true \lstinline!expression2! is evaluated and is the value of the \lstinline!if!-expression, else \lstinline!expression3! is evaluated and is the value of the \lstinline!if!-expression.
The two expressions, \lstinline!expression2! and \lstinline!expression3!, must be type compatible expressions (\cref{type-compatible-expressions}) giving the type of the \lstinline!if!-expression.
The \lstinline!if!-expressions with \lstinline!elseif!\index{elseif@\robustinline{elseif}!if-expression} are defined by replacing \lstinline!elseif! by \lstinline!else if!.
For short-circuit evaluation see \cref{evaluation-order}.

\begin{nonnormative}
\lstinline!elseif! in expressions has been added to the Modelica language for symmetry with \lstinline!if!-equations.
\end{nonnormative}

\begin{example}
\begin{lstlisting}[language=modelica]
Integer i;
Integer sign_of_i1 = if i < 0 then -1 elseif i == 0 then 0 else 1;
Integer sign_of_i2 = if i < 0 then -1 else if i == 0 then 0 else 1;
\end{lstlisting}
\end{example}

\subsection{Member Access Operator}\label{member-access-operator}

It is possible to access members of a class instance using dot notation, i.e., the \lstinline!.! operator.
It is also possible to select a record member of a general expression by enclosing it in parentheses.
Note that while the selection is applied to an \lstinline[language=grammar]!output-expression-list! in the grammar, it is only semantically valid when the \lstinline[language=grammar]!output-expression-list! represents an expression.

In case the first operand is an array it is seen as a slicing operation, see \cref{slice-operation}.

\begin{example}
The component reference \lstinline!R1.R! accesses the resistance component \lstinline!R! of resistor \lstinline!R1!.

The qualified class name \lstinline!A.B! is a reference to the local class \lstinline!B! which is a member of the class \lstinline!A!.
Note that the left operand in this case is a class, not an instance of the class.

\lstinline!(Complex(2, 3)).re! constructs the record \lstinline!Complex(2, 3)! and then selects the \lstinline!re! component in it.
\lstinline!Complex(2, 3).re! is not valid syntax.
\end{example}

\subsection{Built-in Variable time}\label{built-in-variable-time}\indexinline{time}

All declared variables are functions of the independent variable \lstinline!time!.
The variable \lstinline!time! is a built-in variable available in all models and blocks, which is treated as an input variable.
It is implicitly defined as:
\begin{lstlisting}[language=modelica]
input Real time (final quantity = "Time",
                 final unit = "s");
\end{lstlisting}

The value of the \lstinline!start!-attribute of \lstinline!time! is set to the time instant at which the simulation is started.

\begin{example}
\begin{lstlisting}[language=modelica]
encapsulated model SineSource
  import Modelica.Math.sin;
  connector OutPort = output Real;
  OutPort y = sin(time); // Uses the built-in variable time.
end SineSource;
\end{lstlisting}
\end{example}

\section{Built-in Operators and Functions}\label{built-in-intrinsic-operators-with-function-syntax}

Certain built-in operators of Modelica are called using the same syntax as a function call.
However, they do not behave as a mathematical function, because the result depends not only on the input arguments but also on the status of the simulation.

There are also built-in functions that depend only on the input argument, but also may trigger events in addition to returning a value.
The built-in functions may also be overloaded such that a single Modelica function cannot be compatible with all calls of the function.
Here, \emph{built-in} means that they are defined at the Modelica language level, not through a Modelica \lstinline!function! definition.
The following built-in operators/functions are available:
\begin{itemize}
\item
  Mathematical functions and conversion operators, see \cref{numeric-functions-and-conversion-functions} below.
\item
  Derivative and special purpose operators with function syntax, see \cref{derivative-and-special-purpose-operators-with-function-syntax} below.
\item
  Event-related operators, see \cref{event-related-operators-with-function-syntax} below.
\item
  Array operators/functions, see \cref{built-in-array-functions}.
\item
  Synchronous operators, see \cref{synchronous-language-elements}.
\item
  State machine operators, see \cref{transitions}.
\end{itemize}

Except where shadowing problems are being discussed, references to built-in functions and operators within this document always assume that the built-in definitions are not shadowed by user-defined definitions, see also \cref{built-in-functions}.
With the exception where inputs are named (e.g., \lstinline!String!), all operators and functions in this section can only be called with positional arguments.

\subsection{Numeric Functions and Conversion Operators}\label{numeric-functions-and-conversion-functions}

The mathematical functions and conversion operators listed below do not generate events.
\begin{center}
\begin{tabular}{l|l l}
\hline
\tablehead{Expression} & \tablehead{Description} & \tablehead{Details}\\
\hline
\hline
{\lstinline!abs($v$)!} & Absolute value (event-free) & \Cref{modelica:abs} \\
{\lstinline!sign($v$)!} & Sign of argument (event-free) & \Cref{modelica:sign} \\
{\lstinline!min($x$, $y$)!} & Least of two scalars (event-free) & \Cref{modelica:min-binary} \\
{\lstinline!max($x$, $y$)!} & Greatest of two scalars (event-free) & \Cref{modelica:max-binary} \\
{\lstinline!sqrt($v$)!} & Square root & \Cref{modelica:sqrt} \\
{\lstinline!nthRoot($v$, $n$)!} & $n$th root & \Cref{modelica:nthRoot} \\
{\lstinline!Integer($e$)!} & Conversion from enumeration to {\lstinline!Integer!} & \Cref{modelica:integer-of-enumeration} \\
{\lstinline!EnumTypeName($i$)!} & Conversion from {\lstinline!Integer!} to enumeration & \Cref{modelica:enumeration-of-integer} \\
{\lstinline!String($\ldots$)!} & Conversion to {\lstinline!String!} & \Cref{modelica:to-String} \\
\hline
\end{tabular}
\end{center}

Except for the \lstinline!String! conversion operator, they are vectorizable according to \cref{scalar-functions-applied-to-array-arguments}.
The \lstinline!min! and \lstinline!max! functions have array-specific variants which perform array reduction operations described in \cref{reduction-functions-and-operators}.

Additional non-event generating mathematical functions are described in \cref{built-in-mathematical-functions-and-external-built-in-functions}, whereas the event-triggering mathematical functions are described in \cref{event-triggering-mathematical-functions}.

\begin{functiondefinition}[abs]
\begin{synopsis}\begin{lstlisting}
abs($v$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Expands into \lstinline!noEvent(if $v$ >= 0 then $v$ else -$v$)!.
Argument $v$ needs to be an \lstinline!Integer! or \lstinline!Real! expression.
\end{semantics}
\begin{nonnormative}
By not generating events the property \lstinline!abs($x$)! $\geq 0$ for all $x$ is ensured at the cost of sometimes having a derivative that changes discontinuously between events.

A typical case requiring the event-free semantics is a flow equation of the form \lstinline!abs(x) * x = y!.
With event generation, the equation would switch between the two forms \lstinline!x^2 = y! and \lstinline!-x^2 = y! at the events, where the events would not be coinciding exactly with the sign changes of \lstinline!y!.
When \lstinline!y! passes through zero, neither form of the equation would have a solution in an open neighborhood of \lstinline!y! $= 0$, and hence solving the equation would have to fail at some point sufficiently close to \lstinline!y! $= 0$.
Without event generation, on the other hand, the equation can be solved easily for \lstinline!x!, also as \lstinline!y! passes through zero.
Note that without event generation the derivative of \lstinline!abs(x) * x! never changes discontinuously, despite \lstinline!abs(x)! having a discontinuous derivative.

In inverted form this equation is \lstinline!x = sign(y) * sqrt(abs(y))!.
With event generation, the call to \lstinline!sqrt! would fail when applied to a negative number during root finding of the zero crossing for \lstinline!abs(y)!, compare \cref{events-and-synchronization}.
Without event generation, on the other hand, evaluating \lstinline!sqrt(abs(y))! will never fail.
\end{nonnormative}
\end{functiondefinition}

\begin{functiondefinition}[sign]
\begin{synopsis}\begin{lstlisting}
sign($v$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Expands into \lstinline!noEvent(if $v$ > 0 then 1 else if $v$ < 0 then -1 else 0)!.
Argument $v$ needs to be an \lstinline!Integer! or \lstinline!Real! expression.
\end{semantics}
\end{functiondefinition}

\begin{functiondefinition}[sqrt]
\begin{synopsis}\begin{lstlisting}
sqrt($v$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Square root of $v$, equivalent to \lstinline!nthRoot(v, 2)!.
\end{semantics}
\end{functiondefinition}

\begin{functiondefinition}[nthRoot]
\begin{synopsis}\begin{lstlisting}
nthRoot($v$, $n$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
$n$th root of $v$, where $v$ shall be a \lstinline!Real! expression, and $n > 0$ shall be an \lstinline!Integer! expression.
The result $y$ is a real root of the equation $y^{n} = v$.
If $n$ is even, $v$ must be non-negative and $y$ shall be the non-negative root.
(If $n$ is odd, there is no constraint on $v$ and $y$ will have the same sign as $v$.)
\end{semantics}
\end{functiondefinition}

\begin{operatordefinition*}[Integer]\label{modelica:integer-of-enumeration}\index{Integer@\robustinline{Integer}!conversion operator}
\begin{synopsis}\begin{lstlisting}
Integer($e$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Ordinal number of the expression $e$ of enumeration type that evaluates to the enumeration value \lstinline!E.enumvalue!, where \lstinline!Integer(E.e1) = 1!, \lstinline!Integer(E.en) = n!, for an enumeration type \lstinline!E = enumeration(e1, $\ldots$, en)!.
See also \cref{type-conversion-of-enumeration-values-to-string-or-integer}.
\end{semantics}
\end{operatordefinition*}

\begin{operatordefinition*}[<EnumTypeName>]\label{modelica:enumeration-of-integer}\index{enumeration@\robustinline{enumeration}!conversion operator}
\begin{synopsis}\begin{lstlisting}
EnumTypeName($i$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
For any enumeration type \lstinline!EnumTypeName!, returns the enumeration value \lstinline!EnumTypeName.e! such that $\text{\lstinline!Integer(EnumTypeName.e)!} = i$.
Refer to the definition of \lstinline!Integer! above.

It is an error to attempt to convert values of $i$ that do not correspond to values of the enumeration type.
See also \cref{type-conversion-of-integer-to-enumeration-values}.
\end{semantics}
\end{operatordefinition*}

\begin{operatordefinition*}[String]\label{modelica:to-String}\index{String@\robustinline{String}!conversion operator}
\begin{synopsis}\begin{lstlisting}
String($b$, $\langle$$\mbox{\emph{options}}$$\rangle$)
String($i$, $\langle$$\mbox{\emph{options}}$$\rangle$)
String($i$, format = $s$)
String($r$, $\langle$$\mbox{\emph{options}}$$\rangle$)
String($r$, format = $s$)
String($e$, $\langle$$\mbox{\emph{options}}$$\rangle$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Convert a scalar non-\lstinline!String! expression to a \lstinline!String! representation.
The first argument may be a \lstinline!Boolean! $b$, an \lstinline!Integer! $i$, a \lstinline!Real! $r$, or an enumeration value $e$ (\cref{type-conversion-of-enumeration-values-to-string-or-integer}).
The $\langle\mathit{options}\rangle$ represent zero or more of the following named arguments (that cannot be passed as positional arguments):
\begin{itemize}
\item
  \lstinline!Integer minimumLength = 0!: Minimum length of the resulting string.
  If necessary, the blank character is used to fill up unused space.
\item
  \lstinline!Boolean leftJustified = true!: If true, the converted result is left justified in the string; if false it is right justified in the string.
\item
  \lstinline!Integer significantDigits = 6!: Number of significant digits in the result string.
  Only allowed when formatting a \lstinline!Real! value.
\end{itemize}

The standard type coercion described in \cref{standard-type-coercion} shall not be applied for the first argument of \lstinline!String!.
Hence, specifying \lstinline!significantDigits! is an error when the first argument of \lstinline!String! is an \lstinline!Integer! expression.

For \lstinline!Real! expressions the output shall be according to the Modelica grammar.

\begin{nonnormative}
Examples of \lstinline!Real! values formatted with 6 significant digits: \emph{12.3456}, \emph{0.0123456}, \emph{12345600}, \emph{1.23456E-10}.
\end{nonnormative}

The \lstinline!format! string corresponding to $\langle\mathit{options}\rangle$ is:
\begin{itemize}
\item
  For \lstinline!Real!:\\
  \lstinline!(if leftJustified then "-" else "") + String(minimumLength)!\\
  \lstinline!  + "." + String(signficantDigits) + "g"!
\item
  For \lstinline!Integer!:\\
  \lstinline!(if leftJustified then "-" else "") + String(minimumLength) + "d"!
\end{itemize}

The ANSI-C style \lstinline!format! string (which cannot be combined with any of the other named arguments) consists of a single conversion specification without the leading \%.
It shall not contain a length modifier, and shall not use `\lstinline!*!' for width and/or precision.
For both \lstinline!Real! and \lstinline!Integer! values, the conversion specifiers `\lstinline!f!', `\lstinline!e!', `\lstinline!E!', `\lstinline!g!', `\lstinline!G!' are allowed.
For \lstinline!Integer! values it is also allowed to use the `\lstinline!d!', `\lstinline!i!', `\lstinline!o!', `\lstinline!x!', `\lstinline!X!', `\lstinline!u!', and `\lstinline!c!' conversion specifiers.
Using the \lstinline!Integer! conversion specifiers for a \lstinline!Real! value is a deprecated feature, where tools are expected to produce a result by either rounding the value, truncating the value, or picking one of the \lstinline!Real! conversion specifiers instead.

The `\lstinline!x!'/`\lstinline!X!' formats (hexa-decimal) and \lstinline!c! (character) for \lstinline!Integer! values give results that do not agree with the Modelica grammar.

\begin{example}
Some situations worth a remark:
\begin{itemize}
\item
  \lstinline!String(4.0, format = "g")! produces \emph{4} which is not a valid \lstinline!Real! literal.
  However, it is an \lstinline!Integer! literal that can be used almost anywhere in Modelica code instead of the \lstinline!Real! literal \lstinline{4.0} (with the first argument to \lstinline!String! being a notable exception here).
\item
  \lstinline!String(4, format = ".3f")! uses the \lstinline!Integer! case of \lstinline!String! since no automatic type coerction takes place for the first argument.
  An implementation may internally convert the value to floating point and then fall back on the \lstinline!Real! case implementation of \lstinline!format = ".3f"!.
\item
  \lstinline!String(4611686018427387648, format = ".0f")! (a valid \lstinline!Integer! value in an implementation with 64 bit \lstinline!IntegerType!) may produce \emph{4611686018427387904} (not equal to input value), in case internal conversion to a 64 bit \lstinline[language=C]!double! is applied.
\end{itemize}
\end{example}
\end{semantics}
\end{operatordefinition*}


\subsection{Event Triggering Mathematical Functions}\label{event-triggering-mathematical-functions}

The operators listed below trigger events unless explicitly or implicitly inhibited by \lstinline!noEvent! (see \cref{events-and-synchronization}).
\begin{center}
\begin{tabular}{l|l l}
\hline
\tablehead{Expression} & \tablehead{Description} & \tablehead{Details}\\
\hline
\hline
{\lstinline!div($x$, $y$)!} & Division with truncation toward zero & \Cref{modelica:div} \\
{\lstinline!mod($x$, $y$)!} & Integer modulus & \Cref{modelica:mod} \\
{\lstinline!rem($x$, $y$)!} & Integer remainder & \Cref{modelica:rem} \\
{\lstinline!ceil($x$)!} & Smallest integer {\lstinline!Real!} not less than $x$ & \Cref{modelica:ceil} \\
{\lstinline!floor($x$)!} & Largest integer {\lstinline!Real!} not greater than $x$ & \Cref{modelica:floor} \\
{\lstinline!integer($x$)!} & Largest {\lstinline!Integer!} not greater than $x$ & \Cref{modelica:integer} \\
{\lstinline!delay($\ldots$)!} & Time delay & \Cref{modelica:delay} \\
\hline
\end{tabular}
\end{center}

Except for the \lstinline!noEvent!-case the expressions \lstinline!div!, \lstinline!ceil!, \lstinline!floor!, and \lstinline!integer! can only change values at events, and will trigger events as needed.
The event triggering expressions for \lstinline!mod(x,y)! is \lstinline!floor(x/y)!, and for \lstinline!rem(x,y)! it is \lstinline!div(x,y)! -- i.e., the expressions \lstinline!mod! and \lstinline!rem! do not only change values at events, but events are triggered at the points of discontinuous change.
The event triggering expression for \lstinline!delay! is the time remaining until the next discontinuity in the operator value.

\begin{nonnormative}
If this is not desired, the \lstinline!noEvent! operator can be applied to them.
E.g., \lstinline!noEvent(integer(v))!.
\end{nonnormative}

\begin{operatordefinition}[div]
\begin{synopsis}\begin{lstlisting}
div($x$, $y$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Algebraic quotient $x / y$ with any fractional part discarded (also known as truncation toward zero).
\begin{nonnormative}
This is defined for \lstinline!/! in C99; in C89 the result for negative numbers is implementation-defined, so the standard function \lstinline[language=C]!div! must be used.
\end{nonnormative}
Result and arguments shall have type \lstinline!Real! or \lstinline!Integer!.
If either of the arguments is \lstinline!Real! the result is \lstinline!Real! otherwise \lstinline!Integer!.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[mod]
\begin{synopsis}\begin{lstlisting}
mod($x$, $y$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Integer modulus of $x / y$, i.e., \lstinline!mod($x$, $y$) = $x$ - floor($x$ / $y$) * $y$!.
Result and arguments shall have type \lstinline!Real! or \lstinline!Integer!.
If either of the arguments is \lstinline!Real! the result is \lstinline!Real! otherwise \lstinline!Integer!.
\begin{nonnormative}
Note, outside of a \lstinline!when!-clause state events are triggered when the return value changes discontinuously.
Examples: \lstinline!mod(3, 1.4) = 0.2!, \lstinline!mod(-3, 1.4) = 1.2!, \lstinline!mod(3, -1.4) = -1.2!.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[rem]
\begin{synopsis}\begin{lstlisting}
rem($x$, $y$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Integer remainder of $x / y$, such that \lstinline!div($x$, $y$) * $y$ + rem($x$, $y$) = $x$!.
Result and arguments shall have type \lstinline!Real! or \lstinline!Integer!.
If either of the arguments is \lstinline!Real! the result is \lstinline!Real! otherwise \lstinline!Integer!.
\begin{nonnormative}
Note, outside of a \lstinline!when!-clause state events are triggered when the return value changes discontinuously.
Examples: \lstinline!rem(3, 1.4) = 0.2!, \lstinline!rem(-3, 1.4) = -0.2!.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[ceil]
\begin{synopsis}\begin{lstlisting}
ceil($x$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Smallest integer not less than $x$.
Result and argument shall have type \lstinline!Real!.
\begin{nonnormative}
Note, outside of a \lstinline!when!-clause state events are triggered when the return value changes discontinuously.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[floor]
\begin{synopsis}\begin{lstlisting}
floor($x$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Largest integer not greater than $x$.
Result and argument shall have type \lstinline!Real!.
\begin{nonnormative}
Note, outside of a \lstinline!when!-clause state events are triggered when the return value changes discontinuously.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[integer]
\begin{synopsis}\begin{lstlisting}
integer($x$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Largest integer not greater than $x$.
The argument shall have type \lstinline!Real!.
The result has type \lstinline!Integer!.
\begin{nonnormative}
Note, outside of a \lstinline!when!-clause state events are triggered when the return value changes discontinuously.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[delay]
\begin{synopsis}\begin{lstlisting}
delay($\mathit{expr}$, $\mathit{delayTime}$, $\mathit{delayMax}$)
delay($\mathit{expr}$, $\mathit{delayTime}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Evaluates to:
\begin{equation*}
\begin{cases}
\mathit{expr}(\text{\lstinline!time.start!}) & \text{\lstinline!time!} - \mathit{delayTime} \leq \text{\lstinline!time.start!}\\
\mathit{expr}(\text{\lstinline!time!} - \mathit{delayTime}) & \text{otherwise}
\end{cases}
\end{equation*}

When a \lstinline!delay!-expression is discrete-time (see \cref{discrete-time-expressions}), events will be generated in order to allow the value to change at the correct points in time.
Further, when a \lstinline!delay!-expression is non-discrete-time and event generation is enabled (not appearing inside \lstinline!noEvent!), events may also be generated in order to preserve discontinuities in $\mathit{expr}$.
It is a quality of implementation to avoid excessive generation of events by only preserving significant discontinuities.

The expression $\mathit{expr}$ shall be a subtype of \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, or an enumeration type.
The time arguments, $\mathit{delayTime}$ and $\mathit{delayMax}$, shall be subtypes of \lstinline!Real!.
The type of the result is the same as the type of $\mathit{expr}$.

When provided, $\mathit{delayMax}$ shall be a parameter expression, and it shall hold that $0 \leq \mathit{delayTime} \leq \mathit{delayMax}$.
When $\mathit{delayMax}$ is not provided, $\mathit{delayTime} \geq 0$ shall be a parameter expression.
The operator is not allowed inside \lstinline!function! classes.
For non-scalar arguments the function is vectorized according to \cref{vectorized-calls-of-functions}.
For further details, see \cref{delay}.
\end{semantics}
\end{operatordefinition}


\subsubsection{delay}\label{delay}

\begin{nonnormative}
\lstinline!delay! allows a numerical sound implementation by interpolating in the (internal) integrator polynomials, as well as a more simple realization by interpolating linearly in a buffer containing past values of expression $\mathit{expr}$.
Without further information, the complete time history of the delayed signals needs to be stored, because the delay time may change during simulation.
To avoid excessive storage requirements and to enhance efficiency, the maximum allowed delay time has to be given via $\mathit{delayMax}$.
This gives an upper bound on the values of the delayed signals which have to be stored.
For real-time simulation where fixed step size integrators are used, this information is sufficient to allocate the necessary storage for the internal buffer before the simulation starts.
For variable step size integrators, the buffer size is dynamic during integration.

In principle, \lstinline!delay! could break algebraic loops.
For simplicity, this is not supported because the minimum delay time has to be given as additional argument to be fixed at compile time.
Furthermore, the maximum step size of the integrator is limited by this minimum delay time in order to avoid extrapolation in the delay buffer.
\end{nonnormative}


\subsection{Elementary Mathematical Functions}\label{built-in-mathematical-functions-and-external-built-in-functions}

The functions listed below are elementary mathematical functions.
Tools are expected to utilize well known properties of these functions (derivatives, inverses, etc) for symbolic processing of expressions and equations.
\begin{center}
\begin{tabular}{l|l l}
\hline
\tablehead{Expression} & \tablehead{Description} & \tablehead{Details}\\
\hline
\hline
{\lstinline!sin($x$)!}        \indexinline{sin}   & Sine & \\
{\lstinline!cos($x$)!}        \indexinline{cos}   & Cosine & \\
{\lstinline!tan($x$)!}        \indexinline{tan}   & Tangent ($x$ shall not be: $\ldots$, -$\pi/2$, $\pi/2$, $3\pi/2$, $\ldots$) & \\
{\lstinline!asin($x$)!}       \indexinline{asin}  & Inverse sine ($-1 \le x \le 1$) & \\
{\lstinline!acos($x$)!}       \indexinline{acos}  & Inverse cosine ($-1 \le x \le 1$) & \\
{\lstinline!atan($x$)!}       \indexinline{atan}  & Inverse tangent & \\
{\lstinline!atan2($y$, $x$)!} \indexinline{atan2} & Principal value of the arc tangent of $y/x$ & \Cref{modelica:atan2} \\
{\lstinline!sinh($x$)!}       \indexinline{sinh}  & Hyperbolic sine & \\
{\lstinline!cosh($x$)!}       \indexinline{cosh}  & Hyperbolic cosine & \\
{\lstinline!tanh($x$)!}       \indexinline{tanh}  & Hyperbolic tangent & \\
{\lstinline!exp($x$)!}        \indexinline{exp}   & Exponential, base $\mathrm{e}$ & \\
{\lstinline!log($x$)!}        \indexinline{log}   & Natural (base $\mathrm{e}$) logarithm ($x > 0$) & \\
{\lstinline!log10($x$)!}      \indexinline{log10} & Base 10 logarithm ($x > 0$) & \\
\hline
\end{tabular}
\end{center}

These functions are the only ones that can also be called using the deprecated \lstinline!"builtin"! external language, see \cref{external-function-interface}.

\begin{nonnormative}
End user oriented information about the elementary mathematical functions can be found for the corresponding functions in the \lstinline!Modelica.Math! package.
\end{nonnormative}

\begin{functiondefinition}[atan2]
\begin{synopsis}\begin{lstlisting}
atan2($y$, $x$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Principal value of the arc tangent of $y/x$, using the signs of the two arguments to determine the quadrant of the result.
The result $\varphi$ is in the interval $\left[-\pi,\, \pi\right]$ and satisfies:
\begin{equation*}
\begin{aligned}
\abs{(x,\, y)}\, \cos(\varphi) &= x\\
\abs{(x,\, y)}\, \sin(\varphi) &= y
\end{aligned}
\end{equation*}
\end{semantics}
\end{functiondefinition}

\subsection{Derivative and Special Purpose Operators with Function Syntax}\label{derivative-and-special-purpose-operators-with-function-syntax}

The operators listed below include the derivative operator and special purpose operators with function syntax.
\begin{center}
\begin{tabular}{l|l l}
\hline
\tablehead{Expression} & \tablehead{Description} & \tablehead{Details}\\
\hline
\hline
{\lstinline!der($\mathit{expr}$)!} & Time derivative & \Cref{modelica:der} \\
{\lstinline!cardinality($c$)!} & Number of occurrences in {\lstinline!connect!}-equations & \Cref{modelica:cardinality} \\
{\lstinline!homotopy($\mathit{actual}$, $\mathit{simplified}$)!} & Homotopy initialization & \Cref{modelica:homotopy} \\
{\lstinline!semiLinear($x$, $k^{+}$, $k^{-}$)!} & Sign-dependent slope & \Cref{modelica:semiLinear} \\
{\lstinline!inStream($v$)!} & Stream variable flow into component & \Cref{modelica:inStream} \\
{\lstinline!actualStream($v$)!} & Actual value of stream variable & \Cref{modelica:actualStream} \\
{\lstinline!spatialDistribution($\ldots$)!} & Variable-speed transport & \Cref{modelica:spatialDistribution} \\
{\lstinline!getInstanceName()!} & Name of instance at call site & \Cref{modelica:getInstanceName} \\
\hline
\end{tabular}
\end{center}

The special purpose operators with function syntax where the call below uses named arguments can be called with named arguments (with the specified names), or with positional arguments (the inputs of the functions are in the order given in the calls below).

\begin{operatordefinition}[der]
\begin{synopsis}\begin{lstlisting}
der($\mathit{expr}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
The time derivative of $\mathit{expr}$.
If the expression $\mathit{expr}$ is a scalar it needs to be a subtype of \lstinline!Real!.
The expression and all its time-varying subexpressions must be continuous and semi-differentiable.
An exception is when the operator \lstinline!reinit! (\Cref{modelica:reinit}) is activated, as not even states are continuous.
The operator is not allowed inside \lstinline!function! classes.
If $\mathit{expr}$ is an array, the operator is applied to all elements of the array.
For non-scalar arguments the function is vectorized according to \cref{vectorized-calls-of-functions}.
\begin{nonnormative}
For \lstinline!Real! parameters and constants the result is a zero scalar or array of the same size as the variable.
\end{nonnormative}

\begin{example}
For continuous expression we have several cases.
\begin{lstlisting}[language=modelica]
  Real when1, x1, x2, x3, w1, y1, y2, y3;
equation
  when sample(1, 1) then
    when1 = $\ldots$;
  end when;
  x1 = if time>=0 then 0 else time; // Continuous
  x2 = if time<1 then 0 else time;  // Not continuous
  x3 = x1 * x2;    // The product is continuous, despite x2

  w1 = der(when1); // Explicitly illegal
  y1 = der(x1);    // Ok
  y2 = der(x2);    // Not ok at time=1
  y3 = der(x3);    // Ok
\end{lstlisting}
Since it is difficult to prove whether expressions are continuous, tools can dynamically check the continuity such that \lstinline!x2! only generates an error when the integration reaches the discontinuity.
\end{example}

\begin{example}
Exception for reinit:
\begin{lstlisting}[language=modelica]
  Real x4, x5, x6;
equation
  when sample(1, 1) then
    reinit(x4, 0);
  end when;
  der(x4) = time;
  x5 = x4^2;
  x6 = der(x5); // Allowed even if x5 is not continuous, since that is due to reinit
\end{lstlisting}
\end{example}

\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[cardinality]
\begin{synopsis}\begin{lstlisting}
cardinality($c$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
\begin{nonnormative}
This is a deprecated operator.
It should no longer be used, since it will be removed in one of the next Modelica releases.
\end{nonnormative}
Returns the number of (inside and outside) occurrences of connector instance $c$ in a \lstinline!connect!-equation as an \lstinline!Integer! number.
For further details, see \cref{cardinality-deprecated}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[homotopy]
\begin{synopsis}\begin{lstlisting}
homotopy(actual = $\mathit{actual}$, simplified = $\mathit{simplified}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
The scalar expressions $\mathit{actual}$ and $\mathit{simplified}$ are subtypes of \lstinline!Real!.
A Modelica translator should map this operator into either of the two forms:
\begin{enumerate}
\item
  Returns $\mathit{actual}$ (trivial implementation).
\item
  In order to solve algebraic systems of equations, the operator might during the solution process return a combination of the two arguments, ending at actual.
  \begin{example}
  $\mathit{actual} \cdot \lambda + \mathit{simplified} \cdot (1 - \lambda)$, where $\lambda$ is a homotopy parameter going from 0 to 1.
  \end{example}
  The solution must fulfill the equations for \lstinline!homotopy! returning $\mathit{actual}$.
\end{enumerate}
For non-scalar arguments the function is vectorized according to \cref{scalar-functions-applied-to-array-arguments}.
For further details, see \cref{homotopy}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[semiLinear]
\begin{synopsis}\begin{lstlisting}
semiLinear($x$, $k^{+}$, $k^{-}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns: \lstinline!smooth(0, if $x$ >= 0 then $k^{+}$ * $x$ else $k^{-}$ * $x$)!.
The result is of type \lstinline!Real!.
For non-scalar arguments the function is vectorized according to \cref{vectorized-calls-of-functions}.
For further details, see \cref{semilinear} (especially in the case when $x = 0$).
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[inStream]
\begin{synopsis}\begin{lstlisting}
inStream($v$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
\lstinline!inStream($v$)! is only allowed for stream variables $v$ defined in stream connectors, and is the value of the stream variable $v$ close to the connection point assuming that the flow is from the connection point into the component.
This value is computed from the stream connection equations of the flow variables and of the stream variables.
The operator is not allowed inside \lstinline!function! classes.
The operator is vectorizable.
For further details, see \cref{stream-operator-instream-and-connection-equations}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[actualStream]
\begin{synopsis}\begin{lstlisting}
actualStream($v$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
\lstinline!actualStream($v$)! returns the actual value of the stream variable $v$ for any flow direction.
The operator is not allowed inside \lstinline!function! classes.
The operator is vectorizable.
For further details, see \cref{stream-operator-actualstream}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[spatialDistribution]
\begin{synopsis}\begin{lstlisting}
spatialDistribution(
  in0 = $\mathit{in0}$, in1 = $\mathit{in1}$, x = $x$,
  positiveVelocity = $\ldots$,
  initialPoints = $\ldots$,
  initialValues = $\ldots$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
\lstinline!spatialDistribution! allows approximation of variable-speed transport of properties.
The operator is not allowed inside \lstinline!function! classes.
For further details, see \cref{spatialdistribution}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[getInstanceName]
\begin{synopsis}\begin{lstlisting}
getInstanceName()
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns a string with the name of the model/block that is simulated, appended with the fully qualified name of the instance in which this function is called.
For further details, see \cref{getinstancename}.
\end{semantics}
\end{operatordefinition}

A few of these operators are described in more detail in the following.

\subsubsection{spatialDistribution}\label{spatialdistribution}

\begin{nonnormative}
Many applications involve the modelling of variable-speed transport of properties.
One option to model this infinite-dimensional system is to approximate it by an ODE, but this requires a large number of state variables and might introduce either numerical diffusion or numerical oscillations.
Another option is to use a built-in operator that keeps track of the spatial distribution of $z(\xi, t)$, by suitable sampling, interpolation, and shifting of the stored distribution.
In this case, the internal state of the operator is hidden from the ODE solver.
\end{nonnormative}

\lstinline!spatialDistribution! allows the infinite-dimensional problem below to be solved efficiently with good accuracy
\begin{align*}
\frac{\partial z(\xi, t)}{\partial t} + v(t) \frac{\partial z(\xi, t)}{\partial \xi} &= 0\\
z(0, t) &= \mathrm{in}_{0}(t) \quad \text{if $v(t) \geq 0$}\\
z(1, t) &= \mathrm{in}_{1}(t) \quad \text{if $v(t) < 0$}
\end{align*}
where $z(\xi, t)$ is the transported quantity, $\xi$ is the normalized spatial coordinate ($0 \le \xi \le 1$), $t$ is the time, $v(t)$ is the normalized transport velocity and the boundary conditions are set at either $\xi = 0$ or $\xi = 1$, depending on the sign of the velocity.

The calling syntax is:
\begin{lstlisting}[language=modelica]
(out0, out1) = spatialDistribution(in0, in1, x, positiveVelocity,
                                   initialPoints = {0.0, 1.0},
                                   initialValues = {0.0, 0.0});
\end{lstlisting}
where \lstinline!in0!, \lstinline!in1!, \lstinline!out0!, \lstinline!out1!, and \lstinline!x! are all subtypes of \lstinline!Real!, \lstinline!positiveVelocity! is a \lstinline!Boolean!, and \lstinline!initialPoints! and \lstinline!initialValues! are arrays of subtypes of \lstinline!Real!.
The position \lstinline!x! is the integral of the transport velocity $v$, where the constant of integration does not matter.
The arrays \lstinline!initialPoints! and \lstinline!initialValues! shall be parameter expressions of equal size, containing the $\xi$ coordinates and the $z$ values of a finite set of points describing the initial distribution of $z(\xi, t_{0})$.
The \lstinline!out0! and \lstinline!out1! are given by the solutions at $z(0, t)$ and $z(1, t)$; and \lstinline!in0! and \lstinline!in1! are the boundary conditions at $z(0, t)$ and $z(1, t)$ (at each point in time only one of \lstinline!in0! and \lstinline!in1! is used).
The \lstinline!initialPoints! array shall span the entire range from 0 to 1, and must be sorted in non-descending order.
The operator can not be vectorized according to the vectorization rules described in \cref{scalar-functions-applied-to-array-arguments}.
The operator can be vectorized only with respect to the arguments \lstinline!in0! and \lstinline!in1! (which must have the same size), returning vectorized outputs \lstinline!out0! and \lstinline!out1! of the same size; the arguments \lstinline!initialPoints! and \lstinline!initialValues! are vectorized accordingly.

The solution, $z$, can be described in terms of characteristics:
\begin{equation*}
z(\xi+\int_{t}^{t+\beta}\! v(\alpha) \mathrm{d}\alpha,\, t+\beta) = z(\xi, t), \quad\text{for all $\beta$ as long as staying inside the domain}
\end{equation*}

This allows the direct computation of the solution based on interpolating the boundary conditions.

\lstinline!spatialDistribution! can be described in terms of the pseudo-code given as a block:
\begin{lstlisting}[language=modelica]
block spatialDistribution
  input Real in0;
  input Real in1;
  input Real x;
  input Boolean positiveVelocity;
  parameter Real initialPoints(each min=0, each max=1)[:] = {0.0, 1.0};
  parameter Real initialValues[:] = {0.0, 0.0};
  output Real out0;
  output Real out1;
protected
  Real points[:];
  Real values[:];
  Real x0;
  Integer m;
algorithm
  /* The notation
   *   x <and then> y
   * is used below as a shorthand for
   *   if x then y else false
   * also known as "short-circuit evaluation of x and y".
   */
  if positiveVelocity then
    out1 := interpolate(points, values, 1 - (x - x0));
    out0 := values[1]; // Similar to in0 but avoiding algebraic loop.
  else
    out0 := interpolate(points, values, 0 - (x - x0));
    out1 := values[end]; // Similar to in1 but avoiding algebraic loop.
  end if;
  when <acceptedStep> then
    if x > x0 then
      m := size(points, 1);
      while m > 0 <and then> points[m] + (x - x0) >= 1 loop
        m := m - 1;
      end while;
      values := cat(1,
                    {in0},
                    values[1:m],
                    {interpolate(points, values, 1 - (x - x0))});
      points := cat(1, {0}, points[1:m] .+ (x-x0), {1});
    elseif x < x0 then
      m := 1;
      while m < size(points, 1) <and then> points[m] + (x - x0) <= 0 loop
        m := m + 1;
      end while;
      values := cat(1,
                    {interpolate(points, values, 0 - (x - x0))},
                    values[m:end],
                    {in1});
      points := cat(1, {0}, points[m:end] .+ (x - x0), {1});
    end if;
    x0 := x;
  end when;
initial algorithm
  x0 := x;
  points := initialPoints;
  values := initialValues;
end spatialDistribution;
\end{lstlisting}

\begin{nonnormative}
Note that the implementation has an internal state and thus cannot be described as a function in Modelica; \lstinline!initialPoints! and \lstinline!initialValues! are declared as parameters to indicate that they are only used during initialization.

The infinite-dimensional problem stated above can then be formulated in the following way:
\begin{lstlisting}[language=modelica]
der(x) = v;
(out0, out1) = spatialDistribution(in0, in1, x, v >= 0,
                                   initialPoints, initialValues);
\end{lstlisting}

Events are generated at the exact instants when the velocity changes sign -- if this is not needed, \lstinline!noEvent! can be used to suppress event generation.

If the velocity is known to be always positive, then \lstinline!out0! can be omitted, e.g.:
\begin{lstlisting}[language=modelica]
der(x) = v;
(, out1) = spatialDistribution(in0, 0, x, true, initialPoints, initialValues);
\end{lstlisting}
Technically relevant use cases for the use of \lstinline!spatialDistribution! are modeling of electrical transmission lines, pipelines and pipeline networks for gas, water and district heating, sprinkler systems, impulse propagation in elongated bodies, conveyor belts, and hydraulic systems.
Vectorization is needed for pipelines where more than one quantity is transported with velocity \lstinline!v! in the example above.
\end{nonnormative}

\subsubsection{cardinality (deprecated)}\label{cardinality-deprecated}

\begin{nonnormative}
\lstinline!cardinality! is deprecated for the following reasons and will be removed in a future release:
\begin{itemize}
\item
  Reflective operator may make early type checking more difficult.
\item
  Almost always abused in strange ways
\item
  Not used for Bond graphs even though it was originally introduced for that purpose.
\end{itemize}
\end{nonnormative}

\begin{nonnormative}
\lstinline!cardinality! allows the definition of connection dependent equations in a model, for example:
\begin{lstlisting}[language=modelica]
connector Pin
  Real v;
  flow Real i;
end Pin;
model Resistor
  Pin p, n;
equation
  assert(cardinality(p) > 0 and cardinality(n) > 0,
         "Connectors p and n of Resistor must be connected");
  // Equations of resistor
  $\ldots$
end Resistor;
\end{lstlisting}
\end{nonnormative}

The cardinality is counted after removing conditional components, and shall not be applied to expandable connectors, elements in expandable connectors, or to arrays of connectors (but can be applied to the scalar elements of array of connectors).
\lstinline!cardinality! should only be used in the condition of assert and \lstinline!if!-statements that do not contain \lstinline!connect! and similar operators, see \cref{connect-equations}).
The operator is not allowed inside \lstinline!function! classes.

\subsubsection{homotopy}\label{homotopy}

\begin{nonnormative}
During the initialization phase of a dynamic simulation problem, it often happens that large nonlinear systems of equations must be solved by means of an iterative solver.
The convergence of such solvers critically depends on the choice of initial guesses for the unknown variables.
The process can be made more robust by providing an alternative, simplified version of the model, such that convergence is possible even without accurate initial guess values, and then by continuously transforming the simplified model into the actual model.
This transformation can be formulated using expressions of this kind:
\begin{equation*}
\lambda\cdot\text{\lstinline!actual!} + (1-\lambda)\cdot\text{\lstinline!simplified!}
\end{equation*}
in the formulation of the system equations, and is usually called a homotopy transformation.
If the simplified expression is chosen carefully, the solution of the problem changes continuously with $\lambda$, so by taking small enough steps it is possible to eventually obtain the solution of the actual problem.

The operator can be called with ordered arguments or preferably with named arguments for improved readability.

It is recommended to perform (conceptually) one homotopy iteration over the whole model, and not several homotopy iterations over the respective non-linear algebraic equation systems.
The reason is that the following structure can be present:
\begin{lstlisting}[language=modelica]
w = $f_1$(x) // has homotopy
0 = $f_2$(der(x), x, z, w)
\end{lstlisting}

Here, a non-linear equation system $f_2$ is present.
\lstinline!homotopy! is, however used on a variable that is an ``input'' to the non-linear algebraic equation system, and modifies the characteristics of the non-linear algebraic equation system.
The only useful way is to perform the homotopy iteration over $f_1$ and $f_2$ together.

The suggested approach is ``conceptual'', because more efficient implementations are possible, e.g., by determining the smallest iteration loop, that contains the equations of the first BLT block in which \lstinline!homotopy! is present and all equations up to the last BLT block that describes a non-linear algebraic equation system.

A trivial implementation of \lstinline!homotopy! is obtained by defining the following function in the global scope:
\begin{lstlisting}[language=modelica]
function homotopy
  input Real actual;
  input Real simplified;
  output Real y;
algorithm
  y := actual;
  annotation(Inline = true);
end homotopy;
\end{lstlisting}
\end{nonnormative}

\begin{example}[1]
In electrical systems it is often difficult to solve non-linear algebraic equations if switches are part of the algebraic loop.
An idealized diode model might be implemented in the following way, by starting with a ``flat'' diode characteristic and then move with \lstinline!homotopy! to the desired ``steep'' characteristic:
\begin{lstlisting}[language=modelica]
model IdealDiode
  $\ldots$
  parameter Real Goff = 1e-5;
protected
  Real Goff_flat = max(0.01, Goff);
  Real Goff2;
equation
  off = s < 0;
  Goff2 = homotopy(actual = Goff, simplified = Goff_flat);
  u = s * (if off then 1 else Ron2) + Vknee;
  i = s * (if off then Goff2 else 1 ) + Goff2*Vknee;
  $\ldots$
end IdealDiode;
\end{lstlisting}
\end{example}

\begin{example}[2]
In electrical systems it is often useful that all voltage sources start with zero voltage and all current sources with zero current, since steady state initialization with zero sources can be easily obtained.
A typical voltage source would then be defined as:
\begin{lstlisting}[language=modelica]
model ConstantVoltageSource
  extends Modelica.Electrical.Analog.Interfaces.OnePort;
  parameter Modelica.Units.SI.Voltage V;
equation
  v = homotopy(actual = V, simplified = 0.0);
end ConstantVoltageSource;
\end{lstlisting}
\end{example}

\begin{example}[3]
In fluid system modelling, the pressure/flowrate relationships are highly nonlinear due to the quadratic terms and due to the dependency on fluid properties.
A simplified linear model, tuned on the nominal operating point, can be used to make the overall model less nonlinear and thus easier to solve without accurate start values.
Named arguments are used here in order to further improve the readability.
\begin{lstlisting}[language=modelica]
model PressureLoss
  import Modelica.Units.SI;
  $\ldots$
  parameter SI.MassFlowRate m_flow_nominal "Nominal mass flow rate";
  parameter SI.Pressure dp_nominal "Nominal pressure drop";
  SI.Density rho "Upstream density";
  SI.DynamicViscosity lambda "Upstream viscosity";
equation
  $\ldots$
  m_flow = homotopy(actual = turbulentFlow_dp(dp, rho, lambda),
                    simplified = dp/dp_nominal*m_flow_nominal);
  $\ldots$
end PressureLoss;
\end{lstlisting}
\end{example}

\begin{example}[4] Note that \lstinline!homotopy! \emph{shall not} be used to combine unrelated expressions, since this can generate singular systems from combining two well-defined systems.
\begin{lstlisting}[language=modelica]
model DoNotUse
  Real x;
  parameter Real x0 = 0;
equation
  der(x) = 1-x;
initial equation
  0 = homotopy(der(x), x - x0);
end DoNotUse;
\end{lstlisting}

The initial equation is expanded into
\begin{equation*}
0 = \lambda*\mathrm{der}(x)+(1-\lambda)(x-x_0)
\end{equation*}
and you can solve the two equations to give
\begin{equation*}
x = \frac{\lambda+(\lambda-1)x_0}{2\lambda-1}
\end{equation*}
which has the correct value of $x_0$ at $\lambda = 0$ and of 1 at $\lambda = 1$, but unfortunately has a singularity at $\lambda = 0.5$.
\end{example}


\subsubsection{semiLinear}\label{semilinear}

(See definition of \lstinline!semiLinear! in \cref{derivative-and-special-purpose-operators-with-function-syntax}).
In some situations, equations with \lstinline!semiLinear! become underdetermined if the first argument (\lstinline!x!) becomes zero, i.e., there are an infinite number of solutions.
It is recommended that the following rules are used to transform the equations during the translation phase in order to select one meaningful solution in such cases:
\begin{itemize}
\item
The equations
\begin{lstlisting}[language=modelica]
y = semiLinear(x, sa, s1);
y = semiLinear(x, s1, s2);
y = semiLinear(x, s2, s3);
$\ldots$
y = semiLinear(x, sN, sb);
$\ldots$
\end{lstlisting}
may be replaced by
\begin{lstlisting}[language=modelica]
s1 = if x >= 0 then sa else sb
s2 = s1;
s3 = s2;
$\ldots$
$s_N = s_{N-1}$;
y = semiLinear(x, sa, sb);
\end{lstlisting}

\item
The equations
\begin{lstlisting}[language=modelica]
x = 0;
y = 0;
y = semiLinear(x, sa, sb);
\end{lstlisting}
may be replaced by
\begin{lstlisting}[language=modelica]
x = 0
y = 0;
sa = sb;
\end{lstlisting}
\end{itemize}

\begin{nonnormative}
For symbolic transformations, the following property is useful (this follows from the definition):
\begin{lstlisting}[language=modelica]
semiLinear(m_flow, port_h, h);
\end{lstlisting}
is identical to:
\begin{lstlisting}[language=modelica]
-semiLinear(-m_flow, h, port_h);
\end{lstlisting}

The \lstinline!semiLinear! function is designed to handle reversing flow in fluid systems, such as
\begin{lstlisting}[language=modelica]
H_flow = semiLinear(m_flow, port.h, h);
\end{lstlisting}
i.e., the enthalpy flow rate \lstinline!H_flow! is computed from the mass flow rate \lstinline!m_flow! and the upstream specific enthalpy depending on the flow direction.
\end{nonnormative}

\subsubsection{getInstanceName}\label{getinstancename}

Returns a string with the name of the model/block that is simulated, appended with the fully qualified name of the instance in which this function is called.

\begin{example}
\begin{lstlisting}[language=modelica]
package MyLib
  model Vehicle
    Engine engine;
    $\ldots$
  end Vehicle;
  model Engine
    Controller controller;
    $\ldots$
  end Engine;
  model Controller
  equation
    Modelica.Utilities.Streams.print("Info from: " + getInstanceName());
  end Controller;
end MyLib;
\end{lstlisting}
If \lstinline!MyLib.Vehicle! is simulated, the call of \lstinline!getInstanceName()! returns \lstinline!"Vehicle.engine.controller"!.
\end{example}

If this function is not called inside a model or block (e.g., the function is called in a function or in a constant of a package), the return value is not specified.

The simulation result should not depend on the return value of this function.

\subsection{Event-Related Operators with Function Syntax}\label{event-related-operators-with-function-syntax}

The operators listed below are event-related operators with function syntax.
The operators \lstinline!noEvent!, \lstinline!pre!, \lstinline!edge!, and \lstinline!change!, are vectorizable according to \cref{scalar-functions-applied-to-array-arguments}.
\begin{center}
\begin{tabular}{l|l l}
\hline
\tablehead{Expression} & \tablehead{Description} & \tablehead{Details}\\
\hline
\hline
{\lstinline!initial()!} & Predicate for the initialization phase & \Cref{modelica:initial}\\
{\lstinline!terminal()!} & Predicate for the end of a successful analysis & \Cref{modelica:terminal}\\
{\lstinline!noEvent($\mathit{expr}$)!} & Evaluate $\mathit{expr}$ without triggering events & \Cref{modelica:noEvent}\\
{\lstinline!smooth($p$, $\mathit{expr}$)!} & Treat $\mathit{expr}$ as $p$ times continuously differentiable & \Cref{modelica:smooth}\\
{\lstinline!sample($\mathit{start}$, $\mathit{interval}$)!} & Periodic triggering of events & \Cref{modelica:event-sample}\\
{\lstinline!pre($y$)!} & Left limit $y(t^{-})$ of variable $y(t)$ & \Cref{modelica:pre}\\
{\lstinline!edge($b$)!} & Expands into {\lstinline!($b$ and not pre($b$))!} & \Cref{modelica:edge}\\
{\lstinline!change($v$)!} & Expands into {\lstinline!($v$ <> pre($v$))!} & \Cref{modelica:change}\\
{\lstinline!reinit($x$, $\mathit{expr}$)!} & Reinitialize $x$ with $\mathit{expr}$ & \Cref{modelica:reinit}\\
\hline
\end{tabular}
\end{center}

\begin{operatordefinition}[initial]
\begin{synopsis}\begin{lstlisting}
initial()
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns \lstinline!true! during the initialization phase and \lstinline!false! otherwise.
The operator is not allowed inside \lstinline!function! classes.
\begin{nonnormative}
Hereby, \lstinline!initial()! triggers a time event at the beginning of a simulation.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[terminal]
\begin{synopsis}\begin{lstlisting}
terminal()
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns \lstinline!true! at the end of a successful analysis.
The operator is not allowed inside \lstinline!function! classes.
\begin{nonnormative}
Hereby, \lstinline!terminal()! ensures an event at the end of successful simulation.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[noEvent]
\begin{synopsis}\begin{lstlisting}
noEvent($\mathit{expr}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
\lstinline!Real! elementary relations within $\mathit{expr}$ are taken literally, i.e., no state or time event is triggered.
No zero crossing functions shall be used to monitor any of the normally event-generating subexpressions inside $\mathit{expr}$.
Inside functions, \lstinline!noEvent! only makes a difference in combination with the function annotation \lstinline!GenerateEvents = true! (see \cref{modelica:GenerateEvents}).
See also \crefnameref{modelica:smooth} and \cref{events-and-synchronization}.
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[smooth]
\begin{synopsis}\begin{lstlisting}
smooth($p$, $\mathit{expr}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
If $p \geq 0$ \lstinline!smooth($p$, $\mathit{expr}$)! returns $\mathit{expr}$ and states that $\mathit{expr}$ is $p$ times continuously differentiable, i.e., $\mathit{expr}$ is continuous in all \lstinline!Real! variables appearing in the expression and all partial derivatives with respect to all appearing real variables exist and are continuous up to order $p$.
The argument $p$ should be a scalar \lstinline!Integer! parameter expression.
The only allowed types for $\mathit{expr}$ in \lstinline!smooth! are: \lstinline!Real! expressions, arrays of allowed expressions, and records containing only components of allowed expressions.

\lstinline!smooth! should be used instead of \lstinline!noEvent! in order to avoid events for efficiency reasons.
A tool is free to not generate events for expressions inside \lstinline!smooth!.
However, \lstinline!smooth! does not guarantee that no events will be generated, and thus it can be necessary to use \lstinline!noEvent! inside \lstinline!smooth!.

\begin{nonnormative}
Note that \lstinline!smooth! does not guarantee a smooth output if any of the occurring variables change discontinuously.
\end{nonnormative}

\begin{example}
\begin{lstlisting}[language=modelica]
  Real x, y, z;
equation
  x = if time < 1 then 2 else time - 2;
  z = smooth(0, if time < 0 then 0 else time);
  y = smooth(1,
        noEvent(if x < 0 then 0 else sqrt(x) * x)); // Needs noEvent.
\end{lstlisting}
\end{example}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition*}[sample]\label{modelica:event-sample}\index{sample@\robustinline{sample}!event-generating}
\begin{synopsis}\begin{lstlisting}
sample($\mathit{start}$, $\mathit{interval}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns \lstinline!true! and triggers time events at time instants $\mathit{start} + i \cdot \mathit{interval}$ for $i = 0,\, 1\, \ldots$, and is only true during the first event iteration at those times.
At event iterations after the first one at each event and during continuous integration the operator always returns \lstinline!false!.
The starting time $\mathit{start}$ and the sample interval $\mathit{interval}$ must be parameter expressions and need to be a subtype of \lstinline!Real! or \lstinline!Integer!.
The sample interval $\mathit{interval}$ must be a positive number.
The operator is not allowed inside \lstinline!function! classes.
\end{semantics}
\end{operatordefinition*}

\begin{operatordefinition}[pre]
\begin{synopsis}\begin{lstlisting}
pre($y$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Returns the \emph{left limit} $y(t^{-})$ of variable $y(t)$ at a time instant $t$.
At an event instant, $y(t^{-})$ is the value of $y$ after the last event iteration at time instant $t$ (see comment below).
% Warning "component expression" is a term defined for synchronous operator argument restrictions; this seems to conflict with also defining the present argument restriction below.
Any subscripts in the component expression $y$ must be parameter expressions.
The operator is not allowed inside \lstinline!function! classes.
\lstinline!pre! can be applied to the variable $y$ only if $y$ is a discrete-time expression and $y$ is either a subtype of a simple type or is a record component.
\begin{nonnormative}
This can be applied to continuous-time variables in \lstinline!when!-clauses, see \cref{discrete-time-expressions} for the definition of discrete-time expression.
\end{nonnormative}
The first value of \lstinline!pre($y$)! is determined in the initialization phase.

A new event is triggered if there is at least for one variable \lstinline!v! such that \lstinline!pre(v) <> v! after the active model equations are evaluated at an event instant.
In this case the model is at once reevaluated.
This evaluation sequence is called \emph{event iteration}.
The integration is restarted once \lstinline!pre(v) == v! for all \lstinline!v! appearing inside \lstinline!pre($\ldots$)!.

\begin{nonnormative}
If \lstinline!v! and \lstinline!pre(v)! are only used in \lstinline!when!-clauses, the translator might mask event iteration for variable \lstinline!v! since \lstinline!v! cannot change during event iteration.
It is a quality of implementation to find the minimal loops for event iteration, i.e., not all parts of the model need to be reevaluated.

The language allows mixed algebraic systems of equations where the unknown variables are of type \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, or an enumeration.
These systems of equations can be solved by a global fix point iteration scheme, similarly to the event iteration, by fixing the \lstinline!Boolean!, \lstinline!Integer!, and/or enumeration unknowns during one iteration.
Again, it is a quality of implementation to solve these systems more efficiently, e.g., by applying the fix point iteration scheme to a subset of the model equations.
\end{nonnormative}
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[edge]
\begin{synopsis}\begin{lstlisting}
edge($b$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Expands into \lstinline!($b$ and not pre($b$))! for \lstinline!Boolean! variable $b$.
The same restrictions as for \lstinline!pre! apply (e.g., not to be used in \lstinline!function! classes).
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[change]
\begin{synopsis}\begin{lstlisting}
change(v)
\end{lstlisting}\end{synopsis}
\begin{semantics}
Expands into \lstinline!($v$ <> pre($v$))!.
The same restrictions as for \lstinline!pre! apply (e.g., not to be used in \lstinline!function! classes).
\end{semantics}
\end{operatordefinition}

\begin{operatordefinition}[reinit]
\begin{synopsis}\begin{lstlisting}
reinit($x$, $\mathit{expr}$)
\end{lstlisting}\end{synopsis}
\begin{semantics}
In the body of a \lstinline!when!-clause, reinitializes $x$ with $\mathit{expr}$ at an event instant.
$x$ is a scalar or array \lstinline!Real! variable that is implicitly defined to have \lstinline!StateSelect.always!.
\begin{nonnormative}
It is an error if the variable cannot be selected as a state.
\end{nonnormative}
$\mathit{expr}$ needs to be type-compatible with $x$.
\lstinline!reinit! can only be applied once for the same variable -- either as an individual variable or as part of an array of variables.
It can only be applied in the body of a \lstinline!when!-clause in an equation section.
See also \cref{reinit}.
\end{semantics}
\end{operatordefinition}

\section{Variability of Expressions}\label{variability-of-expressions}

The concept of \firstuse[expression variability]{variability of an expression}\index{variability!expression|see{expression variability}} indicates to what extent the expression can vary over time.
See also \cref{component-variability} regarding the concept of variability.
% It seems wrong to not mention 'clocked discrete-time' here.
There are four levels of variability of expressions, starting from the least variable:
\begin{itemize}
\item
  constant variability
\item
  parameter variability
\item
  discrete-time variability
\item
  continuous-time variability
\end{itemize}

While many invalid models can be rejected based on the declared variabilities of variables alone (without the concept of expression variability), the following rules both help enforcing compliance of computed solutions to declared variability, and impose additional restrictions that simplify reasoning and reporting of errors:
\begin{itemize}
\item
  For an assignment \lstinline!v := expr! or binding equation \lstinline!v = expr!, \lstinline!v! must be declared to be at least as variable as \lstinline!expr!.
\item
  For multiple return assignment \lstinline!(x1, $\ldots$, xn) := expr! (see \cref{assignments-from-called-functions-with-multiple-results}), all of \lstinline!x1!, \ldots, \lstinline!xn! must be declared to be at least as variable as \lstinline!expr!.
\item
  When determining whether an equation can contribute to solving for a variable \lstinline!v! (for instance, when applying the perfect matching rule, see \cref{synchronous-data-flow-principle-and-single-assignment-rule}), the equation can only be considered contributing if the resulting solution would be at most as variable as \lstinline!v!.
\end{itemize}

\begin{example}
The (underdetermined) model \lstinline!Test! below illustrates two kinds of consequences due to variability constraints.
First, it contains variability errors for declaration equations and assignments.
Second, it illustrates the impact of variability on the matching of equations to variables, which can lead to violation of the perfect matching rule.
Details of how variabilities are determined are given in the sections below.
The \willintroduce{discrete-valued equation variability rule} mentioned in the comments below refer to the rule in \cref{discrete-time-expressions} that requires both sides of the \lstinline!Boolean! equation to be discrete-time.
\begin{lstlisting}[language=modelica]
model Constants
  parameter Real p1 = 1;
  constant Real c1 = p1 + 2; // Error, not a constant expression.
  parameter Real p2 = p1 + 2; // Fine.
end Constants;
model Test
  Constants c1(p1 = 3); // Fine.
  Constants c2(p2 = 7); // Fine, declaration equation can be modified.
  Real x;
  Boolean b1 = noEvent(x > 1); // Error, since b1 is a discrete-time variable
                               // and noEvent(x > 1) is not discrete-time.
  Boolean b2;
  Integer i1;
  Integer i2;
algorithm
  i1 := x; // Error, assignment to variable of lesser variability.
equation
  /* The equation below can be rejected for two reasons:
   * 1. Discrete-valued equation variability rule requires both sides to be
   *    discrete-time.
   * 2. It violates the perfect matching rule, as no variable can be solved
   *    with correct variability using this equation.
   */
  b2 = noEvent(x > 1); // Error, see above.
  i2 = x;              // No variability error, and can be matched to x.
end Test;
\end{lstlisting}
\end{example}

\subsection{Function Variability}\label{function-variability}

The variability of function calls needs to consider both the variability of arguments directly given in the function and the variability of the used default arguments, if any.
This is especially a concern for functions given as a short class, see \cref{inheritance-of-functions}.
This has additional implications for redeclarations, see \cref{function-compatibility}.
The purity of the function, see \cref{pure-modelica-functions}, does not influence the variability of the function call.

\begin{nonnormative}
The restrictions for calling functions declared as \lstinline!impure! serve a similar purpose as the variability restrictions, see \cref{pure-modelica-functions}, and thus it is not necessary to consider purity in the definition of variability.
Consider a function reading an external file and returning some value from that file.
Different uses can have the file updated before the simulation (as a parameter-expression), or during the simulation (as a discrete-time expression).
Thus it depends on the use case and the specific file, not the function itself, and it would even be possible to update the file in continuous time (as part of an algorithm) and still use the same function.
\end{nonnormative}

\subsection{Constant Expressions}\label{constant-expressions}

Constant expressions\index{constant!expression}\index{expression variability!constant} are:
\begin{itemize}
\item
  \lstinline!Real!, \lstinline!Integer!, \lstinline!Boolean!, \lstinline!String!, and \lstinline!enumeration! literals.
\item
  Constant variables, see \cref{component-variability}.
\item
  Except for the special built-in operators \lstinline!initial!, \lstinline!terminal!, \lstinline!der!, \lstinline!edge!, \lstinline!change!, \lstinline!sample!, and \lstinline!pre!, a function or operator with constant subexpressions as argument (and no parameters defined in the function) is a constant expression.
\item
  Some function calls are constant expressions regardless of the arguments:
  \begin{itemize}
  \item
    \lstinline!ndims(A)!
  \end{itemize}
\item
  Some function calls are constant expressions even if one or more arguments are not:
  \begin{itemize}
  \item
    \lstinline!delay($x$, $\ldots$)! where $x$ is a constant expression.
  \end{itemize}
\end{itemize}

\subsection{Evaluable Expressions}\label{evaluable-expressions}

Evaluable expressions\index{evaluable expression}\index{expression variability!evaluable} are:
\begin{itemize}
\item
  Constant expressions.
\item
  Evaluable parameter variables, see \cref{component-variability}.
\item
  Input variables in functions not having annotation \lstinline!GenerateEvents = true! (\cref{modelica:GenerateEvents}) behave as though they were evaluable expressions.
\item
  Except for the special built-in operators \lstinline!initial!, \lstinline!terminal!, \lstinline!der!, \lstinline!edge!, \lstinline!change!, \lstinline!sample!, and \lstinline!pre!, a function or operator with evaluable subexpressions is an evaluable expression.
\item
  The sub-expression \lstinline!end! used in \lstinline!A[$\ldots$ end $\ldots$]! if \lstinline!A! is a variable declared in a non-\lstinline!function! class.
\item
  Some function calls are evaluable expressions even if one or more arguments are not:
  \begin{itemize}
  \item
    \lstinline!size(A)! (including \lstinline!size(A, j)! where \lstinline!j! is an evaluable expression) if \lstinline!A! is variable declared in a non-function class.
  \item
    \lstinline!delay($x$, $\ldots$)! where $x$ is an evaluable expression.
  \item
    \lstinline!Connections.isRoot(A.R)!
  \item
    \lstinline!Connections.rooted(A.R)!
  \item
    \lstinline!cardinality(c)!, see restrictions for use in \cref{cardinality-deprecated}.
  \end{itemize}
\end{itemize}

\subsection{Parameter Expressions}\label{parameter-expressions}

Parameter expressions\index{parameter!expression}\index{expression variability!parameter}\index{parametric variability|see{parameter, expression}} are:
\begin{itemize}
\item
  Evaluable expressions.
\item
  Non-evaluable parameter variables, see \cref{component-variability}.
\item
  Except for the special built-in operators \lstinline!initial!, \lstinline!terminal!, \lstinline!der!, \lstinline!edge!, \lstinline!change!, \lstinline!sample!, and \lstinline!pre!, a function or operator with parameter subexpressions is a parameter expression.
\item
  Some function calls are parameter expressions even if one or more arguments are not:
  \begin{itemize}
  \item
    \lstinline!size(A, j)! where \lstinline!j! is a parameter expression, if \lstinline!A! is variable declared in a non-function class.
  \item
    \lstinline!delay($x$, $\ldots$)! where $x$ is a parameter expression.
  \end{itemize}
\end{itemize}

\subsection{Discrete-Time Expressions}\label{discrete-time-expressions}

Discrete-time expressions\index{discrete-time!expression}\index{expression variability!discrete-time} are:
\begin{itemize}
\item
  Parameter expressions.
\item
  Discrete-time variables, see \cref{component-variability}.
\item
  Function calls where all input arguments of the function are discrete-time expressions.
\item
  Expressions where all the subexpressions are discrete-time expressions.
\item
  Expressions in the body of a \lstinline!when!-clause, \lstinline!initial equation!, or \lstinline!initial algorithm!.
\item
  Expressions in a clocked discrete-time partition, see \cref{clocked-discrete-time-and-clocked-discretized-continuous-time-partition}.
\item
  Unless inside \lstinline!noEvent!: Ordered relations (\lstinline!>!, \lstinline!<!, \lstinline!>=!, \lstinline!<=!) and the event generating functions \lstinline!ceil!, \lstinline!floor!, \lstinline!div!, and \lstinline!integer!, if at least one argument is non-discrete-time expression and subtype of \lstinline!Real!.
  \begin{nonnormative}
  These will generate events, see \cref{events-and-synchronization}.
  Note that \lstinline!rem! and \lstinline!mod! generate events but are not discrete-time expressions.
  In other words, relations inside \lstinline!noEvent!, such as \lstinline!noEvent(x>1)!, are not discrete-time expressions.
  \end{nonnormative}
\item
  Unless inside \lstinline!noEvent!: \lstinline!delay($x$, $\ldots$)!, if $x$ is a discrete-time expression.
\item
  Unless inside \lstinline!noEvent!: Function calls where the function has annotation \lstinline!GenerateEvents = true! (\cref{modelica:GenerateEvents}), the output does not contain a subtype of \lstinline!Real!, and any non-\lstinline!Real! inputs have discrete-time variability.
  For a function call returning multiple return values (see \cref{output-formal-parameters-of-functions}) the variability is decided separately for each output.
\item
  The functions \lstinline!pre!, \lstinline!edge!, and \lstinline!change! result in discrete-time expressions.
\item
  Expressions in functions not having annotation \lstinline!GenerateEvents = true! (\cref{modelica:GenerateEvents}), behave as though they were discrete-time expressions.
\end{itemize}

Inside an \lstinline!if!-expression, \lstinline!if!-clause, \lstinline!while!-statement or \lstinline!for!-clause, that is controlled by a non-discrete-time (that is continuous-time, but not discrete-time) switching expression and not in the body of a \lstinline!when!-clause, it is not legal to have assignments to discrete-time variables, equations between discrete-time expressions, or real elementary relations/functions that should generate events.

\begin{nonnormative}
The restriction above is necessary in order to guarantee that all equations for discrete-time variable are discrete-time expressions, and to ensure that crossing functions do not become active between events.
\end{nonnormative}

For a scalar or array equation \lstinline!expr1 = expr2! where neither expression is of base type \lstinline!Real!, both expressions must be discrete-time expressions.
For a record equation, the rule applies recursively to each of the components of the record.
This is called the \firstuse{discrete-valued equation variability rule}.

\begin{nonnormative}
For a scalar equation, the rule follows from the observation that a discrete-valued equation does not provide sufficient information to solve for a continuous-valued variable.
Hence, and according to the perfect matching rule (see \cref{synchronous-data-flow-principle-and-single-assignment-rule}), such an equation must be used to solve for a discrete-valued variable.
By the interpretation of \eqref{eq:dae-discrete-valued} in \cref{modelica-dae-representation}, it follows that one of \lstinline!expr1! and \lstinline!expr2! must be the variable, and the other expression its solution.
Since a discrete-valued variable is a discrete-time expression, it follows that its solution on the other side of the equation must have at most discrete-time variability.
That is, both sides of the equation are discrete-time expressions.

For example, this rule shows that (outside of a \lstinline!when!-clause) \lstinline!noEvent! cannot be applied to either side of a \lstinline!Boolean!, \lstinline!Integer!, \lstinline!String!, or \lstinline!enumeration! equation, as this would result in a non-discrete-time expression.

For an array equation, note that each array can have only one element type, so if one element is \lstinline!Real!, then all other entries must also be \lstinline!Real!, possibly making use of standard type coercion, \cref{standard-type-coercion}.
Hence, if the base type is not \lstinline!Real!, all elements of the array are discrete-valued, allowing the argument above for a scalar equation to be applied elementwise to the array equation.
That is, all array elements on both sides of the array equation will have discrete-time variability, showing that also the entire arrays \lstinline!expr1! and \lstinline!expr2! are discrete-time expressions.

For a record equation, the components of the record have independent types, and the equation is seen as a collection of equations for the individual components of the record.
In order to support records with components of mixed variability, a record equation with sides given by either record variables or record constructors is conceptually split before variability is determined.
\end{nonnormative}

\begin{example}
Discrete-valued equation variability rule applied to record equations.
In the first of the equations below, having a record constructor on both sides of the equation, the equation is conceptually split, and variabilities of \lstinline!time! and \lstinline!true! are considered separately.
In the second equation, the \lstinline!makeR! function call -- regardless of inlining -- means that the equation cannot be conceptually split into individual components of the record.
The variability of the \lstinline!makeR! call is continuous-time due to the \lstinline!time! argument, which also becomes the variability of the \lstinline!b! member of the call.
\begin{lstlisting}[language=modelica]
record R
  Real x;
  Boolean b;
end R;

function makeR "Function wrapper around record constructor"
  input Real xx;
  input Boolean bb;
  output R r = R(xx, bb);
  annotation(Inline = true); // Inlining doesn't help.
end makeR;

model Test
  R r1, r2;
equation
  r1 = R(time, true);     // OK: Discrete-time Boolean member.
  r2 = makeR(time, true); // Error: Continuous-time Boolean member.
end Test;
\end{lstlisting}
\end{example}

\subsection{Continuous-Time and Non-Discrete-Time Expressions}\label{continuous-time-expressions}

All expressions are continuous-time expressions\index{continuous-time!expression}\index{expression variability!continuous-time} including constant, parameter and discrete-time expressions.
The term \firstuse{non-discrete-time expression}\index{expression variability!non-discrete-time} refers to expressions that are neither constant, parameter nor discrete-time expressions.
For example, \lstinline!time! is a continuous-time built-in variable (see \cref{component-variability}) and \lstinline!time + 1! is a non-discrete-time expression.
Note that plain \lstinline!time! may, depending on context, refer to the continuous-time variable or the non-discrete-time expression.
